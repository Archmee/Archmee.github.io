<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archmee</title>
  <subtitle>Eat, drink, fuck and live.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://archmee.github.io/"/>
  <updated>2016-03-05T16:55:23.054Z</updated>
  <id>http://archmee.github.io/</id>
  
  <author>
    <name>Archmee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>立场诗</title>
    <link href="http://archmee.github.io/201603/stand-poems.html"/>
    <id>http://archmee.github.io/201603/stand-poems.html</id>
    <published>2016-03-05T16:37:14.000Z</published>
    <updated>2016-03-05T16:55:23.054Z</updated>
    
    <content type="html">&lt;center&gt;—— &lt;em&gt;德兰修女&lt;/em&gt;&lt;/center&gt;


&lt;p&gt;人们不讲道理、没有逻辑、以自我为中心，不管怎样，总是爱他们；&lt;/p&gt;
&lt;p&gt;即使你是友善的，人们还是说你自私和别有用心，不管怎样，总是要友善；&lt;/p&gt;
&lt;p&gt;当你功成名就，身边尽是真的敌人和假的朋友，不管怎样，总是要成功；&lt;/p&gt;
&lt;p&gt;诚实和率直，使你受到欺骗和攻击，不管怎样，总是诚实、率直；&lt;/p&gt;
&lt;p&gt;你多年营造的一切，可能毁于一夜之间，不管怎样，总是要去营造；&lt;/p&gt;
&lt;p&gt;如果你得到平静和喜悦，可能会遭人妒嫉，不管怎样，总是要快乐；&lt;/p&gt;
&lt;p&gt;你今天做的善事，人们往往明天就会忘记，不管怎样，总是要做善事；&lt;/p&gt;
&lt;p&gt;把你所拥有最好的东西献给这个世界，也许微不足道，不管怎样，总是要把最好的东西献给世界。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;偶然读到的一首诗，读完让人觉得很通透。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;center&gt;—— &lt;em&gt;德兰修女&lt;/em&gt;&lt;/center&gt;


&lt;p&gt;人们不讲道理、没有逻辑、以自我为中心，不管怎样，总是爱他们；&lt;/p&gt;
&lt;p&gt;即使你是友善的，人们还是说你自私和别有用心，不管怎样，总是要友善；&lt;/p&gt;
&lt;p&gt;当你功成名就，身边尽是真的敌人和假的朋友，不
    
    </summary>
    
      <category term="life" scheme="http://archmee.github.io/categories/life/"/>
    
    
      <category term="摘抄" scheme="http://archmee.github.io/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS学习笔记之OC基础</title>
    <link href="http://archmee.github.io/201603/start-learn-oc-languae.html"/>
    <id>http://archmee.github.io/201603/start-learn-oc-languae.html</id>
    <published>2016-03-03T10:30:00.000Z</published>
    <updated>2016-03-20T19:29:48.874Z</updated>
    
    <content type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;从2.29号开始看 BigNerd 出版的《Objective-C编程》，花了两天时间将 C 语言部分温习了一遍，由于我是计算机专业的毕业生，所以 C 系的语言还算靠谱，但毕竟做了一年 Web 开发，重点都放在  PHP 和其他 Web 开发知识上，所以关于 C 的知识也已忘却不少。无论如何，我还是认真的把 C 的基础过了一遍(PS：有个讨论苹果开发入门的知乎贴有人说这本书只需要一天时间，实在佩服！)，并且跟着作者YY了一下 iOS 的开发工具 Xcode IDE，为什么YY呢，因为书上用的是 Mac 下的 Xcode，而我先前的C语言部分都是用的 Win 下的 Codeblocks，原因且看下面。&lt;/p&gt;
&lt;h2 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h2&gt;&lt;p&gt;因为我手头并不宽裕，只有一个 iPad mini 2，当时买来是为了看书看视频用的，而 MAC 呢，虽然我没有，但是我姐有，可是她白天上班要带到公司去，所以我们的计划就是我白天在家看书，晚上等电脑回来再敲代码。然而这几天晚上我都在熟悉 MAC 的使用以及……&lt;strong&gt;下载Xcode&lt;/strong&gt;，是的，连我自己也没想到。在鬼畜的 iTunes 上下载4.5G的 Xcode 7.2.1 尝试了2个晚上，就看到菊花一直转啊转啊，也不知道进度多少，？下载无果后，我姐利用上班时间在 Apple 官网下载了最新的 Xcode 7.3 Beta 版，这个版本我之前在官网看到过，因为是 Beta 版，所以才没有下载。那好吧，既然下载了，那就安装吧……,安装完运行才提示 Xcode 7.3 只支持 OS X 10.11 以上，而我的系统还是 OS X 10.10.1，试问隔壁的Windows有按照系统小版本更新来支持工具的吗？那我想估计下载 Xcode 6 就可以了吧，然而翻遍官网也没找到 Xcode 6 或者其他不是最新版的 Xcode 的链接，最后通过Google找到了 &lt;a href=&quot;http://stackoverflow.com/questions/10335747/how-to-download-xcode-4-5-6-7-and-get-the-dmg-file&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOverflow上同样的问题：&lt;code&gt;how-to-download-xcode-4-5-6-7-and-get-the-dmg-file ?&lt;/code&gt;&lt;/a&gt;，才知道要 &lt;a href=&quot;https://developer.apple.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;访问Apple官网的这个页面&lt;/a&gt;，登陆 Apple ID，然后就可以下载Xcode的历史版本了。oh，妈妈咪呀，终于找到了你了，真是“皇天不负有心人”“踏波铁屑无觅处，得来全不费工夫。”“蓦然回首，那人却在灯火阑珊处”啊！好歹看见了一丝曙光，耗费昨晚一晚上，终于下载下来了 2.6 G 的 Xcode 6.4，等今晚上安装吧，这下应该是没问题的。结果晚上我姐回家说已经为此更新了系统。&lt;br&gt;吐槽结束，回到正题吧。&lt;br&gt;前面说过，我们这里省略 C 语言的部分，所以直接从13章开始。&lt;/p&gt;
&lt;h2 id=&quot;OC-13章：对象&quot;&gt;&lt;a href=&quot;#OC-13章：对象&quot; class=&quot;headerlink&quot; title=&quot;OC-13章：对象&quot;&gt;&lt;/a&gt;OC-13章：对象&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对象和结构体类似，结构体中的&lt;strong&gt;成员&lt;/strong&gt;在对象中称为&lt;strong&gt;实例变量&lt;/strong&gt;（instance variable），对象和结构体的不同点在于：对象还可以包含一组函数。&lt;/li&gt;
&lt;li&gt;类负责描述特定类型的对象，一个类定义了一种对象。&lt;/li&gt;
&lt;li&gt;画对象图时，类一般用&lt;strong&gt;虚线&lt;/strong&gt;，实例（对象）一般用&lt;strong&gt;实线&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;OC 头文件后缀为&lt;code&gt;.h&lt;/code&gt;,其他代码后缀为&lt;code&gt;.m&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;OC 用&lt;code&gt;#import&lt;/code&gt;导入头文件，类似于 C 的&lt;code&gt;#include&lt;/code&gt;，但是&lt;code&gt;#import&lt;/code&gt;导入更有效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Foundation&lt;/strong&gt;框架是 iOS 项目的一个基础框架，由多种类、函数、常量以及数据类型组成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSLog()&lt;/code&gt;函数类似于C语言的&lt;code&gt;printf()&lt;/code&gt;函数，它与&lt;code&gt;printf()&lt;/code&gt;的区别在于会先输出日期、时间、程序名称和进程ID，再输出实际内容。格式打印符&lt;code&gt;%p&lt;/code&gt;会输出指针地址，&lt;code&gt;%@&lt;/code&gt;会输出对象的‘描述信息’。&lt;/li&gt;
&lt;li&gt;在 OC 中，若要执行方法里的代码，&lt;u&gt;首先需要发送一条&lt;strong&gt;消息&lt;/strong&gt;给包含这个方法的对象或类&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;消息发送：必须写在一对方括号中，并且必须包含接收方（receiver）和选择器（selector）。&lt;br&gt;&lt;img src=&quot;/images/22-56-05.jpg&quot; alt=&quot;Message&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类方法&lt;/strong&gt;（class method）会创建类的实例，并初始化实例变量，如date。&lt;br&gt;&lt;strong&gt;实例方法&lt;/strong&gt;（instance method）会提供实例中实例变量的信息，或是对实例的实例变量进行操作，如timeIntervalSince1970。&lt;/li&gt;
&lt;li&gt;OC 区分大小写，以下为 OC 的语言命名习惯：&lt;ul&gt;
&lt;li&gt;指向实例的变量使用&lt;strong&gt;驼峰命名法&lt;/strong&gt;（camel case），以小写字母开头，接下来每个单词首字母大写。&lt;/li&gt;
&lt;li&gt;方法的命名也使用驼峰命名法。&lt;/li&gt;
&lt;li&gt;类的名称以大写字母开头，接下来的单词继续使用驼峰命名法。&lt;/li&gt;
&lt;li&gt;很多苹果创建的类型和常量的命名也是前缀大写的驼峰命名法，如NSInteger，他并不是类，只是一种整型类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt; 2016.3.5 12:46 更新&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OC-14章：消息&quot;&gt;&lt;a href=&quot;#OC-14章：消息&quot; class=&quot;headerlink&quot; title=&quot;OC-14章：消息&quot;&gt;&lt;/a&gt;OC-14章：消息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;传递实参的消息，方法名后带有冒号&lt;code&gt;:&lt;/code&gt;意味需要发送带有实参的消息，而且每个冒号后面都要传递参数。在写代码时，多个实参应该对齐冒号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSDate&lt;/code&gt;是时间类，&lt;code&gt;NSCalendar&lt;/code&gt;是日历类。&lt;/li&gt;
&lt;li&gt;消息可以&lt;strong&gt;嵌套&lt;/strong&gt;发送，系统会最先从最里面的消息由内之外依次执行。&lt;/li&gt;
&lt;li&gt;唯一必须以嵌套的形式连续发送的消息是alloc和init。&lt;br&gt;每个类都有一个 alloc 方法，它能创建一个对象，并返回指向该对象的指针，通过 alloc 出来的对象，必须要经过初始化才能使用，它存放在内存里，但是无法接收消息，每个类也都有一个 init 方法，它用来初始化实例。eg.&lt;code&gt;[[Class alloc] init]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nil&lt;/strong&gt; 是不指向任何对象的指针，nil 值为0。在OC中向 nil 发送消息，没有任何影响。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重点1：&lt;/strong&gt;如果程序向某个对象发送了消息，但却没得到预期的结果，应先检查消息接收方是否为 nil。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重点2：&lt;/strong&gt;向 nil 发送消息，得到的返回值没有任何意义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;声明指针时如不知道指针所指对象的准确类型，可以使用&lt;code&gt;id&lt;/code&gt;类型。id 类型的含义是：可以指向任意类型的OC对象的指针，并且已经隐含了&lt;code&gt;*&lt;/code&gt;的作用。eg.&lt;code&gt;id example&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-15章：对象与内存&quot;&gt;&lt;a href=&quot;#OC-15章：对象与内存&quot; class=&quot;headerlink&quot; title=&quot;OC-15章：对象与内存&quot;&gt;&lt;/a&gt;OC-15章：对象与内存&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;函数的帧在函数结束后会自动释放，堆里的对象不会自动释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARC：&lt;/strong&gt;自动销毁不被引用的对象的机制，自动引用计数（automatic reference counting）的简称。当对象对指向自己的指针计数为0时，程序便自动销毁该对象。&lt;br&gt;如果不再需要某个对象，则可以将&lt;u&gt;指向它&lt;/u&gt;的指针设置为 nil。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-16章：NSString&quot;&gt;&lt;a href=&quot;#OC-16章：NSString&quot; class=&quot;headerlink&quot; title=&quot;OC-16章：NSString&quot;&gt;&lt;/a&gt;OC-16章：NSString&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@&amp;quot;...&amp;quot;&lt;/code&gt;是OC中的一个缩写，代表根据给定的字符串创建一个 NSString 对象。这种缩写称为&lt;strong&gt;字面量语法&lt;/strong&gt;（literal syntax）。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSString 实例可以保存任意 Unicode 字符，如需插入非 ASCII 字符，则可以使用&lt;code&gt;\u&lt;/code&gt;，后面加上该字符的 Unicode 编码。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *str = [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;I \u2661 You&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt; 2016.3.5 23:46 更新&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OC-17章：NSArray&quot;&gt;&lt;a href=&quot;#OC-17章：NSArray&quot; class=&quot;headerlink&quot; title=&quot;OC-17章：NSArray&quot;&gt;&lt;/a&gt;OC-17章：NSArray&lt;/h2&gt;&lt;h3 id=&quot;NSArray&quot;&gt;&lt;a href=&quot;#NSArray&quot; class=&quot;headerlink&quot; title=&quot;NSArray&quot;&gt;&lt;/a&gt;NSArray&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NSArray 也可以用&lt;strong&gt;字面量语法&lt;/strong&gt;来创建实例，数组的内容写在方括号，使用逗号分隔。eg:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *list = @[eleOne, eleTwo, eleTree];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;NSArray 创建的是&lt;strong&gt;静态数组&lt;/strong&gt;（static array），一旦 NSArray 实例被创建，就无法添加或删除数组里的指针，也无法改变数组的指针顺序。&lt;/li&gt;
&lt;li&gt;NSArray 中的指针是有序的，并可以通过相应索引来存取，索引从0开始。这一点和C语言类似。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;方法会返回 NSArray 对象中所含指针的个数。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;遍历数组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标准方式&lt;/p&gt;
  &lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(init; condtion; step)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//操作数组元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OC的快速枚举&lt;/p&gt;
  &lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(variable &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//操作数组元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;旧式数组方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;还没有字面量语法的时候（用&lt;code&gt;@&lt;/code&gt;创建数组），只能用 &lt;code&gt;arrayWithObjects:&lt;/code&gt; 类方法来创建 NSArray 实例。eg:&lt;/p&gt;
  &lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *list = [&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; arrayWithObjects:eleOne, eleTwo, eleThree, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后的&lt;code&gt;nil&lt;/code&gt;告诉方法停止运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还没有下标语法的时候，一般使用&lt;code&gt;ObjectAtIndex&lt;/code&gt;来访问数组中的指针。eg:&lt;/p&gt;
  &lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,[list objectAtIndex:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;NSMutableArray&quot;&gt;&lt;a href=&quot;#NSMutableArray&quot; class=&quot;headerlink&quot; title=&quot;NSMutableArray&quot;&gt;&lt;/a&gt;NSMutableArray&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NSMutableArray 是 NSArray 的子类。&lt;/li&gt;
&lt;li&gt;NSMutableArray 创建的是&lt;strong&gt;动态数组&lt;/strong&gt;（dynamic array），和 NSArray 实例不同的是，它可以添加、删除或对指针重新进行排序。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addObject:&lt;/code&gt;方法给 NSMutableArray 在尾部添加对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insertObject:atIndex:&lt;/code&gt;在指定位置添加对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;removeObjectAtIndex:&lt;/code&gt;删除数组中指定位置的对象，数组中的对象个数会随之减少。&lt;/li&gt;
&lt;li&gt;如果遍历数组时需要添加或删除指针，则需要使用标准的 for 循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt; 2016.3.6 23:10 更新&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OC-18章：自定义类&quot;&gt;&lt;a href=&quot;#OC-18章：自定义类&quot; class=&quot;headerlink&quot; title=&quot;OC-18章：自定义类&quot;&gt;&lt;/a&gt;OC-18章：自定义类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OC的头文件.h又称&lt;strong&gt;接口文件&lt;/strong&gt;（interface file），包含实例变量和方法的声明。OC的.m文件称为&lt;strong&gt;实现文件&lt;/strong&gt;（implementation file），包含所有方法的代码实现。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OC &lt;strong&gt;头文件&lt;/strong&gt; 以&lt;code&gt;@interface&lt;/code&gt;开始，以&lt;code&gt;@end&lt;/code&gt;结束。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在花括号&lt;code&gt;{}&lt;/code&gt;里声明实例变量，实例变量以下划线&lt;code&gt;_&lt;/code&gt;开始，后跟实例变量的名字。书上说明&lt;code&gt;_&lt;/code&gt;没有特别语法含义，仅仅是易于区分实例变量和局部变量。&lt;/li&gt;
&lt;li&gt;声明实例方法以减号&lt;code&gt;-&lt;/code&gt;开始（类方法以加号&lt;code&gt;+&lt;/code&gt;开始？），后面跟方法声明。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassName&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;ExtendsClassName&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//声明实例变量 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; _stockNumber;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//声明方法，或者属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// - (返回类型)函数名:参数;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;)valueStock:(&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;)rate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;OC &lt;strong&gt;实现文件&lt;/strong&gt; 以&lt;code&gt;@implementation&lt;/code&gt;开始，以&lt;code&gt;@end&lt;/code&gt;结束。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&quot;ClassName.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassName&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//实现方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;)valueStock:(&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;)rate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//code  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;存取方法（accessor method）：&lt;strong&gt;取方法&lt;/strong&gt;（getter method）用去掉下划线前缀的实例变量命名。&lt;strong&gt;存方法&lt;/strong&gt;（setter method）用set后跟去掉下划线前缀的实例变量命名，并且要遵循驼峰命名。eg：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) setHeightInMeters:(&lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt;)h;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;包含头文件的区别：&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;包含系统头文件，&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;包含当前项目头文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;是一个指针，指向当前对象。可以作为实参传递给其他方法。&lt;/li&gt;
&lt;li&gt;OC没有命名空间（namespace），所以为了避免同一个项目中名字冲突，推荐使用三个或者三个以上的字母最为类前缀。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-19章：属性&quot;&gt;&lt;a href=&quot;#OC-19章：属性&quot; class=&quot;headerlink&quot; title=&quot;OC-19章：属性&quot;&gt;&lt;/a&gt;OC-19章：属性&lt;/h2&gt;&lt;p&gt;OC有一条便捷途径，可以简化存取方法的过程，该途径称为&lt;strong&gt;属性&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;声明属性：可以取而代之18章在花括号中声明实例变量，且声明属性不用写在花括号里，而是和声明方法在同一个级别。&lt;br&gt;声明属性以&lt;code&gt;@property&lt;/code&gt;开始，后跟属性的特性、类型和名称。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; heightInMeters;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;声明属性的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让头文件更简洁。&lt;/li&gt;
&lt;li&gt;减少代码输入。&lt;/li&gt;
&lt;li&gt;最重要的是，编译器会帮你声明和实现存取方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;属性的特性：属性的声明可以有一个或多个属性特性（property attributes），属性特性告诉编译器关于属性行为的更多信息，多个属性特性用逗号&lt;code&gt;,&lt;/code&gt;分隔。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性的特性分为&lt;strong&gt;原子性&lt;/strong&gt;（atomic）和&lt;strong&gt;非原子性&lt;/strong&gt;（nonatomic），默认为原子性。&lt;/li&gt;
&lt;li&gt;属性的另一种特性：&lt;ul&gt;
&lt;li&gt;readonly（只读）：只有取方法，没有存方法。&lt;/li&gt;
&lt;li&gt;readwrite（读写）：默认值，既有存方法，也有取方法。&lt;/li&gt;
&lt;li&gt;copy（可拷贝）：每当声明一个指向NSString或NSArray的对象的属性时，都需要设置copy属性。&lt;/li&gt;
&lt;li&gt;还有更多……&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点号调用存取方法：dot notation 是苹果公司提供的一种快捷调用存取方法的语法。它和获取结构体成员方法一样，但是不同之处在于，使用 dot notation 实际是在发送消息。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//下面的代码对于属性的存取是等价的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;object&lt;span class=&quot;variable&quot;&gt;.var&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[object setVar:&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//setVar是编译生成的存方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;测试发现，也可以用点号调用其他非存取方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;OC-20章：继承&quot;&gt;&lt;a href=&quot;#OC-20章：继承&quot; class=&quot;headerlink&quot; title=&quot;OC-20章：继承&quot;&gt;&lt;/a&gt;OC-20章：继承&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本书所有对象（无论间接的还是直接的）都继承自NSObject。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassName&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当有属性指向某个对象的时候，需要对内存进行管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;子类的实例可以毫无疑问的代替父类的实例，因为它继承了父类的所有东西。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;覆盖方法&lt;/strong&gt;：覆盖方法只能改变方法的实现，而无法改变它的声明方式，方法名称、返回类型以及实参类型都必须保持相同。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子类可以利用父类的实现，而不是完全替换，不过需要用到 &lt;strong&gt;super&lt;/strong&gt; 指令。super 的含义是：运行指定的方法，但是从对象的父类开始查找与之匹配的实现。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//在实现方法代码中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; parentClassMethod]; &lt;span class=&quot;comment&quot;&gt;//运行父类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;NSObject 虽然拥有很多方法，但是只有一个实例变量： &lt;strong&gt;isa&lt;/strong&gt; 指针。任何一个对象的 isa 指针都指向创建该对象的类.&lt;/li&gt;
&lt;li&gt;给对象发送消息的时候，对象就会查询是否有该消息名的方法。搜索会通过 isa 指针找到该对象的类并查询，如果没有匹配该消息名的方法，如果没有，就会继续查询它的父类。依次类推，对象会沿着继承链向上查询，直到找到匹配消息名的方法，或者到达继承链的顶端（NSObject）为止，如果还是没找到，就报错。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;%@&lt;/code&gt; 和 &lt;strong&gt;description&lt;/strong&gt; 方法的转换：处理&lt;code&gt;%@&lt;/code&gt;时，程序会先向相应的指针变量所指的对象发送 description 消息，description 方法会返回一个描述类实例的字符串。description 是一个NSObject方法，所以所有对象都有这个方法，类可以覆盖 description 方法来定义类实例的描述。eg:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)description &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;...&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt; 2016.3.9 22:50 更新&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OC-21章：对象实例变量及属性&quot;&gt;&lt;a href=&quot;#OC-21章：对象实例变量及属性&quot; class=&quot;headerlink&quot; title=&quot;OC-21章：对象实例变量及属性&quot;&gt;&lt;/a&gt;OC-21章：对象实例变量及属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对象实例变量的三种常见用途：&lt;ul&gt;
&lt;li&gt;对象属性：指向某个单一的、代表某个值的对象，如NSString对象。&lt;/li&gt;
&lt;li&gt;一对一关系：指向单个复杂对象的指针。&lt;/li&gt;
&lt;li&gt;一对多关系：指向某个collection类的实例的指针。如NSMutableArray实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任何一个对象不会在其内部保存其他对象，而只会在内部保存相应对象的地址。与“包含其他对象”相比，这样会产生两大副作用。&lt;ul&gt;
&lt;li&gt;单个对象可能会扮演多个角色。&lt;/li&gt;
&lt;li&gt;导致产生大量独立的对象，耗尽程序的可用内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为了解决上个问题的副作用，OC提出了&lt;strong&gt;对象所有权&lt;/strong&gt;（object owership）概念，当A对象拥有某个对象实例变量B时，称A拥有了B指向的对象。当某个对象的拥有方个数为0时，可以判定程序不再需要该对象，从而释放该对象。&lt;/li&gt;
&lt;li&gt;有一个NSObject方法：&lt;strong&gt;dealloc&lt;/strong&gt;，如果类覆盖了该方法，那么当类的实例被释放时，就会执行dealloc方法。&lt;/li&gt;
&lt;li&gt;一对多关系是由collection对象（如数组）和其包含的对象组成的。&lt;ul&gt;
&lt;li&gt;当在collection对象中加入某个对象的时，会在collection对象中保存指向该对象的指针，并成为该对象的拥有方。&lt;/li&gt;
&lt;li&gt;当从collection中移除某个对象时，会删除指向该对象的指针，并不再是该对象的拥有方。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;@class ClassName&lt;/code&gt;引用某个头文件时，和&lt;code&gt;#import&lt;/code&gt;不同的是，编译器不会查看文件的全部内容，因此处理速度更快，这样是因为编译器不需要知道实现细节就能处理文件中的所有声明了。&lt;/li&gt;
&lt;li&gt;创建collection对象的时机有两个：&lt;ul&gt;
&lt;li&gt;创建本地对象时。&lt;/li&gt;
&lt;li&gt;需要使用相应collection对象时（延迟创建机制）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果程序有用不到的但有没有释放的对象，就称程序有内存泄露（memory leak）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-22章：类扩展&quot;&gt;&lt;a href=&quot;#OC-22章：类扩展&quot; class=&quot;headerlink&quot; title=&quot;OC-22章：类扩展&quot;&gt;&lt;/a&gt;OC-22章：类扩展&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;涉及实现细节的属性或方法最好在&lt;strong&gt;类扩展&lt;/strong&gt;（class extension）中声明，类扩展是一组私有的声明，只有类和该类的实例才能使用在类扩展中声明的属性、实例变量或方法。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通常，类扩展是添加在类实现文件中的，并且是位于&lt;code&gt;@implementation&lt;/code&gt;之上的，并且和头文件中一样要用&lt;code&gt;@interface ... @end&lt;/code&gt;包起来，但是类名字后面是跟一对括号&lt;code&gt;()&lt;/code&gt;，声明方法都一样。eg：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassName&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//...类扩展声明内容放在这里...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassName&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//...原来实现方法的代码...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可用类扩展&lt;strong&gt;隐藏可变属性&lt;/strong&gt;。比如 NSMutableArray。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;子类无法获取父类的类扩展。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;在类的头文件中声明属性的时候，其他对象只能看到属性的存取方法，对象（包括子类）无法直接获取属性声明生成的实例变量。&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt; 2016.3.10 22:05 更新&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OC-23章：避免内存泄露&quot;&gt;&lt;a href=&quot;#OC-23章：避免内存泄露&quot; class=&quot;headerlink&quot; title=&quot;OC-23章：避免内存泄露&quot;&gt;&lt;/a&gt;OC-23章：避免内存泄露&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;“互相拥有”的所有权关系导致相关的对象都无法被释放。这种情况称为&lt;strong&gt;强引用循环&lt;/strong&gt;（strong reference cycle），强引用循环是导致内存泄露的常见原因。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过 &lt;strong&gt;弱引用&lt;/strong&gt; （weak reference）可以解决强引用循环问题。在声明属性的时候在特性中采用&lt;strong&gt;weak&lt;/strong&gt;关键字，eg：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;) Object *pointer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果需要明确的将指针变量声明为弱引用，则可以标注&lt;strong&gt;__weak&lt;/strong&gt;，eg：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; Object *pointer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;为了避免强引用循环，通常需要遵守此规则：父对象拥有子对象，但是子对象不拥有父对象。&lt;/li&gt;
&lt;li&gt;弱引用有自动置0特性，当某个由弱引用指向的对象被释放时，相应的指针变量会被&lt;strong&gt;归零&lt;/strong&gt;（zeroed），即赋为nil。&lt;/li&gt;
&lt;li&gt;总结：强引用会保留对象的拥有方，使其不被释放。而弱引用则不会保留，因此标为弱引用的实例变量与属性指向的对象可能会消失。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在没有ARC之前，都是采用手动引用计数：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Code block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject retain]; &lt;span class=&quot;comment&quot;&gt;//获取anObject的拥有权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject release]; &lt;span class=&quot;comment&quot;&gt;//释放anObject的拥有权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[anObject autorelease]; &lt;span class=&quot;comment&quot;&gt;//自动释放anObject的拥有权，自动一般在autorelease池（对象）被排干（drain）的时候；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Another code block  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//手动创建autorelease池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSAutoreleasePool&lt;/span&gt; *arp = [[&lt;span class=&quot;built_in&quot;&gt;NSAutoreleasePool&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//coding here&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[arp drain] &lt;span class=&quot;comment&quot;&gt;//排干autorelease池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//--------------&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Objective-c加入ARC，也加入了用于创建autorelease池的新语法。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;//创建autorelease池（对象）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// coding here&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;//autorelease池已经被排空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;理解内存管理的技巧“从局部的角度，以分类为分界”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-24章：Collection-类&quot;&gt;&lt;a href=&quot;#OC-24章：Collection-类&quot; class=&quot;headerlink&quot; title=&quot;OC-24章：Collection 类&quot;&gt;&lt;/a&gt;OC-24章：Collection 类&lt;/h2&gt;&lt;h3 id=&quot;NSSet-NSMutable（集合）&quot;&gt;&lt;a href=&quot;#NSSet-NSMutable（集合）&quot; class=&quot;headerlink&quot; title=&quot;NSSet/NSMutable（集合）&quot;&gt;&lt;/a&gt;NSSet/NSMutable（集合）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NSSet对象所包含的内容是无序的，而且在NSset对象那个中，某个对象只能出现一次。&lt;/li&gt;
&lt;li&gt;NSset对象的最大用处就是检查某个对象是否存在。&lt;/li&gt;
&lt;li&gt;NSset对象也分为可对指针进行修改和不可对指针进行修改两类：NSSet对象是不能对指针进行修改的，对象创建好后就不能对其中的指针进行添加或删除等操作，而NSMutableSet是它的子类，它是动态可变的。&lt;/li&gt;
&lt;li&gt;NSset对象中的对象是无序的，所以不能通过索引来访问。&lt;/li&gt;
&lt;li&gt;如果程序要检查某两个对象是否相等，可以用NSObject类中的&lt;strong&gt;isEqual:&lt;/strong&gt;方法。&lt;/li&gt;
&lt;li&gt;相同的变量一定是相等的，而相等的变量不一定相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;NSDictionary-NSMutableDictionary-字典&quot;&gt;&lt;a href=&quot;#NSDictionary-NSMutableDictionary-字典&quot; class=&quot;headerlink&quot; title=&quot;NSDictionary/NSMutableDictionary(字典)&quot;&gt;&lt;/a&gt;NSDictionary/NSMutableDictionary(字典)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NSDictionary是一组&lt;strong&gt;键-值对&lt;/strong&gt;（key-value pair）集合，键通常是字符串，值可以是任意类型的对象。字典对象中的键都是独一无二的，字典对象所保存的键-值对是无序的。字典的字面量语法由&lt;code&gt;@&lt;/code&gt;和&lt;code&gt;{}&lt;/code&gt;组成，键值对之间用逗号&lt;code&gt;,&lt;/code&gt;分割。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *dic = @&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;@&quot;key-1&quot;&lt;/span&gt; : @&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//值是数字对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;@&quot;key-2&quot;&lt;/span&gt; : @[&lt;span class=&quot;string&quot;&gt;@&quot;Lua&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;@&quot;xiba&quot;&lt;/span&gt;], &lt;span class=&quot;comment&quot;&gt;//值是数组对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;@&quot;key-3&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;abc&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//值是字符串对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//从字典取值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dic[&lt;span class=&quot;string&quot;&gt;@&quot;key-2&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//还没引入下标的用法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[dic setObject:&lt;span class=&quot;string&quot;&gt;&quot;key-x&quot;&lt;/span&gt; fouKey:&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//添加字典对象那个&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[dic objectForKey:&lt;span class=&quot;string&quot;&gt;@&quot;key-x&quot;&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//从字典取值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;不可修改对象&quot;&gt;&lt;a href=&quot;#不可修改对象&quot; class=&quot;headerlink&quot; title=&quot;不可修改对象&quot;&gt;&lt;/a&gt;不可修改对象&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问：前面讲的 collection 都有不可更改和可更改的，那么为什么要提供不能修改的 collection 呢？&lt;br&gt;答：使用不能修改的 collection 可以节约内存提高性能，因为它永远无法拷贝。而对于可修改对象，则可能发生这样一种情况：程序中的其它代码可能在你使用这个对象时修改这个对象的内容。为了避免这种情况，就需要复制一份私有拷贝。而每个程序的代码都有可能做一份私有拷贝，这样就有可能会有多份一样的对象拷贝。&lt;/p&gt;
&lt;p&gt;比如 NSArray 的 copy 方法实际上不会做任何额外的操作，仅仅返回指向自身的指针而已。而 NSMutableArray 的 copy 方法则会制作一份自己的拷贝，并返回指向新数组的对象的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;很多类都有不可修改对象，这些类都有可修改的子类（一般在中间加入Mutable），&lt;u&gt;但是 &lt;strong&gt;NSDate&lt;/strong&gt; 和 &lt;strong&gt;NSDate&lt;/strong&gt; 只有不可修改的版本&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a&gt;数组排序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不可修改的数组不能排序。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;排序描述对象&lt;/strong&gt;（sort descriptor）包含两个信息：一个是数组中的对象的属性名，而是根据该属性是要升序（ascending）还是降序（descending）。eg:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSSortDescriptor&lt;/span&gt; *desc = [&lt;span class=&quot;built_in&quot;&gt;NSSortDescriptor&lt;/span&gt; sordDescriptorWithKey: &lt;span class=&quot;string&quot;&gt;@&quot;key&quot;&lt;/span&gt; ascending:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//key可以是方法名，也可以是实例变量或属性的名字。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[mutableList sortUsingDescriptors: @[desc]];&lt;span class=&quot;comment&quot;&gt;//将mutableList数组按照descriptor排序后，结果依然放在mutableList中。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;过滤&quot;&gt;&lt;a href=&quot;#过滤&quot; class=&quot;headerlink&quot; title=&quot;过滤&quot;&gt;&lt;/a&gt;过滤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对collection进行过滤的时候，程序将对collection对象和一条逻辑语句进行比较，得到一个合成的collection，这个collection包含满足这条语句的对象：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSPredicate&lt;/span&gt; *predicate = [&lt;span class=&quot;built_in&quot;&gt;NSPredicate&lt;/span&gt; predicateWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;value &amp;gt; 70&quot;&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//设置过滤条件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *result = [list filteredArrayUsingPredicate:predicate]; &lt;span class=&quot;comment&quot;&gt;//过滤&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Predicate对象的条件语句可以支持非常复杂的格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;collection-注意事项&quot;&gt;&lt;a href=&quot;#collection-注意事项&quot; class=&quot;headerlink&quot; title=&quot;collection 注意事项&quot;&gt;&lt;/a&gt;collection 注意事项&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;向collection对象加入某个对象时，collection对象会成为该对象的拥有方，如果从collection对象中移除该对象，collection对象就不再是该对象的拥有方了。&lt;/li&gt;
&lt;li&gt;本章节提到的collection只能保存对象，如果要保存C语言的基本类型，可以创建相应的对象进行封装。NSValue 实例可以用来保存任意的数量值。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本章节提到的collection对象都不能保存 nil ，如果要将“空”加入collection对象，则可以使用NSNull类，它只有一个实例，代表“空”。eg:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[collection addObject:[&lt;span class=&quot;built_in&quot;&gt;NSNull&lt;/span&gt; null]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-25章：常量&quot;&gt;&lt;a href=&quot;#OC-25章：常量&quot; class=&quot;headerlink&quot; title=&quot;OC-25章：常量&quot;&gt;&lt;/a&gt;OC-25章：常量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将代码中不变的值称为&lt;strong&gt;常量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;OC中可以通过 &lt;strong&gt;#define&lt;/strong&gt; 和 &lt;strong&gt;全局变量&lt;/strong&gt; 来定义常量。&lt;/li&gt;
&lt;li&gt;在OC中π的常量是&lt;code&gt;M_PI&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;通过 #define，不仅可以替换代码中某个特定值，还可以构建类似函数的代码段，称为&lt;strong&gt;宏&lt;/strong&gt;（macro）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSLocale&lt;/strong&gt; 实例可以保存针对不同地理位置的相关信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extern&lt;/strong&gt; 关键字导入其他文件中的定义。&lt;/li&gt;
&lt;li&gt;苹果引入了一种新的enum声明语法：&lt;strong&gt;NS_ENUM()&lt;/strong&gt;，它有两个参数，分别是数据类型和名字。&lt;/li&gt;
&lt;li&gt;在 #define 和 全局变量 中&lt;u&gt;更倾向于&lt;/u&gt;使用全局变量来定义常量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-26章：NSString和NSData写入文件&quot;&gt;&lt;a href=&quot;#OC-26章：NSString和NSData写入文件&quot; class=&quot;headerlink&quot; title=&quot;OC-26章：NSString和NSData写入文件&quot;&gt;&lt;/a&gt;OC-26章：NSString和NSData写入文件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将NSString对象写入文件&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSMutableString&lt;/span&gt; *str = &lt;span class=&quot;string&quot;&gt;@&quot;Hello world!\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error=&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//用于处理错误的参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; success = [str writeToFile:&lt;span class=&quot;string&quot;&gt;@&quot;/tmp/test.txt atomiclly:YES encoding:NSUTF8StringEncoding error:&amp;amp;error&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!success) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//写入文件失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, [error localizedDescription]); &lt;span class=&quot;comment&quot;&gt;//输出时要格式化错误信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//否则写入成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Success!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将文件读入NSString对象&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error=&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *str = [[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; alloc] initWithContentsOfFile:&lt;span class=&quot;string&quot;&gt;@&quot;/tmp/test.txt&quot;&lt;/span&gt; encoding:&lt;span class=&quot;built_in&quot;&gt;NSASCIIStringEncoding&lt;/span&gt; error:&amp;amp;error];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!str) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;//读取失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;//读取成功 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将NSData对象写入文件&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error=&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *url = [&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;http://google.com/images/logo/ps_logo.png&quot;&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//给一个有效图片地址就行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSURLRequest&lt;/span&gt; *request = [&lt;span class=&quot;built_in&quot;&gt;NSURLRequest&lt;/span&gt; requestWithURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *data = [&lt;span class=&quot;built_in&quot;&gt;NSURLCollection&lt;/span&gt; sentSynchronousRequest:request returningResponse:&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; error:&amp;amp;error];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//读取失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//读取成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读取文件存入NSData对象&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *readData = [&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; dataWithContentOffile:&lt;span class=&quot;string&quot;&gt;@&quot;/tmp/test.txt&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;寻找特别目录：苹果公司创建了一个函数告诉你正确的目录&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *deskTop = &lt;span class=&quot;built_in&quot;&gt;NSSearchPathForDirectoriesInDomains&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSDesktopDirectory&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSUserDomainMask&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//NSDesktopDirectory是桌面目录，还有其他目录常量可以查看文档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt; 2016.3.17 16:15 更新&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OC-27章：回调&quot;&gt;&lt;a href=&quot;#OC-27章：回调&quot; class=&quot;headerlink&quot; title=&quot;OC-27章：回调&quot;&gt;&lt;/a&gt;OC-27章：回调&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;回调&lt;/strong&gt; （callback）就是将一段可执行的代码和一个特定的事件绑定起来，当特定的事件发生时，就会执行这段代码。在OC中，有四种可实现回调的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目标-动作对&lt;/strong&gt;：在程序开始等待前，要求“当事件发生时，向指定的对象发送某个特定的消息”。这里接收消息的对象是目标（target），消息的选择器（selector）是动作（action）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;辅助对象&lt;/strong&gt;：在程序开始等待前，要求“当事件发生时，向遵守相应协议的辅助对象发送消息”，&lt;strong&gt;委托对象&lt;/strong&gt;（delegate）和&lt;strong&gt;数据源&lt;/strong&gt;（data source）是常见的辅助对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通知&lt;/strong&gt;（notification）：苹果提供了一种称为通知中心的对象。在程序开始等待前，告知通知中心“某个对象正在等待某些特定的通知，当其中某个通知出现时，向指定的对象发送特定的消息”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block对象&lt;/strong&gt;：Block 是一段可执行的代码。当程序开始等待前，声明一个Block对象，当事件发生时，执行这段Block对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件驱动的程序需要有一个对象，专门等待事件的发生。NSRunLoop实例会在特定的事件发生时触发回调。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@selector&lt;/code&gt;语句用来传递动作消息的名称给相应方法。&lt;/li&gt;
&lt;li&gt;可以在声明一个变量前使用&lt;code&gt;__unused&lt;/code&gt;修饰符标记，消除编译器“变量未使用”警告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NSURLConnection&lt;/code&gt;在异步模式时，不会一次性发送全部数据，他会发送块状的数据，并多次发送。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协议&lt;/strong&gt;（protocol）是一系列方法声明，辅助对象可以根据协议实现相应方法&lt;/li&gt;
&lt;li&gt;如何选择除了 Block 外的三种回调方法：&lt;ul&gt;
&lt;li&gt;对于只做一件事情的对象，使用目标-动作对。&lt;/li&gt;
&lt;li&gt;对于功能更复杂的对象，使用辅助对象。&lt;/li&gt;
&lt;li&gt;对于要触发多个回调的对象，使用通知。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建的对象拥有一个指向回调对象的指针，而这个回调对象的指针指向你创建的对象。就陷入了一个强引用循环，这两个对象都无法释放。所以编写回调代码时，应该遵循以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通知中心不拥有观察者&lt;/strong&gt;。如果将某个对象注册为观察者，那么通常应该在释放该对象将其移出通知中心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象不拥有委托对象或数据源对象&lt;/strong&gt;。如果某个新创建的对象是另一个对象的委托对象或数据源对象，那么该对象应该在其&lt;code&gt;dealloc&lt;/code&gt;方法中取消相应的关联。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象不拥有目标&lt;/strong&gt;。如果新创建的对象是另一个对象的目标，那么该对象应该在其&lt;code&gt;dealloc&lt;/code&gt;方法中取消相应的关联。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果使用方法的实际名称进行查询，那么查询速度会很慢，为了提速，编译器会为了每个其解除过的方法附上一个唯一的数字。这个数字称为选择器，通过编译指令&lt;code&gt;@selector&lt;/code&gt;可以得到与方法名相对应的选择器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-28章：Block对象&quot;&gt;&lt;a href=&quot;#OC-28章：Block对象&quot; class=&quot;headerlink&quot; title=&quot;OC-28章：Block对象&quot;&gt;&lt;/a&gt;OC-28章：Block对象&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;开始表示这段代码是一个 Block 对象。Block 对象也可以有实参和返回值。&lt;/li&gt;
&lt;li&gt;Block 对象可以被当成一个实参来传递给可以接收 block 的方法。&lt;/li&gt;
&lt;li&gt;声明一个 Block 时，要参考要使用该 Block 对象的方法期望的 Block 类型。&lt;/li&gt;
&lt;li&gt;对于有返回值的 Block 对象，可以像调用函数那样调用 Block 对象，然后使用其返回值。&lt;/li&gt;
&lt;li&gt;匿名 Block 对象是可以传递给方法的 Block 对象的，而不需要先赋值给变量。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当在 Block 中使用在 Block 对象外声明的变量（外部变量）时，相应的 Block 对象会捕获这些变量。&lt;/p&gt;
&lt;p&gt;对基本类型的变量，捕获意味着程序会拷贝变量的值，并用 Block 对象中的局部变量保存。对指针类型的变量， Block 对象会使用强引用，这意味着凡是 Block 对象使用到的对象，都会被保留，所以在相应的 Block 对象被释放前，这些对象一定不会被释放（这也是block对象和函数的区别，函数无法做到）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 Block 对象中捕获的外部变量是常数，程序无法修改变量所保存的值。如果需要在 Block 对象中修改某个外部变量，则可以在声明外部变量前，加上&lt;code&gt;__block&lt;/code&gt;关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;^&amp;#123; count++; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 Block 对象中使用&lt;code&gt;self&lt;/code&gt;时，又会陷入强引用循环，为了打破它，可以在 Block 对象外声明一个&lt;code&gt;__weak&lt;/code&gt;指针，然后指向 Block 对象中要使用的 &lt;code&gt;self&lt;/code&gt;，然后在 Block对象中使用新的指针。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; Object *weakself = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//弱引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Object: %@&quot;&lt;/span&gt;, weakself);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而是由于是弱引用，&lt;code&gt;self&lt;/code&gt;指向的对象有可能在运行时被释放。可以在 Block 对象中创建一个对&lt;code&gt;self&lt;/code&gt;的局部强引用。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; Object *weakself = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//弱引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Object *innerSelf = weakself; &lt;span class=&quot;comment&quot;&gt;//局部强引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Object: %@&quot;&lt;/span&gt;, innerSelf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果直接在 Block 对象中使用实例变量，那么 Block 对象会捕获 &lt;code&gt;self&lt;/code&gt;，而不会捕获实例变量。这样又会陷入强引用循环，所以不要直接存取实例变量，尽量使用存取方法。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; Object *weakself = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//弱引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Object *innerSelf = weakself; &lt;span class=&quot;comment&quot;&gt;//局部强引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;Object: %@&quot;&lt;/span&gt;, innerSelf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;value is %@&quot;&lt;/span&gt;, _value); &lt;span class=&quot;comment&quot;&gt;//不推荐：Block 对象会捕获self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;value is %@&quot;&lt;/span&gt;, innerSelf&lt;span class=&quot;variable&quot;&gt;.value&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 推荐使用存取方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-29章：协议&quot;&gt;&lt;a href=&quot;#OC-29章：协议&quot; class=&quot;headerlink&quot; title=&quot;OC-29章：协议&quot;&gt;&lt;/a&gt;OC-29章：协议&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;协议可以为一个对象指定角色。&lt;/li&gt;
&lt;li&gt;协议是一组方法声明，一些是必须的，一些是可选的。如果要某个对象扮演特定的角色，就一定要实现必须的方法，选择实现可选方法。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在创建要遵守某个协议的新类时，要在头文件中进行说明，eg：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TerrificView&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt; &amp;lt;&lt;span class=&quot;title&quot;&gt;ProtocolName&lt;/span&gt;，&lt;span class=&quot;title&quot;&gt;ProtocolName&lt;/span&gt;&amp;gt; //该类继承自&lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt;类，并且遵守尖括号中列举的协议，多个协议用逗号隔开&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果给一个对象发送消息，而这个对象没有相应的方法，程序会崩溃。如果在遵守某协议的类中没有实现某个可选方法，也是如此。为了避免这种情况，可以使用&lt;code&gt;respondsToSelector:&lt;/code&gt;询问对象是否实现了某个方法，该方法在&lt;code&gt;NSObject&lt;/code&gt;中实现了，返回值是&lt;code&gt;BOOL&lt;/code&gt;型。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([_data respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(totalValue)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [_data totalValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OC-30章：Proper-List-格式&quot;&gt;&lt;a href=&quot;#OC-30章：Proper-List-格式&quot; class=&quot;headerlink&quot; title=&quot;OC-30章：Proper List 格式&quot;&gt;&lt;/a&gt;OC-30章：Proper List 格式&lt;/h2&gt;&lt;p&gt;一个NSArray里面放上N个NSDictionary就组成了P-List格式，再输出到后缀&lt;code&gt;.plist&lt;/code&gt;的文件中即可，好像没什么重点……&lt;/p&gt;
&lt;p&gt;——— 结束de分割线 ———&lt;/p&gt;
&lt;p&gt;到今天为止，Objective-C基础部分就学习结束了，这篇笔记也更新结束了，因为中途情绪比较低落，看书容易走神，所以速度还是有点慢。希望后面能好起来。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;从2.29号开始看 BigNerd 出版的《Objective-C编程》，花了两天时间将 C 语言部分温习了一遍，由于我是计算机专业的毕业生，所以 
    
    </summary>
    
      <category term="technology" scheme="http://archmee.github.io/categories/technology/"/>
    
    
      <category term="Objective-C" scheme="http://archmee.github.io/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://archmee.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>故乡</title>
    <link href="http://archmee.github.io/201602/a-lais-home.html"/>
    <id>http://archmee.github.io/201602/a-lais-home.html</id>
    <published>2016-02-27T17:00:38.000Z</published>
    <updated>2016-03-05T16:48:12.179Z</updated>
    
    <content type="html">&lt;center&gt;&lt;br&gt;—— &lt;em&gt;阿来&lt;/em&gt;&lt;br&gt;&lt;br&gt;我现在坐在群山之巅&lt;br&gt;我把头埋在双膝之间&lt;br&gt;感到风，像时光的水流&lt;br&gt;漫过我的脊梁&lt;br&gt;河流轰鸣，道路回转&lt;br&gt;现在我要独自一人&lt;br&gt;任群山的波涛把我充满&lt;br&gt;任大地重新向我涌来&lt;br&gt;&lt;br&gt;今天我又穿过了十二个村庄&lt;br&gt;接下来我还要穿过一百多个村庄&lt;br&gt;而所有这些栽培着这些&lt;br&gt;玉米  小麦  苹果  梨的村庄&lt;br&gt;放牧着牛羊的村庄——&lt;br&gt;都跟我出生的村子一模一样&lt;br&gt;&lt;br&gt;有一座水磨坊，有一所小学堂&lt;br&gt;晴天的早上&lt;br&gt;小学堂的钟声叮当作响&lt;br&gt;所有这一切&lt;br&gt;都跟我出生的那个村子一模一样&lt;br&gt;所以你们这些所有的村子&lt;br&gt;你们都是我的故乡&lt;br&gt;&lt;br&gt;&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;2016.2.24 摘自 &lt;a href=&quot;http://tv.cntv.cn/video/VSET100173543987/d250c6328bdd4cab9feeed410382c2aa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《开讲啦》第20160205期&lt;/a&gt; 14分20秒处，作者阿来写于香烟盒子上的一首诗，无名，我暂取名为故乡。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;br&gt;—— &lt;em&gt;阿来&lt;/em&gt;&lt;br&gt;&lt;br&gt;我现在坐在群山之巅&lt;br&gt;我把头埋在双膝之间&lt;br&gt;感到风，像时光的水流&lt;br&gt;漫过我的脊梁&lt;br&gt;河流轰鸣，道路回转&lt;br&gt;现在我要独自一人&lt;br&gt;任群山的波涛把我充满&lt;br&gt;任大地重新向我涌来&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="http://archmee.github.io/categories/life/"/>
    
    
      <category term="摘抄" scheme="http://archmee.github.io/tags/%E6%91%98%E6%8A%84/"/>
    
      <category term="诗" scheme="http://archmee.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>Github + Hexo 三步曲</title>
    <link href="http://archmee.github.io/201602/github-and-hexo-three-steps.html"/>
    <id>http://archmee.github.io/201602/github-and-hexo-three-steps.html</id>
    <published>2016-02-26T21:24:25.000Z</published>
    <updated>2016-03-10T16:52:40.885Z</updated>
    
    <content type="html">&lt;h3 id=&quot;序曲&quot;&gt;&lt;a href=&quot;#序曲&quot; class=&quot;headerlink&quot; title=&quot;序曲&quot;&gt;&lt;/a&gt;序曲&lt;/h3&gt;&lt;p&gt;之前有过一次搭建博客的经历，当时购买了自己的第一个 .COM 域名，并用 Wordpress 挂在了同学的服务器上，一年下来只写了有寥寥几篇博客，虽然都还算认真写的，但写作动力不足，最后域名过期便无疾而终了，想来还因为 Wordpress 太慢，且臃肿难用，二来每次在网页上写文章很不方便，一旦网页挂掉就 Game Over 了，Evernote 和有道笔记用过之后也不是很满意，一个太慢，一个除了慢而且长得丑（每次都要登陆登陆，登陆你个大头鬼啊，你知不知道我每次都是写的本地笔记本啊，而且最近每用一次必崩溃一次），两者功能都太多，我现在只偶尔用 Evernote 的剪藏功能来收藏网页。&lt;/p&gt;
&lt;p&gt;其余，我想有一个能记录想法或笔记的工具，随时能用，并且有一个展示的地方，仅此而已。本来也可以写在Lofter、新浪博客、点点等博客平台上，但是总感觉不够『独立』，尤其在用了 Markdown 之后，更被 Markdown 的简洁优雅所吸引。最最重要的是我最近要开始学习 iOS 开发，到时会记录一些学习笔记和总结在这里，因为我发现很多大牛都有在博客上记录总结的习惯。与此同时还可以好好用下 Git 和 Github，综上，才有了我的新博客。&lt;/p&gt;
&lt;p&gt;So，Let’s start！&lt;/p&gt;
&lt;h3 id=&quot;第一步：准备工作&quot;&gt;&lt;a href=&quot;#第一步：准备工作&quot; class=&quot;headerlink&quot; title=&quot;第一步：准备工作&quot;&gt;&lt;/a&gt;第一步：准备工作&lt;/h3&gt;&lt;p&gt;首先，你要：&lt;/p&gt;
&lt;h4 id=&quot;1-注册-GitHub&quot;&gt;&lt;a href=&quot;#1-注册-GitHub&quot; class=&quot;headerlink&quot; title=&quot;1. 注册 GitHub&quot;&gt;&lt;/a&gt;1. 注册 GitHub&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.github.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt; 是我们放博客的地方，它是开源世界的一个代码仓库，甚至可以毫不夸张地说是它推动了开源运动的发展，同时它也是世界上最大的同性交友社区，咳咳——严肃点！&lt;/p&gt;
&lt;h4 id=&quot;2-学习Markdown&quot;&gt;&lt;a href=&quot;#2-学习Markdown&quot; class=&quot;headerlink&quot; title=&quot;2. 学习Markdown&quot;&gt;&lt;/a&gt;2. 学习Markdown&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://wowubuntu.com/markdown/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Markdown&lt;/strong&gt;&lt;/a&gt; 简洁优雅的语法让人可以专注于写作，越来越多的网站和作者都在使用和支持 Markdown，当然你最好找一个支持         Markdown 的编辑器。我在用的是 Evernote 的『&lt;a href=&quot;http://maxiang.info&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;马克飞象&lt;/a&gt;』，有网页版和 Chrome 插件，可以绑定Evernote账号同步，支持离线写作。因为我只需要一个编辑器，而且写完后会发布到博客，所以并没有绑定账号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果使用马克飞象没有绑定账号的话，不管是网页版还是插件版估计都会有缓存容量限制，而且文章多了会影响打开时的加载速度，所以记得写完后即使清理以前的文章。&lt;/li&gt;
&lt;li&gt;其实绑定账号后，文章都被同步到 Evernote，这样就不用考虑博客的备份问题了，是吧？&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第二步：安装软件&quot;&gt;&lt;a href=&quot;#第二步：安装软件&quot; class=&quot;headerlink&quot; title=&quot;第二步：安装软件&quot;&gt;&lt;/a&gt;第二步：安装软件&lt;/h3&gt;&lt;h4 id=&quot;1-安装Git&quot;&gt;&lt;a href=&quot;#1-安装Git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装Git&quot;&gt;&lt;/a&gt;1. 安装Git&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Git&lt;/strong&gt;&lt;/a&gt; 是一个非常流行的分布式版本控制工具，全世界的搬砖工人、射击师都在用它，据不完全统计，这些人手拉手可以绕地球……多少圈来着，还没人统计过，估计因为人太多了！！！关于 Git 到底是什么以及可以用来干什么，请自行搜索。关于 Git 的使用，甚至可以用一整本书来讲解，因为它太复杂了，但是不用担心，我们只需要学会它简单的几条命令的就可以了，这里有份 &lt;a href=&quot;http://www.bootcss.com/p/git-guide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git 简易指南&lt;/a&gt;，它对于我们的使用已经足够，甚至你连这份这份简易指南也可以不用看，后面我们会提到。但是如果你想深入学习 Git 的话，这里有官方的 &lt;a href=&quot;http://git-scm.com/book/en/v2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pro Git 英文版&lt;/a&gt; 和 &lt;a href=&quot;http://git-scm.com/book/zh/v2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pro Git 中文版&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于 Git 客户端的选择，我只讨论 Windows，我之前用过一段时间使用过 &lt;a href=&quot;https://desktop.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Desktop For Windows&lt;/a&gt;，但是感觉有点重，不管是 GUI 还是 Git Bash 启动都很慢，所以我现在只想找个轻量一点的类似 Linux 下的命令行工具，几经搜寻后，决定使用 &lt;a href=&quot;http://git-scm.com/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git 官网提供的客户端&lt;/a&gt; ，同时它还有 Linux 和 Mac 的版本。&lt;/p&gt;
&lt;p&gt;客户端安装好后，发现它也提供了Git GUI，但是从安装到现在我一次都没开过，打开 Git Bash，默认样式不是很好看，自己在右键 &lt;code&gt;Options&lt;/code&gt; 里面进行调整。然后输入如下命令对 Git 进行基本配置：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name=&lt;span class=&quot;string&quot;&gt;&quot;你的github用户名&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email=&lt;span class=&quot;string&quot;&gt;&quot;你的github注册邮箱&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global core.autocrlf &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#注释：为了避免稍后通过Hexo发布博客时出现LF would be replaced by CRLF in xxx.html 错误，我们先配置这条，Stackoverflow上有关于这个问题的讨论：http://stackoverflow.com/questions/1967370/git-replacing-lf-with-crlf.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后因为你以后大多时候可能会使用 SSH 方式和 GitHub 建立连接，你可能需要 &lt;a href=&quot;https://help.github.com/articles/generating-an-ssh-key/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置 ssh-key&lt;/a&gt;，大致原理是在本地产生一个加密串，然后将这个加密串保存到 GitHub 里面，链接里面是 GitHub 提供的详细教程。&lt;/p&gt;
&lt;p&gt;这一步最后你可以尝试 &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;利用 GitHub Pages 发布第一篇博客&lt;/a&gt;，GitHub Pages 是 GitHub 提供的一个托管个人主页的服务。这个链接里面会一步步教你建立一个repo，存放你的二级域名指向的站点，成功后 &lt;code&gt;username.github.io&lt;/code&gt; 可能不能立即访问，等十几分钟就行了。这一步算是看看你的阶段性成果。哦，差点忘了提，掌握这里面使用的 Git 命令就差不多了，前面提到的那个简易指南相对来说都有点多了。&lt;/p&gt;
&lt;h4 id=&quot;2-安装-Nodejs&quot;&gt;&lt;a href=&quot;#2-安装-Nodejs&quot; class=&quot;headerlink&quot; title=&quot;2. 安装 Nodejs&quot;&gt;&lt;/a&gt;2. 安装 Nodejs&lt;/h4&gt;&lt;p&gt;由于 Hexo 是用 Nodejs 写的，所以不解释。&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;NodeJs&lt;/strong&gt;&lt;/a&gt; 官网首页提供了 Windows 版的下载，下载完成后直接运行安装即可，最近的版本已经不需要配置环境变量什么鬼了。当然使用其它系统的请参考 Hexo &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;英文文档&lt;/a&gt; 或 &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文文档&lt;/a&gt;，首页介绍了 Nodejs 在各个系统的安装方法。&lt;/p&gt;
&lt;h4 id=&quot;3-安装-Hexo&quot;&gt;&lt;a href=&quot;#3-安装-Hexo&quot; class=&quot;headerlink&quot; title=&quot;3. 安装 Hexo&quot;&gt;&lt;/a&gt;3. 安装 Hexo&lt;/h4&gt;&lt;p&gt;安装完 Git 和 Nodejs 后，就可以安装 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Hexo&lt;/strong&gt;&lt;/a&gt; 了，其实这一步以后的过程， &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo 官方文档&lt;/a&gt; 里都包括了，但我还是想捋一下。关于为什么是 Hexo，其实我也是在 Hexo、jekyll、FarBox 等等工具上调查纠结了几天，这是 Hexo 官网的slogan：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hexo&lt;/strong&gt; —— &lt;em&gt;A fast, simple &amp;amp; powerful blog framework&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我觉得光是 Hexo 这个名字就很简洁犀利、够Geek，所以就它了，嗯~&lt;br&gt;由于安装了 Nodejs，改变了系统环境变量，所以需要 &lt;strong&gt;重启Git Bash&lt;/strong&gt;，再执行如下命令：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g hexo-cli &lt;span class=&quot;comment&quot;&gt;#安装Hexo，下面的是初始化过程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init &amp;lt;folder&amp;gt; &lt;span class=&quot;comment&quot;&gt;#初始化博客文件夹，folder是你想写博客的文件夹&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &amp;lt;folder&amp;gt; &lt;span class=&quot;comment&quot;&gt;#进入该文件夹&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install &lt;span class=&quot;comment&quot;&gt;#安装依赖&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后你应该把 &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo 官方文档&lt;/a&gt; 的Getting Started 和 Basic Usage 这两部分浏览一遍，了解 Hexo 的配置以及博客从写作到发布的流程，当然如果你有时间的话，可以浏览一下整个文档，这对于你以后想 Hack 别人的 Hexo 主题或者写自己的 Hexo 主题会有用。&lt;/p&gt;
&lt;h3 id=&quot;第三步：发布博客&quot;&gt;&lt;a href=&quot;#第三步：发布博客&quot; class=&quot;headerlink&quot; title=&quot;第三步：发布博客&quot;&gt;&lt;/a&gt;第三步：发布博客&lt;/h3&gt;&lt;p&gt;到了这里，我们的节目基本就接近尾声了，“啪~，套话又来了……”&lt;/p&gt;
&lt;h4 id=&quot;1-安装必要插件&quot;&gt;&lt;a href=&quot;#1-安装必要插件&quot; class=&quot;headerlink&quot; title=&quot;1. 安装必要插件&quot;&gt;&lt;/a&gt;1. 安装必要插件&lt;/h4&gt;&lt;p&gt;其实到这里，我们的安装软件的任务已经结束了，但为了稍后少走弯路，我直接按照解决问题后的思路来写了。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-git --save &lt;span class=&quot;comment&quot;&gt;#安装Hexo的git插件，因为我们会在Hexo里面用git发布文章&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-feed --save &lt;span class=&quot;comment&quot;&gt;#安装生成RSS的插件，方便用户订阅&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-sitemap --save &lt;span class=&quot;comment&quot;&gt;#安装生成sitemap插件，提供给蜘蛛&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-更改-Hexo-配置&quot;&gt;&lt;a href=&quot;#2-更改-Hexo-配置&quot; class=&quot;headerlink&quot; title=&quot;2. 更改 Hexo 配置&quot;&gt;&lt;/a&gt;2. 更改 Hexo 配置&lt;/h4&gt;&lt;p&gt;Hexo 配置文件 _config.yml 位于 Hexo 根目录，可用 Vim 或其他编辑工具打开修改。&lt;br&gt;&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;header&quot;&gt;## Docs: https://hexo.io/docs/configuration.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: 网站标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subtitle: 网站的子标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;description: 网站描述&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;author: 作者，即博客拥有者名字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;language: en #关于language的使用各个主题都稍有不同，看主题文档配置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...中间省略若干...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theme: again #主题名字,每次更换主题都要一定改这里&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deploy: #发布博客平台的配置，还可以增加诸如国内的gitcafe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repo: git@github.com:username/username.github.io.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 配置文件里面我只列出了主要需要修改的地方，剩余其他选项可以看看 &lt;a href=&quot;https://hexo.io/docs/configuration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档的Configuration部分&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：每个配置名称和配置内容之间要至少一个空格！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;3-更换主题&quot;&gt;&lt;a href=&quot;#3-更换主题&quot; class=&quot;headerlink&quot; title=&quot;3. 更换主题&quot;&gt;&lt;/a&gt;3. 更换主题&lt;/h4&gt;&lt;p&gt;Hexo 默认的主题有点丑，但功能还算完善，&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo官网展示了部分主题&lt;/a&gt;以及&lt;a href=&quot;https://github.com/hexojs/hexo/wiki/themes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub wiki上列出了比较全的主题&lt;/a&gt;，选定喜欢的主题后，可以到主题的项目主页看看README，有没有需要安装的包依赖，那么如何更换主题呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将主题克隆到本地，在 Hexo 根目录执行如下命令：&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/username/theme-name.git themes/theme-name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改配置文件，打开 Hexo 根目录的 _config.yml：&lt;/p&gt;
 &lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;theme: theme-name #在这里填写你更换的主题名称&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;4-写博客&quot;&gt;&lt;a href=&quot;#4-写博客&quot; class=&quot;headerlink&quot; title=&quot;4. 写博客&quot;&gt;&lt;/a&gt;4. 写博客&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;按照Scaffolds目录下提供的layout之一新建一个文件，当然你也可以写一个属于自己的layout放到此目录下，而写文章要用 post 类型的 layout，而 post 在 Hexo 的配置文件里被配置成了默认的 layout，所以如下命令的 loyout 可省略。&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo new layout &lt;span class=&quot;string&quot;&gt;&quot;postName&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#postName是博客名字，博客文件名称也是根据该名字来生成的，博客文件默认在source/_post目录下，当然这些也都是可配置的。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后用你喜欢的Markdown编辑器打开刚刚生成的博客文件，写下你想写的文字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成博客：&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo generate &lt;span class=&quot;comment&quot;&gt;#生成网页静态文件，Hexo会在根目录新建public文件夹来存放&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server &lt;span class=&quot;comment&quot;&gt;#启动本地服务器，成功后可通过浏览器输入localhost:4000来测试博客效果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy &lt;span class=&quot;comment&quot;&gt;#发布，如果前面的git插件安装后正确配置，就不会有太大问题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：hexo deploy 时每次都会覆盖原来的内容，所以记得备份。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发布成功后，就可通过 &lt;code&gt;username.github.io&lt;/code&gt;来访问你的博客。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于我正在使用的主题，我用的是 Hexo 官网展示的第一款主题 Again，不是因为我懒，而是我调查了几十个主题纠结之后的果断选择，这款主题不是很令人满意，也不是很完善，甚至没有提供分类和标签功能，但是这样反而让它看起来简单简洁，我想有时间我会将它改的更让人满意。&lt;br&gt; &lt;strong&gt;Ps&lt;/strong&gt;：关于如何创建分类和标签页面在我参考的文章里面估计可以找到&lt;/p&gt;
&lt;p&gt;关于404页面，在没有购买顶级域名的情况下，配置404页面并没什么用。&lt;/p&gt;
&lt;h3 id=&quot;曲终&quot;&gt;&lt;a href=&quot;#曲终&quot; class=&quot;headerlink&quot; title=&quot;曲终&quot;&gt;&lt;/a&gt;曲终&lt;/h3&gt;&lt;p&gt;感谢 Git、GitHub、Hexo、Markdown、Nodejs 的技术支持以及开源世界的贡献者！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Pages 主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ibruce 的 hexo-your-blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zipperary.com/categories/hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;zipperary的Hexo系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.v2ex.com/t/175940&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;V2关于hexo deploy报错的讨论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;u&gt;还包括文中其他链接&lt;/u&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序曲&quot;&gt;&lt;a href=&quot;#序曲&quot; class=&quot;headerlink&quot; title=&quot;序曲&quot;&gt;&lt;/a&gt;序曲&lt;/h3&gt;&lt;p&gt;之前有过一次搭建博客的经历，当时购买了自己的第一个 .COM 域名，并用 Wordpress 挂在了同学的服务器上，一年下来只写了有寥寥几篇
    
    </summary>
    
      <category term="technology" scheme="http://archmee.github.io/categories/technology/"/>
    
    
      <category term="git" scheme="http://archmee.github.io/tags/git/"/>
    
      <category term="github" scheme="http://archmee.github.io/tags/github/"/>
    
      <category term="hexo" scheme="http://archmee.github.io/tags/hexo/"/>
    
      <category term="markdown" scheme="http://archmee.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
