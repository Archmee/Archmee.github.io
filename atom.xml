<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archmee</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://archmee.github.io/"/>
  <updated>2019-08-19T03:25:07.568Z</updated>
  <id>http://archmee.github.io/</id>
  
  <author>
    <name>archmee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>循环引用和深度克隆</title>
    <link href="http://archmee.github.io/201908/2019-08-19.html"/>
    <id>http://archmee.github.io/201908/2019-08-19.html</id>
    <published>2019-08-15T16:00:00.000Z</published>
    <updated>2019-08-19T03:25:07.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>深度克隆我想很多人都写过，但是很多人实现的都是简单版本，对于复杂的深度克隆，基本上工程上大家都会使用 underscore 的 cloneDeep，那么深度克隆有什么技术难点呢：</p><ul><li>复杂数据类型，比如函数、正则、日期、Symbol 等不能通过直接遍历属性的方式拷贝</li><li>数据可能会有循环引用，如果一直拷贝就会无穷递归</li></ul><p>我最近在对以前实现的一个深度克隆进行思考改进的时候，灵感来了有了一点思路，下面分别进行说明</p><h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><p>第一，我们先处理复杂数据类型，我们只要实现一个严格的数据类型判断，在拷贝的时候进行判断，并分别进行处理</p><ul><li>对于基本类型数据，直接复制</li><li>对于 正则对象，可以提取字符串，再调用构造函数重新创建正则对象</li><li>对于日期对象，也可以通过构造函数重新黄建</li><li>其实比较难的是函数对象，主要是 new Function 传入的字符串会被包装到一个匿名函数中并返回，我用了一些比较hack的办法，主要是处理函数名和参数，算是暂时解决了这个问题。</li><li>除此之外的对象可以递归遍历</li></ul><p>下面直接看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!src ||</span><br><span class="line">      isString(src) ||</span><br><span class="line">      isNumber(src) ||</span><br><span class="line">      isBoolean(src)) &#123; <span class="comment">//基本值 null, undefined, string, number, bool 直接复制</span></span><br><span class="line"></span><br><span class="line">    newValue = src;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDate(src)) &#123; <span class="comment">//日期</span></span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">Date</span>(src);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(src)) &#123; <span class="comment">// 函数</span></span><br><span class="line">    <span class="comment">// 方法一，把函数解体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个函数分为三个部分，名字、参数、函数体 转换为字符串后，要分别解析出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fnString = src.toString().replace(<span class="regexp">/[\r\n]*\s+/g</span>, <span class="string">' '</span>);<span class="comment">//去掉换行符</span></span><br><span class="line">    <span class="keyword">var</span> fnMatch = fnString.match(<span class="regexp">/^function\s*(?:([\w\$]*)\s*(?:\(([\w,]*)\))(?:\s*\&#123;(.*)\&#125;))/</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> fnName = fnMatch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fnArgs = fnMatch[<span class="number">2</span>].split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">var</span> fnBody = fnMatch[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数字符串中用名字递归调用自己，我们则relace为arguments.callee</span></span><br><span class="line">    <span class="comment">// 函数名前面和后面必然有边界符才替换</span></span><br><span class="line">    <span class="keyword">if</span> (fnName) &#123;</span><br><span class="line">      fnBody = fnMatch[<span class="number">3</span>].replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+ fnName + <span class="string">'\\b'</span>), <span class="string">'arguments.callee'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">Function</span>(...fnArgs, fnBody); <span class="comment">// 这里要借助... 不然很难展开参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种，一种比较hack的方法，替换函数名字，增加立即调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传给Function一个带有function声明的函数字符串的话，一定需要函数名，</span></span><br><span class="line">    <span class="comment">// 而且返回的函数被匿名函数包裹，我们通过在字符串后面添加立即执行函数来执行</span></span><br><span class="line">    <span class="comment">// 由于这个函数时被封闭的，所以名字可以随意</span></span><br><span class="line">    <span class="comment">// var fnString = src.toString().replace(/[\r\n]*\s+/g, ' ');</span></span><br><span class="line">    <span class="comment">// var fnMatch = fnString.match(/^function\s*(?:([\w\$]*))/);</span></span><br><span class="line">    <span class="comment">// var fnName = fnMatch[1] ? fnMatch[1] : 'noName';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (!fnMatch[1]) &#123;</span></span><br><span class="line">    <span class="comment">//     fnString = fnString.replace('function', 'function ' + fnName);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 追加立即调用</span></span><br><span class="line">    <span class="comment">// fnString += ';' + fnName + '.apply(this, [].slice.call(arguments));'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// newValue = new Function(fnString); // 这里会返回一个匿名函数，匿名函数中包裹原来的函数和函数调用</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(src)) &#123; <span class="comment">// 正则</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个正则对象的字符串分为两种情况，我们只需要处理字面量</span></span><br><span class="line">    <span class="comment">// 1. /^abc/ 这种是字面量，处理为 ^abc，对于/^abc/ig 这种，要把ig提取出来作为RegExp的第二个参数</span></span><br><span class="line">    <span class="comment">// 2. 还有通过RegExp创建的 ^abc，无需处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reg = src.toString();</span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> last = reg.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> patten = reg.slice(start, last);</span><br><span class="line">    <span class="keyword">var</span> end = reg.slice(last+<span class="number">1</span>); <span class="comment">// i、g、m ...</span></span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">RegExp</span>(patten, end);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(src) || isObject(src))&#123; <span class="comment">// 数据和对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src.hasOwnProperty(item)) &#123;  <span class="comment">//防止继承属性</span></span><br><span class="line">          newValue[item] = cloneObject(src[item]); <span class="comment">// 递归复制</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">// end else</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于数据类型判断的实现比较简单，就不在这里占篇幅了，通过上面的代码，可以看出函数的处理是最复杂的，因为传给 Function 构造函数的字符串都会被放进一个匿名函数进行返回，我实现了两种hack：</p><ul><li><p>一种是，对于原函数的字符串，通过正则提取函数名、参数、函数体，由于函数体可能递归调用函数自己，所以我们替换了函数体内和函数名同名的字符串为 <code>arguments.callee</code>，然后把参数和函数体分别传给 Function。</p><p>对于Function的参数展开目前我们使用了ES6的<code>...</code>展开符，如果没有这个运算符，我们如何处理这里的参数是个问题，而且这里不能调用apply，我有了一点思考，准备单开一个主题来聊聊我的思路</p></li><li><p>第二种是，我们直接传递原函数的字符串给 Function，但是现在返回的函数是一个匿名函数包裹了原函数的形式，不能被直接调用，所以我们在匿名函数内部实现了函数立即调用，并通过匿名函数的参数调用原函数，并将我们添加的调用字符串追加到原函数的字符串后面，传给Function即可</p></li></ul><p>如果不用这种方式处理的话，目前我还没有想到什么理想的方案，如果各位有想法的话欢迎交流</p><h2 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h2><p>我那天在草稿纸上画一棵树的时候，突然想到了循环引用的问题，并开始了展开思考，当A对象引用了B对象，而B对象又引用了A对象的话就构成了循环引用，如果采用上面的方法，碰到对象就递归，那么就会进入无线循环，如何解决呢，我们要做的不是斩断这个引用，而是如果源对象就是相互引用的，那么我们拷贝的结果也应当是相互引用的，考虑如下数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'a'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  name: <span class="string">'b'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.src = b;</span><br><span class="line">b.src = a;</span><br></pre></td></tr></table></figure><p>我也实现过两次，下面展开我的思路</p><p>第一种：类似原型链的方式</p><p>如果大家了解原型链，就比较好理解这种方式，当我们使用 instanceof 操作符的时候，它会一直遍历原型链检查原型对象直到 null 才终止，我的思路和这个思想差不多。</p><p>我们可以把它想象成有两颗节点的一棵树，一开始只有一个父节点为null的根节点，当从根节点向下遍历的时候，判断这个节点的祖先节点是否和该节点指向同一个地址，如果是，则表示进入循环，直接复制地址，然后返回（不进入递归）。如果遍历完祖先节点都没有找到相同相同地址的节点，表示没有循环，则将该节点加入这棵树。</p><p>这棵树长这样，由于curent是函数闭包里面的局部变量，每次递归的时候，传递给子节点，子节点保存父节点的引用和自己的引用，所以current不会相互影响，下面的代码省略了一些之前的一些过程，只表达主要思路。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚开始的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">a, parent=null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = &#123;</span><br><span class="line">    parent: parent, <span class="comment">// 这是我们要遍历的树，伴随指针</span></span><br><span class="line">    src: a, <span class="comment">// 这是原对象，我们不能更改，只是用作检查</span></span><br><span class="line">  &#125;；</span><br><span class="line">  <span class="keyword">if</span> (checkCircle(a, current)) &#123;</span><br><span class="line">    <span class="comment">// 遍历a的属性clone，这里省略了循环</span></span><br><span class="line">    cloneObject(a, current);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">b, parent=a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = ｛</span><br><span class="line">      parent: parent,</span><br><span class="line">      src: b</span><br><span class="line">  ｝</span><br><span class="line">  <span class="keyword">if</span> (checkCircle(b, current)) &#123;</span><br><span class="line">    <span class="comment">// 遍历b的属性clone，这里省略了循环</span></span><br><span class="line">    cloneObject(b, current);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次遇到一个对象 进行遍历检查是否循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCircle</span>(<span class="params">src, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = parent;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.src === src) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很清晰的表达做了什么事情，这里的思路没问题，但没有完全解决问题，所以没有贴出完整代码。我刚开始很喜滋滋的欣赏自己的成果，然后画了一颗复杂的树进行测试，然后发现，对于当前节点对兄弟节点或者兄弟节点的子孙节点进行引用的情况没有很好的处理，这样会出现什么情况呢，就是兄弟节点会复制自己的子孙节点，而当前节点也会复制其兄弟节点或其子孙节点，这种情况表示正在创建的这颗对象树有两份其兄弟节点的拷贝，这和原对象的引用情况不符，也不是我们想要的情况，毕竟浪费了内存。</p><p>在我苦思冥想以后，我仍然基于这棵树有了新的思路，如果一个对象表示这棵树的一个节点，它一旦被访问就保存到访问列表，然后保存被复制前的地址和复制后的地址，如果下次再访问就表示被创建过了，不管其他父节点，子孙节点还是兄弟节点再访问我，就表示重复访问，那我就直接把我上次创建的新的的引用地址给它，它就不用重复创建了，这个应该算是标记法吧。而且这个还很好的解决了循环引用的问题，因为一个节点一旦被访问过就被保存起来，下一次再访问如果不是重复创建就是循环引用，perfect，这个方案非常完美的解决了问题。</p><p>下面是 show time 。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点图，保存访问过的节点</span></span><br><span class="line"><span class="keyword">var</span> nodesMap = &#123;</span><br><span class="line">  nodes: [], <span class="comment">/* &#123; oldSrc: a, newSrc: b &#125; */</span></span><br><span class="line"></span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nodes.push(node);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nodes.length = <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  find: <span class="function"><span class="keyword">function</span>(<span class="params">ref</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">        len,</span><br><span class="line">        nodes = <span class="keyword">this</span>.nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ref === nodes[i].oldSrc) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodes[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!src ||</span><br><span class="line">      isString(src) ||</span><br><span class="line">      isNumber(src) ||</span><br><span class="line">      isBoolean(src)) &#123; <span class="comment">//基本值 null, undefined, string, number, bool</span></span><br><span class="line"></span><br><span class="line">    newValue = src;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDate(src)) &#123; <span class="comment">//日期</span></span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">Date</span>(src);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(src)) &#123;</span><br><span class="line">    <span class="comment">// 方法一，把函数解体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个函数分为三个部分，名字、参数、函数体 转换为字符串后，要分别解析出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fnString = src.toString().replace(<span class="regexp">/[\r\n]*\s+/g</span>, <span class="string">' '</span>);<span class="comment">//去掉换行符</span></span><br><span class="line">    <span class="keyword">var</span> fnMatch = fnString.match(<span class="regexp">/^function\s*(?:([\w\$]*)\s*(?:\(([\w,]*)\))(?:\s*\&#123;(.*)\&#125;))/</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> fnName = fnMatch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fnArgs = fnMatch[<span class="number">2</span>].split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">var</span> fnBody = fnMatch[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数字符串中用名字递归调用自己，我们则relace为arguments.callee</span></span><br><span class="line">    <span class="comment">// 函数名前面和后面必然有边界符才替换</span></span><br><span class="line">    <span class="keyword">if</span> (fnName) &#123;</span><br><span class="line">      fnBody = fnMatch[<span class="number">3</span>].replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+ fnName + <span class="string">'\\b'</span>), <span class="string">'arguments.callee'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">Function</span>(...fnArgs, fnBody); <span class="comment">// 这里要借助... 不然很难展开参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种，一种比较hack的方法，替换函数名字，增加立即调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传给Function一个带有function声明的函数字符串的话，一定需要函数名，</span></span><br><span class="line">    <span class="comment">// 而且返回的函数被匿名函数包裹，我们通过在字符串后面添加立即执行函数来执行</span></span><br><span class="line">    <span class="comment">// 由于这个函数时被封闭的，所以名字可以随意</span></span><br><span class="line">    <span class="comment">// var fnString = src.toString().replace(/[\r\n]*\s+/g, ' ');</span></span><br><span class="line">    <span class="comment">// var fnMatch = fnString.match(/^function\s*(?:([\w\$]*))/);</span></span><br><span class="line">    <span class="comment">// var fnName = fnMatch[1] ? fnMatch[1] : 'noName';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (!fnMatch[1]) &#123;</span></span><br><span class="line">    <span class="comment">//     fnString = fnString.replace('function', 'function ' + fnName);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 追加立即调用</span></span><br><span class="line">    <span class="comment">// fnString += ';' + fnName + '.apply(this, [].slice.call(arguments));'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// newValue = new Function(fnString); // 这里会返回一个匿名函数，匿名函数中包裹原来的函数和函数调用</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(src)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个正则字符串分为两种情况，我们只需要处理字面量</span></span><br><span class="line">    <span class="comment">// 1. /^abc/ 这种是字面量</span></span><br><span class="line">    <span class="comment">// 2. 还有通过RegExp创建的 ^abc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reg = src.toString();</span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> last = reg.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> patten = reg.slice(start, last);</span><br><span class="line">    <span class="keyword">var</span> end = reg.slice(last+<span class="number">1</span>); <span class="comment">// i、g、m ...</span></span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">RegExp</span>(patten, end);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(src) || isObject(src))&#123; <span class="comment">// array and object</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点缓存中查找如果找到，则不用递归</span></span><br><span class="line">    <span class="keyword">var</span> current = nodesMap.find(src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!current) &#123; <span class="comment">// 如果没找到</span></span><br><span class="line">      <span class="comment">// 如果没找到，则创建新地址</span></span><br><span class="line">      newValue = isArray(src) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 每当访问一个节点的时候，会做两件事</span></span><br><span class="line">      <span class="comment">// 一是保存旧地址，而是创建新地址</span></span><br><span class="line">      nodesMap.add(&#123;</span><br><span class="line">        oldSrc: src,</span><br><span class="line">        newSrc: newValue,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src.hasOwnProperty(item)) &#123;  <span class="comment">//防止继承属性</span></span><br><span class="line">          newValue[item] = cloneObject(src[item]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果该节点被访问过，必然已经创建了新地址，则指向新地址即可</span></span><br><span class="line">      newValue = current.newSrc;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">// end else</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理一些克隆之外的工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = cloneObject(src);</span><br><span class="line"></span><br><span class="line">  nodesMap.reset();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要增加了几个东西</p><ul><li>首先是nodesMap，保存了一个已访问列表，每个元素都保存了一个节点的新地址和旧地址</li><li>当判断是对象类型的时候，就从nodesMap中查找该对象<ul><li>如果找到，则说明已经被访问过，并且肯定被复制了，就把新地址返回即可，不用再递归</li><li>如果没找到，则说明还是第一次访问，就创建新对象，并在nodesMap中新增访问节点，保存了被复制的对象的旧地址和新地址</li></ul></li><li>增加了一次cloneDeep的调用，这是由于cloneObject完成的时候，需要做一些清理工作</li></ul><p>上面的就是完整思路和代码了</p><p>其实还有 Symbol 类型的数据没处理，这个我想了下，Symbol 是一个生成一个唯一标识符，我知道有全局注册表，但是如果从全局注册表拿出来的话，那个Symbol就是原来的，如果生成一个新的话，是否有必要？而且Symbol数据类型对于用户几乎是不可见的</p><p>所以对于是否拷贝 Symbol 我持保留态度</p><p>如有问题，欢迎交流</p><p>biu -。-</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;深度克隆我想很多人都写过，但是很多人实现的都是简单版本，对于复杂的深度克隆，基本上工程上大家都会使用 underscore 的 cloneD
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End Deep" scheme="http://archmee.github.io/tags/Front-End-Deep/"/>
    
  </entry>
  
  <entry>
    <title>axios 源码分析</title>
    <link href="http://archmee.github.io/201908/analysis.axios.html"/>
    <id>http://archmee.github.io/201908/analysis.axios.html</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2019-08-15T10:21:45.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读完本文需要 鬼知道多少分钟</p><p>大家好，我是鬼道</p></blockquote><p>axios 是一个基于基于 Promise 的网路请求库，可以用于浏览器和node服务器，虽然经常用，但是我并没有看过内部是怎么实现的。</p><p>在某天晚上心血来潮，花了一晚上时间读完了axios的源码，其实发现也没有想象中那么难。</p><p>在进入具体细节分析前，先预览一下我阅读源码之后绘制的运行依赖图，可以感受下整体结构</p><p><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/axios-structure-2019-08-13_172827.png" alt="axios运行依赖图"></p><p>图片中对于方向表达的不是很明确，简单点说就是上层模块依赖下层模块，而右边的模块主要是为左边的这些模块提供一些通用的工具和方法，比如类型判断等，所以下边的分析重点只会聚焦于左边这一块的内容。</p><blockquote><p>从 github 上下载的 axios 代码根目录下的<code>lib</code>目录就是 axios 的所有源代码</p><p>为了易于理解，我分析的时候调整了代码顺序，并且省略了部分代码，一些工具函数也都是见名知义 :smile:</p></blockquote><h2 id="各个阶段"><a href="#各个阶段" class="headerlink" title="各个阶段"></a>各个阶段</h2><p>概括来说主要流程是这样的：</p><ul><li>调用 createInstance 创建 Axios 实例</li><li>Axios 实例中初始化了拦截器，Axios 的 request 方法被 createInstance 导出</li><li>用户发起请求，request 方法被调用，对拦截器做出响应，调用 dispatchRequest </li><li>dispatchRequest 会检查取消请求与否、转换数据 及调用网络请求库等，把数据返回给 request </li></ul><p>下面详细分析</p><h3 id="1-导入-axios"><a href="#1-导入-axios" class="headerlink" title="1. 导入 axios"></a>1. 导入 axios</h3><h4 id="1-1-导入配置对象"><a href="#1-1-导入配置对象" class="headerlink" title="1.1 导入配置对象"></a>1.1 导入配置对象</h4><blockquote><p>defaults.js</p></blockquote><p>导入配置对象，这个对象大概长这样，里面初始化了网络请求库、请求头信息等，该对象随后会在给各个模块间传递进行使用，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">defaults = &#123;</span><br><span class="line">  <span class="comment">// 根据 node 和 browser 的区别返回 http | xhr 的模块</span></span><br><span class="line">    adapter: getDefaultAdapter(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据转换，之所以把函数放进数组，是为了方便用户自定义转换函数</span></span><br><span class="line">    <span class="comment">// 这样axios就可以连续调用把数据在多个函数之间传递</span></span><br><span class="line">    <span class="comment">// 看了mergeConfig里面，好像是用户传入是会覆盖默认的</span></span><br><span class="line">    transformRequest: [transformRequest], <span class="comment">// 请求时调用，比如对象转为字符串</span></span><br><span class="line">    transformResponse: [transformResponse], <span class="comment">// 返回响应时调用，将字符串转为json</span></span><br><span class="line">    </span><br><span class="line">    timeout: <span class="number">0</span>, <span class="comment">// 请求超时时间设置</span></span><br><span class="line">    xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>,</span><br><span class="line">    xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>,</span><br><span class="line">    maxContentLength: <span class="number">-1</span>,</span><br><span class="line">    validateStatus: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 校验http状态码的函数</span></span><br><span class="line">    </span><br><span class="line">    headers = &#123;</span><br><span class="line">      common: &#123;</span><br><span class="line">        <span class="string">'Accept'</span>: <span class="string">'application/json, text/plain, */*'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">delete</span>: &#123;&#125;,</span><br><span class="line">      <span class="keyword">get</span>: &#123;&#125;,</span><br><span class="line">      head: &#123;&#125;,</span><br><span class="line">    </span><br><span class="line">      put: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">      post: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">      patch: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-创建实例"><a href="#1-2-创建实例" class="headerlink" title="1.2 创建实例"></a>1.2 创建实例</h4><blockquote><p>文件：axios.js</p></blockquote><p>无论是默认初始化还是用户调用 axios.create，都需要调用 createInstance 。</p><p>这里传入了参数 defaults，通过 Axios 创建实例，返回 request 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建实例，传入默认配置，从Axios可知，axios.defaults = defaults</span></span><br><span class="line">axios = createInstance(defaults)</span><br><span class="line"></span><br><span class="line"><span class="comment">// createInstance 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 core/Axios 创建实例</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> Axios(defaultConfig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 Axios 原型里的 request 方法的绑定到 context</span></span><br><span class="line">  <span class="comment">// 所以 instance 其实就是一个单独的 request 函数，但是绑定了 context</span></span><br><span class="line">  <span class="keyword">var</span> instance = bind(Axios.prototype.request, context);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把 Axios.prototype 的方法和属性添加到到 instance 函数里面，并将其方法的 this 都绑定到 context</span></span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 context 的方法和属性也添加到 instance 函数里面去</span></span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面几步很绕，但总结起来就是：把Axios的原型对象和实例对象里的属性和方法都复制给instance函数，</span></span><br><span class="line">  <span class="comment">// 并且所有方法的 this 都被绑定到了context，变成了静态属性或方法</span></span><br><span class="line">  <span class="comment">// 后面可以直接调用 instance() 或者 instance.xxx()</span></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露构造函数</span></span><br><span class="line">axios.create = <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将用户传入配置 和 默认配置合并，创建axios实例，但是用户传入的无效配置将不会得到处理</span></span><br><span class="line">  <span class="keyword">return</span> createInstance(mergeConfig(axios.defaults, instanceConfig));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求相关的模块</span></span><br><span class="line">axios.Cancel = <span class="built_in">require</span>(<span class="string">'./cancel/Cancel'</span>);</span><br><span class="line">axios.CancelToken = <span class="built_in">require</span>(<span class="string">'./cancel/CancelToken'</span>);</span><br><span class="line">axios.isCancel = <span class="built_in">require</span>(<span class="string">'./cancel/isCancel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送所有请求</span></span><br><span class="line">axios.all = <span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spread(function(x, y) &#123;&#125;)([1, 2]);</span></span><br><span class="line">axios.spread = <span class="built_in">require</span>(<span class="string">'./helpers/spread'</span>);</span><br></pre></td></tr></table></figure><h4 id="1-3-Axios-构造函数"><a href="#1-3-Axios-构造函数" class="headerlink" title="1.3 Axios 构造函数"></a>1.3 Axios 构造函数</h4><blockquote><p>文件：core/Axios.js</p></blockquote><p>createInstance 创建了 Axios 实例，Axios里面创建了两个 interceptor 等待 request 被调用的时候使用。</p><p>而通过代码可以看出，request 处理分三个阶段：</p><ol><li>请求前的拦截，调用 request.interceptors，如果成功才执行下一步</li><li>发出请求，调用网络请求模块</li><li>收到响应后的拦截，调用 response.interceptors</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.defaults = instanceConfig;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分别给 request和response 创建了 interceptorMnager</span></span><br><span class="line">  <span class="comment">// 我们在外面就可以调用 axios.interceptors.request.use 等方法</span></span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 request 就是整个 axios 最终导出的函数，目前还不会运行</span></span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果调用该方法之前没添加拦截器的话，dispatchRequest 会直接发请求</span></span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在chain头插入 request 的 interceptors</span></span><br><span class="line">  <span class="comment">// request 是一个interceptor对象，forEach方法是该对象自己的</span></span><br><span class="line">  <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在chain尾插入 response 的 interceptors</span></span><br><span class="line">  <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从chain头部顺序弹出fulfilled和rejected作为then函数的resolve和reject</span></span><br><span class="line">  <span class="comment">// 如果剩下 [dispatchRequest, undefined]</span></span><br><span class="line">  <span class="comment">// 则类似这样，promise.then(dispatchRequest, undefined)</span></span><br><span class="line">  <span class="comment">// 实际上在dispatchRequest左边的调用都是在请求前的，即request阶段</span></span><br><span class="line">  <span class="comment">// 如果request阶段的interceptor没问题就会得到这样的调用dispatchRequest(config)</span></span><br><span class="line">  <span class="comment">// 而 dispatchRequest 是真正发出了请求</span></span><br><span class="line">  <span class="comment">// dispatchRequest 后边的都是接收到响应后的，即response阶段</span></span><br><span class="line">  <span class="comment">// 通过分析在chain插入interceptor的顺序就可以分析出</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config); <span class="comment">// 将config对象传给then</span></span><br><span class="line">  <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">    promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为支持的请求方法提供别名比如get/post</span></span><br><span class="line"><span class="comment">// 这里实现了我们在使用的时候通过 axios.get() 这种方法的调用</span></span><br><span class="line"><span class="comment">// 但是如你所见，这只是一个别名而已，最终还是要调用 request 方法</span></span><br><span class="line"></span><br><span class="line">utils.forEach([<span class="string">'delete'</span>, <span class="string">'get'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodNoData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(utils.merge(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.forEach([<span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodWithData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, data, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(utils.merge(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url,</span><br><span class="line">      data: data, <span class="comment">// post 的数据就是从这里传入的</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1-4-InterceptorManager"><a href="#1-4-InterceptorManager" class="headerlink" title="1.4 InterceptorManager"></a>1.4 InterceptorManager</h4><blockquote><p>文件：core/InterceptorManager.js</p></blockquote><p>在Axios构造函数中创建了 InterceptorManager 实例，use 添加拦截器，eject 移除拦截器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interceptor 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InterceptorManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handlers = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加interceptor</span></span><br><span class="line"><span class="comment">// 这个方法使得我们可以在外调用 axios.interceptors.request.use(resolve, reject)</span></span><br><span class="line">InterceptorManager.prototype.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fulfilled, rejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handlers.push(&#123;</span><br><span class="line">    fulfilled: fulfilled,</span><br><span class="line">    rejected: rejected</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.handlers.length - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除interceptor</span></span><br><span class="line">InterceptorManager.prototype.eject = <span class="function"><span class="keyword">function</span> <span class="title">eject</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[id]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handlers[id] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法遍历handlers，将handler作为参数传给外面的回调fn来执行</span></span><br><span class="line"><span class="comment">// Axios.prototype.request 里面有用到这个方法</span></span><br><span class="line">InterceptorManager.prototype.forEach = <span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  utils.forEach(<span class="keyword">this</span>.handlers, <span class="function"><span class="keyword">function</span> <span class="title">forEachHandler</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h !== <span class="literal">null</span>) &#123;</span><br><span class="line">      fn(h);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-axios-请求"><a href="#2-axios-请求" class="headerlink" title="2. axios 请求"></a>2. axios 请求</h3><blockquote><p>文件：core/dispatchRequest.js</p></blockquote><p>axios 真正发出请求都会调用 request 方法，request 处理分三个阶段，请求前拦截=&gt;请求=&gt;响应后拦截，而请求是 dispatchRequest 调用网络请求模块发出，dispatch分为 5 个阶段：</p><ol><li>请求前检查请求是否被取消</li><li>请求前转换数据（可配置的 transformRequest）</li><li>调用网络请求模块发出请求</li><li>收到响应后检查请求是否被取消</li><li>收到响应后转换数据（可配置的 transformResponse）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1 请求前检查请求是否被取消</span></span><br><span class="line">  throwIfCancellationRequested(config);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2 请求前转换数据，调用transformRequest</span></span><br><span class="line">  config.data = transformData(</span><br><span class="line">    config.data,</span><br><span class="line">    config.headers,</span><br><span class="line">    config.transformRequest</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 引入adapter，xhr 或者 http</span></span><br><span class="line">  <span class="keyword">var</span> adapter = config.adapter || defaults.adapter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3 发出请求</span></span><br><span class="line">  <span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 收到响应后检查请求是否被取消</span></span><br><span class="line">    throwIfCancellationRequested(config);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5 返回响应后调用 transformResponse 处理</span></span><br><span class="line">    response.data = transformData(</span><br><span class="line">      response.data,</span><br><span class="line">      response.headers,</span><br><span class="line">      config.transformResponse</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回响应给 request 方法</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">    </span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回自定义的json错误信息，也要经过 transformResponse</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(reason);</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-xhr-adapter"><a href="#3-xhr-adapter" class="headerlink" title="3. xhr adapter"></a>3. xhr adapter</h3><blockquote><p>文件：adapters/xhr.js</p></blockquote><p>axios 的网络请求库是 xhr 和 http，由于大部分时间我都工作在浏览器端，所以我只对 xhr 进行分析。</p><p>在我删除了一些非核心代码后，它神秘的外衣渐渐褪去，就是用 Promise 包装浏览器的 XMLHttpRequest 而已</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建xhr</span></span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置超时ms</span></span><br><span class="line">    request.timeout = config.timeout;</span><br><span class="line">    </span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 根据返回的 status 判断 resolve 或 reject</span></span><br><span class="line">    &#125;;</span><br><span class="line">    request.onabort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    request.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置传入的请求头，如果有必要，添加xsrf头</span></span><br><span class="line">    request.setRequestHeader(key, val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否发送cookie</span></span><br><span class="line">    request.withCredentials = request.withCredentials ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开连接，发送请求</span></span><br><span class="line">    request.open(method, url, <span class="literal">true</span>);</span><br><span class="line">    request.send(requestData);</span><br><span class="line">    </span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><blockquote><p>文件：cancel/CancelToken.js</p></blockquote><p>由于取消请求需要调用者主动发起，所以它并不算我们主要请求阶段，所以单独拿出来聊聊</p><p>cancelToken 是一个用于取消请求的模块，我很少用，尝试过感觉难用，不光是接口难用，我看了下源码，CancelToken 构造函数和  CancelToken.source 的实现也有点难理解，不过多看几遍就明白了，我精简了下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// promise 执行器，也就是通过下面调用后，resolvePromise 可以激发 then 的调用</span></span><br><span class="line">  <span class="keyword">var</span> resolvePromise;</span><br><span class="line">  <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">promiseExecutor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolvePromise = resolve;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> token = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当cancel被调用时，reason有了，resolvePromise被执行，等待被catch接收</span></span><br><span class="line">  executor(<span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token.reason) &#123; <span class="comment">// 如果cancel已经被调用过了，就不能重复调用了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token.reason = <span class="keyword">new</span> Cancel(message);</span><br><span class="line">    resolvePromise(token.reason); <span class="comment">// 发给promise.then</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以先忽略这里</span></span><br><span class="line">CancelToken.source = <span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cancel;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建 CancelToken 实例，传入一个函数，该函数会在 CancelToken 构造函数内部传回cancel</span></span><br><span class="line">  <span class="keyword">var</span> token = <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    token: token,</span><br><span class="line">    cancel: cancel</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>are u Crying？？？</p><p>i m not！！！</p><p>CancelToken 其实做了一件事，即接收一个函数，并给了你一个接受 cancel 函数的机会，你如果调用这个 cancel 函数，就会设置 token.reason 同时触发 resolvePromise </p><p>不知道你是否还记得 dispatchRequest 的 5 个阶段，请求前和响应后都会检查请求是否被取消，而正是通过下面这个 throwIfCancellationRequested 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispatchRequest.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户请求时传入的参数是否有cancelToken，这是用户在发送请求时设置的一个CancelToken实例</span></span><br><span class="line"><span class="comment">// 如果有，则说明用户有取消的潜在需求，然后调用 cancelToken.throwIfRequested </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfCancellationRequested</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">    config.cancelToken.throwIfRequested();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CancelToken.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 reason 是否存在？</span></span><br><span class="line"><span class="comment">// 不存在，说明 cancel 没有执行过，则放你一马</span></span><br><span class="line"><span class="comment">// 存在，说明 cancel 被执行了，则报警，必须立刻马上取消请求</span></span><br><span class="line">CancelToken.prototype.throwIfRequested = <span class="function"><span class="keyword">function</span> <span class="title">throwIfRequested</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.reason) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">this</span>.reason;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，throwIfRequested 是在 dispatchRequest 中被执行的，而 dispatchRequest  是在 Axios.Prototype.request （所有请求的方法都会经过request）方法中被 <code>promise = promise.then(dispatchRequest)</code> 执行的，而这个promise最终会带着错误被返回给调用者，必然会被调用者的 catch() 捕获到</p><p>再来看一下用法，则更能容易理解了，这个CancelToken的 2 个要素： token 和 cancel 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cancel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一要素，请求时要获取一个cancelToken，并且同时要拿到cancel函数</span></span><br><span class="line">axios.get(<span class="string">'/api'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    cancel = c</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二，任何时候，你都可以调用cancel取消请求</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure><p>至于 CancelToken.source， 只是把这个过程封装了一下而已</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有几个地方提一下，感兴趣的同学自己看代码</p><ol><li><p>createInstance 函数里面</p><p>createInstance 返回后的实例 并没有被返回，而是返回了<code>axios = Axios.prototype.request</code>，我知道这样做的好处是可以直接<code>axios()</code>这样调用，也可以调用静态方法<code>axios.get()</code>，可使除此之外呢？</p></li><li><p>interceptor 在 request 方法中的链式调用</p><p>代码很简单，又觉得妙，这个 chain 大概长这个样子<code>[resolve, reject, dispatchRequest, undefined, resolve, reject]</code>，然后不断的 <code>promise = promise.then(resolve, reject)</code></p></li><li><p>一个类似于bind的函数，觉得还不错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spread</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback.apply(<span class="literal">null</span>, arr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// spread(function(x, y, z) &#123;&#125;)([1, 2, 3]);</span></span><br></pre></td></tr></table></figure></li><li><p>了解到一个新接口 URLSearchParams，见名知义，用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'id'</span>, <span class="string">'123'</span>)</span><br><span class="line">params.append(<span class="string">'name'</span>, <span class="string">'haaa'</span>)</span><br><span class="line">params.toString() <span class="comment">// id=123&amp;name=haaa</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说 axios 运行分三个阶段：</p><ol><li>导入 axios 模块<ol><li>导入 defaults 配置对象</li><li>调用 createInstance 创建一个 Axios 实例 instance，创建Axios实例的时候分别为请求和响应创建了interceptor，然后返回 Axios.Prototype.request 函数，不过这个函数复制了 Axios.Prototype 和 instance 上的所有属性和方法，方法的 this 都被绑定了 instance</li><li>这个 request 是一个核心函数，最后导出的 axios 就是这个函数（函数对象也是对象），axios.create 得到的也是一个request方法、axios.get、post、delete 这些外部可见的请求方法都是调用 request 方法</li></ol></li><li>配置 interceptor<ol><li>当我们在正式请求之前会配置 axios 的拦截器，也就是调用 axios.request.interceptor.use 和 axios.response.interceptor.use 的时候，内部的 interceptorManager 会为每一个 axios 实例维护一个request 拦截列表 和 response 拦截列表，多次调用 use 可以配置多个拦截器</li><li>interceptor 不但可以用 use 添加拦截器，也可以用 eject 移除拦截器</li></ol></li><li>调用 axios 方法<ol><li>发出请求之前，request 会按照 use 调用的顺序处理所有的 request.interceptor，如果成功，则发出请求，否则中断请求</li><li>调用 dispatchRequest 模块<ol><li>检查请求是否被用户取消，取消则中断处理</li><li>处理一些头信息并调用 transformRequest 转换数据</li><li>然后调用网络请求模块发出请求，数据返回</li><li>检查请求是否被用户取消，取消则中断处理</li><li>调用 transformResponse 转换数据，最后返回数据</li></ol></li><li>收到结果之后，request 会按照 use 调用的顺序处理所有的 response.interceptor，分别对成功和失败做出处理</li></ol></li></ol><p>sofa !</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;阅读完本文需要 鬼知道多少分钟&lt;/p&gt;
&lt;p&gt;大家好，我是鬼道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;axios 是一个基于基于 Promise 的网路请求库，可以用于浏览器和node服务器，虽然经常用，但是我并没有看过内部是怎么实现的。&lt;/p
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
      <category term="axios" scheme="http://archmee.github.io/tags/axios/"/>
    
      <category term="Source Code" scheme="http://archmee.github.io/tags/Source-Code/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：ES6 和 Mocha</title>
    <link href="http://archmee.github.io/201704/2017-04-21.html"/>
    <id>http://archmee.github.io/201704/2017-04-21.html</id>
    <published>2017-04-20T16:00:00.000Z</published>
    <updated>2019-08-15T10:36:02.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a>mocha</h2><p>mocha是一个测试框架，使用入门都是很简单的，通过阮一峰的博客可以快速入门 <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">测试框架 Mocha 实例教程</a></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>由于ES6新增内容其实是很多的，但是我们不能全部都学，而且很大一部分只适用于Nodejs，所以暂时只需要学习20%的部分来应付80%的工作即可</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>实际上为js提供了块级作用域，用它所声明的变量，只在let命令所在的代码块内有效。</li><li>解决了以前在循环中需要闭包才能解决的对循环变量的引用问题</li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug</p><h3 id="class-extends-super"><a href="#class-extends-super" class="headerlink" title="class, extends, super"></a>class, extends, super</h3><ul><li>class 声明类</li><li>extends 继承</li><li><p>super 它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p><p>  ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p></li></ul><h3 id="arrow-function-箭头函数"><a href="#arrow-function-箭头函数" class="headerlink" title="arrow function(箭头函数)"></a>arrow function(箭头函数)</h3><p>箭头函数简化了编程工作，对比：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125; <span class="comment">//ES5</span></span><br><span class="line">(i) =&gt; &#123;i + <span class="number">1</span>;&#125; <span class="comment">//ES6</span></span><br></pre></td></tr></table></figure></p><p>以前在setTimeout中的this指向全局对象，为了解决这个问题可以</p><ul><li>在setTimeout调用前保存对this的引用</li><li>或者用bind方法 method.bind(this)</li></ul><p>但是现在有了箭头函数就不用麻烦了<br><code>() =&gt; { this is outer this }</code><br>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。</p><h3 id="template-string"><a href="#template-string" class="headerlink" title="template string"></a>template string</h3><p>用``符号包起来的字符串中可以像模板中一样在<code>${}</code>中插值<code>&lt;span&gt;${data.name}&lt;/span&gt;</code></p><h3 id="destructuring（解构）"><a href="#destructuring（解构）" class="headerlink" title="destructuring（解构）"></a>destructuring（解构）</h3><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">'ken'</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">'lili'</span></span><br><span class="line"><span class="keyword">let</span> zoo = &#123;cat, dog&#125; <span class="comment">//相当于将后面所有对象拷贝到zoo</span></span><br><span class="line"><span class="comment">// zoo = &#123;cat: 'ken', dog: 'lili'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;<span class="attr">type</span>: <span class="string">'animal'</span>, <span class="attr">many</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; type, many&#125; = dog <span class="comment">//将dog对象中的值分别拷贝到前面的变量中</span></span><br><span class="line"><span class="comment">// 现在type 和 many分别是两个变量其值为dog中对应值</span></span><br></pre></td></tr></table></figure></p><p>注意上面代码中提取值时key值要保证相同，因为对象内部属性是无序的，所以不要设想是按照循序赋值</p><h3 id="default，rest"><a href="#default，rest" class="headerlink" title="default，rest"></a>default，rest</h3><ul><li><p>default(函数形参默认值)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a = <span class="number">1</span>, b = <span class="number">2</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">sum(); <span class="comment">//3</span></span><br><span class="line">sum(<span class="number">2</span>); <span class="comment">//4</span></span><br><span class="line">sum(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure></li><li><p>rest arguments<br>有点类似于ES6以前的arguments可以获取形参集合，不过arguments是个对象，而rest是个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">...types</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(types);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>); <span class="comment">//['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ES6-Module：import，export"><a href="#ES6-Module：import，export" class="headerlink" title="ES6 Module：import，export"></a>ES6 Module：import，export</h3><p>之前我们可以用AMD、CMD、UMD、CommonJs等规范来实现模块化，而现在，ES6 Module还是不能用，所以还是继续用原来的吧，不过ES6 Module规范已经出了，接下来就是看各个厂商的实现了。</p><p>顾名思义，import导入模块，export到处模块，如果熟悉模块化编程的话很容易理解它们是如何工作的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;animal, ...&#125; <span class="keyword">from</span> <span class="string">'./content'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//content.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello!'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;animal, ...&#125;</span><br></pre></td></tr></table></figure></p><ul><li>export命令除了输出变量，还可以输出函数，甚至是类</li><li>大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。</li><li>as关键字可以指定别名</li><li>整体导入用星号（*）指定一个对象，所有输出值都导入在这个对象上面。要使用as指定别名</li></ul><p>ES6模块系统和AMD相比有一些不一样的思想，总结一下就是：</p><ul><li>按需引入 vs 全局引入</li><li>多点暴漏 vs 全局暴漏</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>以上内容皆来自博客<br><a href="https://segmentfault.com/a/1190000004365693" target="_blank" rel="noopener">30分钟掌握ES6/ES2015核心内容（上）</a><br><a href="https://segmentfault.com/a/1190000004368132" target="_blank" rel="noopener">30分钟掌握ES6/ES2015核心内容（下）</a><br>如果需要深入学习，可以看：<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6入门</a><br><a href="http://www.infoq.com/cn/es6-in-depth/" target="_blank" rel="noopener">深入浅出ES6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mocha&quot;&gt;&lt;a href=&quot;#mocha&quot; class=&quot;headerlink&quot; title=&quot;mocha&quot;&gt;&lt;/a&gt;mocha&lt;/h2&gt;&lt;p&gt;mocha是一个测试框架，使用入门都是很简单的，通过阮一峰的博客可以快速入门 &lt;a href=&quot;http://www
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：模块化</title>
    <link href="http://archmee.github.io/201704/2017-04-20-3.html"/>
    <id>http://archmee.github.io/201704/2017-04-20-3.html</id>
    <published>2017-04-19T17:43:00.000Z</published>
    <updated>2019-08-15T05:10:37.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最主要的目的："><a href="#最主要的目的：" class="headerlink" title="最主要的目的："></a>最主要的目的：</h2><ul><li>解决命名冲突</li><li>依赖管理</li><li>提高代码可读性</li><li>代码解耦，提高复用性</li></ul><p>前端模块化框架肩负着 模块管理、资源加载 两项重要的功能，这两项功能与工具、性能、业务、部署等工程环节都有着非常紧密的联系。因此，模块化框架的设计应该最高优先级考虑工程需要。</p><h2 id="CMD-or-AMD-or-xMD"><a href="#CMD-or-AMD-or-xMD" class="headerlink" title="CMD or AMD or xMD"></a>CMD or AMD or xMD</h2><ul><li><p>CommonJS 主要用于服务器端，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。由于CommonJS无法直接应用于浏览器端，所以在CommonJS从服务端向前端进军的过程中，分裂出了：</p><ol><li>Modules/1.x派 认为，在现有基础上进行改进即可满足浏览器端的需要，既然浏览器端需要function包装，需要异步加载，那么新增一个方案，能把现有模块转化为适合浏览器端的就行了。</li><li>Modules/Async派 认为浏览器与服务器环境差别太大，不能沿用旧的模块标准。既然浏览器必须异步加载代码，那么模块在定义的时候就必须指明所依赖的模块，然后把本模块的代码写在回调函数里。这就是后来从CommonJS分离出去的AMD</li><li>Modules/2.0派 有点像“中间派”，既不想丢掉旧的规范，也不想像AMD那样推到重来。最终采用了Modules/Wrappings的方式</li></ol></li><li><p>UMD 是 “Universal Module Definition” 的缩写，提供了一系列模式同时兼容 CommonJS 和 AMD ，代价是代码有些丑陋。</p></li><li><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>由于requirejs有不甚优雅的地方，所以必然会有新东西来完善它，这就是后起之秀seajs，seajs的作者是国内大牛淘宝前端布道者玉伯。seajs全面拥抱Modules/Wrappings规范，不用requirejs那样回调的方式来编写模块。而它也不是完全按照Modules/Wrappings规范</p></li><li><p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p></li></ul><p><strong>AMD和CMD的区别</strong></p><pre><code>1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.2. CMD 推崇依赖就近，AMD 推崇依赖前置。</code></pre><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>对于前端工程化的内容，内容太对不是三言两语可以讲清楚的，而且它也不像其他几个方面那样可以通过看一时半会别人的博客就能够学会的。当然如果是相关工具的话，在我前面博客中提到的gulp就算是前端工程化的一方面了，还有后面应该会学习的Webpack。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/lvdabao/p/js-modules-develop.html" target="_blank" rel="noopener">http://www.cnblogs.com/lvdabao/p/js-modules-develop.html</a><br><a href="http://www.cnblogs.com/jinguangguo/archive/2013/04/06/3002515.html" target="_blank" rel="noopener">http://www.cnblogs.com/jinguangguo/archive/2013/04/06/3002515.html</a><br><a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/588</a><br><a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/547</a><br><a href="https://github.com/fouber/blog/issues/4" target="_blank" rel="noopener">https://github.com/fouber/blog/issues/4</a><br><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/277</a><br><a href="https://github.com/seajs/seajs/issues/454" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/454</a><br><a href="https://github.com/seajs/seajs/issues/1605" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/1605</a><br><a href="http://div.io/topic/430" target="_blank" rel="noopener">http://div.io/topic/430</a><br><a href="http://div.io/topic/439" target="_blank" rel="noopener">http://div.io/topic/439</a><br><a href="https://segmentfault.com/a/1190000000733959" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000733959</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/10/javascript_module.html</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html</a><br><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/11/require_js.html</a><br><a href="http://lishaopeng.com/2016/02/05/js-module/" target="_blank" rel="noopener">http://lishaopeng.com/2016/02/05/js-module/</a><br><a href="http://lishaopeng.com/2016/02/11/js-module2/" target="_blank" rel="noopener">http://lishaopeng.com/2016/02/11/js-module2/</a><br><a href="http://lishaopeng.com/2016/02/19/js-module3/" target="_blank" rel="noopener">http://lishaopeng.com/2016/02/19/js-module3/</a><br><a href="https://justineo.github.io/singles/writing-modular-js/" target="_blank" rel="noopener">https://justineo.github.io/singles/writing-modular-js/</a><br><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="noopener">http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)" target="_blank" rel="noopener">https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/require-(%E4%B8%AD%E6%96%87%E7%89%88)" target="_blank" rel="noopener">https://github.com/amdjs/amdjs-api/wiki/require-(%E4%B8%AD%E6%96%87%E7%89%88)</a><br><a href="http://requirejs.org/" target="_blank" rel="noopener">http://requirejs.org/</a><br><a href="http://www.requirejs.cn/" target="_blank" rel="noopener">http://www.requirejs.cn/</a><br><a href="http://cyj.me/why-seajs/requirejs/" target="_blank" rel="noopener">http://cyj.me/why-seajs/requirejs/</a><br><a href="http://huangxuan.me/2015/07/09/js-module-7day/" target="_blank" rel="noopener">http://huangxuan.me/2015/07/09/js-module-7day/</a><br><a href="https://ecomfe.github.io/blog/dissecting-amd-preface/" target="_blank" rel="noopener">https://ecomfe.github.io/blog/dissecting-amd-preface/</a><br><a href="https://ecomfe.github.io/blog/dissecting-amd-what/" target="_blank" rel="noopener">https://ecomfe.github.io/blog/dissecting-amd-what/</a><br><a href="https://ecomfe.github.io/blog/dissecting-amd-how/" target="_blank" rel="noopener">https://ecomfe.github.io/blog/dissecting-amd-how/</a><br><a href="https://ecomfe.github.io/blog/dissecting-amd-loader/" target="_blank" rel="noopener">https://ecomfe.github.io/blog/dissecting-amd-loader/</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html" target="_blank" rel="noopener">http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html" target="_blank" rel="noopener">http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/05/24/2514700.html" target="_blank" rel="noopener">http://www.cnblogs.com/snandy/archive/2012/05/24/2514700.html</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/06/06/2536969.html" target="_blank" rel="noopener">http://www.cnblogs.com/snandy/archive/2012/06/06/2536969.html</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/06/07/2537477.html" target="_blank" rel="noopener">http://www.cnblogs.com/snandy/archive/2012/06/07/2537477.html</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html" target="_blank" rel="noopener">http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html</a></p><p><a href="http://div.io/topic/586" target="_blank" rel="noopener">http://div.io/topic/586</a><br><a href="http://www.infoq.com/cn/articles/yunlong-on-fis" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/yunlong-on-fis</a></p><p>—-IFE2015 task4的终结线——-</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最主要的目的：&quot;&gt;&lt;a href=&quot;#最主要的目的：&quot; class=&quot;headerlink&quot; title=&quot;最主要的目的：&quot;&gt;&lt;/a&gt;最主要的目的：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解决命名冲突&lt;/li&gt;
&lt;li&gt;依赖管理&lt;/li&gt;
&lt;li&gt;提高代码可读性&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：性能优化</title>
    <link href="http://archmee.github.io/201704/2017-04-20-2.html"/>
    <id>http://archmee.github.io/201704/2017-04-20-2.html</id>
    <published>2017-04-19T17:42:00.000Z</published>
    <updated>2019-08-15T05:15:23.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Yahoo军规"><a href="#Yahoo军规" class="headerlink" title="Yahoo军规"></a>Yahoo军规</h2><h3 id="网页内容"><a href="#网页内容" class="headerlink" title="网页内容"></a>网页内容</h3><ul><li>减少http请求次数<ul><li>组合文件：将所有同类型文件组合到一起(images, css, js等)</li><li>CSS Sprites</li><li>Image Maps</li><li>Inline images(比如base64格式)</li></ul></li><li>减少DNS查询次数：每个引用的新域名(比如cdn)具有DNS查询的前端代价，你必须确保这个代价确实是值得的。</li><li>避免页面跳转</li><li>缓存Ajax</li><li>延迟加载</li><li>提前加载<ul><li>有条件</li><li>无条件</li><li>有预期的加载</li></ul></li><li>减少DOM元素数量</li><li>根据域名划分内容（动静分离）</li><li>减少iframe数量</li><li>避免404</li></ul><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul><li>使用CDN</li><li>添加Expires 或Cache-Control报文头</li><li>Gzip压缩传输文件（对pdf作用不大）</li><li>配置ETags</li><li>尽早flush输出</li><li>使用GET Ajax请求数据</li><li>避免空的图片src</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>减少Cookie大小</li><li>页面内容使用无cookie域名（动静分离）</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>将样式表置顶</li><li>用<link>代替@import</li><li>避免CSS表达式（IE）</li><li>避免使用Filters（IE）</li></ul><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><ul><li>将脚本置底或者使用deffer、async关键字</li><li>使用外部Javascirpt和CSS文件（尤其是会重复访问的网页）</li><li>精简Javascript和CSS（打包压缩）</li><li>去除重复脚本</li><li>减少DOM访问</li><li>使用智能事件处理（比如事件代理）</li></ul><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li>优化图像（去除一些无用信息）</li><li>优化CSS Sprite</li><li>不要在HTML中缩放图片</li><li>使用小且可缓存的favicon.ico</li></ul><h3 id="移动客户端"><a href="#移动客户端" class="headerlink" title="移动客户端"></a>移动客户端</h3><ul><li>保持单个内容小于25KB</li><li>打包组建成符合文档</li></ul><h2 id="给网页设计师和前端开发者看的前端性能优化"><a href="#给网页设计师和前端开发者看的前端性能优化" class="headerlink" title="给网页设计师和前端开发者看的前端性能优化"></a>给网页设计师和前端开发者看的前端性能优化</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><ul><li>将样式表放在文档的顶部</li><li>将JavaScript放在底部（可能的地方）</li><li>尽可能减少HTTP请求</li><li>从多个域名提供资源服务能增加浏览器并行下载的资源数量。</li></ul><h3 id="HTTP-请求与-DNS-查询"><a href="#HTTP-请求与-DNS-查询" class="headerlink" title="HTTP 请求与 DNS 查询"></a>HTTP 请求与 DNS 查询</h3><ul><li>浏览器受限于有多少请求可以并行发生。这也是为什么我们经常要使用子域名或者CDN；以便允许这些请求在数个域名上发生，允许同时发生多得多数量的请求。然而，一个新的域名被引用，HTTP请求会受制于一个耗时的DNS查询（某个介于20到120毫秒之间的值）</li><li>DNS查询代价很高，因此你需要决定什么才是对你的网站更合适的；承担查询的消耗或者只是由一个域名提供所有服务。</li></ul><h3 id="DNS-预取"><a href="#DNS-预取" class="headerlink" title="DNS 预取"></a>DNS 预取</h3><p>如果你的网站不得不访问第三方域名的资源，这就牵涉到了DNS查询。幸运的是，有一个相当快又简单的办法来加速这个过程：DNS预取。DNS预取所做的恰恰就是凭证领餐，如下html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"foo.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>那行简单的内容将会告诉支持的浏览器去开始预取那个域名的DNS</p><h3 id="资源预取"><a href="#资源预取" class="headerlink" title="资源预取"></a>资源预取</h3><p>虽然作者给出了和DNS预取类似的方法，但是作者似乎也不太肯定，所以可以看下作者推荐的资料</p><h3 id="CSS-与性能"><a href="#CSS-与性能" class="headerlink" title="CSS 与性能"></a>CSS 与性能</h3><ul><li>永远不要从其他资源域名提供服务 因为这会引起DNS查询并进一步延迟渲染。</li><li>先提供服务 因此浏览器可以继续忙下去。</li><li>合并它 因为不管怎样浏览器会获取所有CSS，你最好将所有这些压缩于一个HTTP请求。</li><li>压缩并简化它 以便浏览器需要下载的少一些。</li><li>缓存它的一切 以便上述的过程尽可能少的发生。</li></ul><h3 id="压缩与简化"><a href="#压缩与简化" class="headerlink" title="压缩与简化"></a>压缩与简化</h3><p>对于你的文本资源，有两个实在很简单的事情是你能（而且也应该）做的；简化他们移除任何注释和空格，并且进一步的压缩它们大小。</p><p>.htaccess评估每一个到达请求，因此实际它有很多开销。这取自 Apache 文档 ：</p><blockquote><p>你应该完全避免使用.htaccess文件，如果你可以直接访问http主服务器的配置文件的话。 使用.htaccess文件使你的Apache http server慢下来。任何你能包含进一个.htaccess文件的指令最好设置在一个<a href="http://httpd.apache.org/docs/2.2/mod/core.html#directory" target="_blank" rel="noopener">字典块</a>,因为它具有同样的效用并且有更好的性能。</p></blockquote><p>压缩（Gzip）将任何基于文本的输入，基于重复的/可重复的字符串对其进行压缩。</p><h3 id="优化图像"><a href="#优化图像" class="headerlink" title="优化图像"></a>优化图像</h3><ul><li>Spriting (精灵)</li><li>视网膜图像<br>  一旦图像解压并在浏览器中渲染，有四倍数量于平常的像素需要存储于内存，视网膜图像消耗了内存并不很多的移动设备<br>  如果统计数据表明有足够富余，你就可以针对矢量图形优化，或者用字体图标代替位图。</li><li>渐进的 JPGs</li><li>完全不用图片，如果用适量纯CSS可以完成某种效果，那么久应该使用纯CSS来实现</li></ul><h2 id="CSS-Sprites：鱼翅还是三鹿？"><a href="#CSS-Sprites：鱼翅还是三鹿？" class="headerlink" title="CSS Sprites：鱼翅还是三鹿？"></a>CSS Sprites：鱼翅还是三鹿？</h2><p>缺点</p><ul><li>拼合图片的时间成本会增加</li><li>编码和维护的时间成本会增加</li><li>不是所有图片都是背景</li><li>错误的使用 Sprites 影响可访问性</li></ul><h2 id="编写高效的-CSS-选择器"><a href="#编写高效的-CSS-选择器" class="headerlink" title="编写高效的 CSS 选择器"></a>编写高效的 CSS 选择器</h2><ul><li>浏览器解析选择器是从右到左的方式。</li><li>你的关键选择器会决定浏览器的工作量，因此，我们应该重视一下关键选择器（即匹配规则的最右一个选择器）</li><li>拥有一个明确的关键选择器最大的好处就是你可以避免使用过度限制选择器</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html" target="_blank" rel="noopener">http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html</a><br><a href="http://www.oschina.net/translate/front-end-performance-for-web-designers-and-front-end-developers" target="_blank" rel="noopener">http://www.oschina.net/translate/front-end-performance-for-web-designers-and-front-end-developers</a><br><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">https://developer.yahoo.com/performance/rules.html</a><br><a href="http://www.zhangxinxu.com/wordpress/2013/04/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2013/04/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</a><br><a href="http://www.cnblogs.com/mofish/archive/2010/10/12/1849062.html" target="_blank" rel="noopener">http://www.cnblogs.com/mofish/archive/2010/10/12/1849062.html</a><br><a href="https://www.qianduan.net/css-sprites-useful-technique-or-potential-nuisance/" target="_blank" rel="noopener">https://www.qianduan.net/css-sprites-useful-technique-or-potential-nuisance/</a><br><a href="http://www.cnblogs.com/leefreeman/p/3993449.html" target="_blank" rel="noopener">http://www.cnblogs.com/leefreeman/p/3993449.html</a><br><a href="http://www.cnblogs.com/leefreeman/p/3998757.html" target="_blank" rel="noopener">http://www.cnblogs.com/leefreeman/p/3998757.html</a><br><a href="http://web.jobbole.com/35339/" target="_blank" rel="noopener">http://web.jobbole.com/35339/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Yahoo军规&quot;&gt;&lt;a href=&quot;#Yahoo军规&quot; class=&quot;headerlink&quot; title=&quot;Yahoo军规&quot;&gt;&lt;/a&gt;Yahoo军规&lt;/h2&gt;&lt;h3 id=&quot;网页内容&quot;&gt;&lt;a href=&quot;#网页内容&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：安全</title>
    <link href="http://archmee.github.io/201704/2017-04-20-1.html"/>
    <id>http://archmee.github.io/201704/2017-04-20-1.html</id>
    <published>2017-04-19T17:41:00.000Z</published>
    <updated>2019-08-15T05:15:52.471Z</updated>
    
    <content type="html"><![CDATA[<p>这几天主要学习了JavaScript模块化的前世今生，工程化等方面知识，还包括安全防护、性能优化等方面知识，算是正式完成了<a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0004" target="_blank" rel="noopener">IFE2015 spring task4</a>，由于主要任务是优化，所以从软件界面上几乎没什么变化，不再截图。<br>由于每篇内容相对独立，所以上面所述方面的学习笔记，将分别记录在接下来的几篇博客中。</p><h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><h3 id="浅谈Web安全性（前端向）"><a href="#浅谈Web安全性（前端向）" class="headerlink" title="浅谈Web安全性（前端向）"></a>浅谈Web安全性（前端向）</h3><h4 id="攻击种类"><a href="#攻击种类" class="headerlink" title="攻击种类"></a>攻击种类</h4><p>Web基本攻击大致可以分为三大类</p><ul><li>资源枚举<br>  别有用心的人会遍历你站点所有可访问的目录，然后把一些常见的备胎文件名（比如“sql.bak”、“index-副本.html”）一个个都枚举一下，如果运气好枚举到了就直接下载。</li><li>参数操纵<br>  这里包括了SQL注入、XPath注入、cgi命令执行，还有XXS和会话劫持等。前三个的攻击主要是在服务端触发的，后二者的攻击则是侧重于客户端。</li><li>其它攻击<br>  其它攻击包括有前面未提及的CSRF攻击、钓鱼攻击和拒绝服务攻击等。</li></ul><h4 id="攻击层面"><a href="#攻击层面" class="headerlink" title="攻击层面"></a>攻击层面</h4><p>常见的攻击层面有三种：</p><ul><li>传统WEB应用程序<ol><li>表单输入</li><li>cookie</li><li>报头</li><li>请求参数</li><li>上传文件</li></ol></li><li>Web服务<ol><li>上述“传统WEB服务”的全部方法；</li><li>WSDL文档</li></ol></li><li>AJAX应用程序<br>  即上述的“一”和“二”的合集</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>综上所述，我们可以这样审视我们的WEB站点：</p><ol><li>永远不要相信客户端传来的任何信息，对这些信息都应先进行编码或过滤处理；</li><li>谨慎返回用户输入的信息</li><li>使用黑名单和白名单处理（即“不允许哪些敏感信息”或“只允许哪些信息”，白名单的效果更好但局限性高）；</li><li>检查、验证请求来源，对每一个重要的操作都进行重新验证；</li><li>使用SSL防止第三方监听通信（但无法阻止XSS、CSRF、SQL注入攻击）；</li><li>不要将重要文件、备份文件存放在公众可访问到的地方；</li><li>会话ID无序化；</li><li>对用户上传的文件进行验证（不单单是格式验证，比方一张gif图片还应将其转为二进制并验证其每帧颜色值&lt;无符号8位&gt;和宽高值&lt;无符号16位&gt;）；</li><li>WSDL文档应当要求用户注册后才能获取；</li></ol><p>虽然我们有一些必要的手段来防止WEB攻击，但永远不会有一枚silver bullet来彻底解决问题，先不谈那些数不胜数的已知的、可被攻击的漏洞，对于谜一样的0-day漏洞，我们所能做的只是提前发现并及时修补它们。</p><h3 id="有关XSS"><a href="#有关XSS" class="headerlink" title="有关XSS"></a>有关XSS</h3><h4 id="XSS的原理分析与解剖"><a href="#XSS的原理分析与解剖" class="headerlink" title="XSS的原理分析与解剖"></a>XSS的原理分析与解剖</h4><ul><li>黑客对此漏洞的偏爱，原因不需要多，只需要一个：Xss几乎每个网站都存在，google、baidu、360等都存在。</li><li>记住一句话“xss就是在页面执行你想要的js”</li></ul><h4 id="XSS的原理分析与解剖（第二篇）"><a href="#XSS的原理分析与解剖（第二篇）" class="headerlink" title="XSS的原理分析与解剖（第二篇）"></a>XSS的原理分析与解剖（第二篇）</h4><p>常见XSS</p><ul><li>反射型XSS</li><li>储蓄型XSS</li><li>DOM XSS</li><li>XSF(Flash XSS)</li><li>挖掘XSS</li></ul><h4 id="XSS的原理分析与解剖：第三章（技巧篇）"><a href="#XSS的原理分析与解剖：第三章（技巧篇）" class="headerlink" title="XSS的原理分析与解剖：第三章（技巧篇）"></a>XSS的原理分析与解剖：第三章（技巧篇）</h4><ul><li>第三方劫持 (外调J/C)：就是把资源域的服务器的权限拿下，替换相关资源，采用‘迂回式’的渗透方式。<br>  PS： J/C指的是javascript、css，不经常使用的就不说了。</li><li>XSS downloader（XSS下载器）：这个技术其实就是把反射和储蓄结合起来，把核心代码写在网站上，然后以XSS触发并调用代码，实现攻击。</li><li>XCS：XCS就是利用浏览器来玩XSS，它的功能比普通上的XSS还要强大，因为利用浏览器协议漏洞，可以调用浏览器的API来实现下载覆盖本地文件(可以把它这个功能理解为挂马)。</li><li>页面渲染XSS</li></ul><h4 id="XSS的原理分析与解剖：第四章（编码与绕过）"><a href="#XSS的原理分析与解剖：第四章（编码与绕过）" class="headerlink" title="XSS的原理分析与解剖：第四章（编码与绕过）"></a>XSS的原理分析与解剖：第四章（编码与绕过）</h4><p>编码</p><ul><li>URL编码</li><li>unicode编码</li><li>HTML编码</li><li>CSS编码</li></ul><h4 id="XSS防护"><a href="#XSS防护" class="headerlink" title="XSS防护"></a>XSS防护</h4><ol><li>验证输入并且基于语境和按照正确的顺序转义不可信数据</li><li>始终遵循白名单优于黑名单的做法</li><li>使用 UTF-8 为默认的字符编码以及设置 content 为 text/html</li><li>不要将用户可以控制的文本放在<meta>标签前。通过使用不同的字符集注射可以导致XSS</li><li>使用&lt;!DOCTYPE html&gt;</li><li>使用推荐的 HTTP 响应头进行 XSS 防护</li><li>防止 CRLF 注入/HTTP 响应拆分</li><li>禁止 TRACE 和其他非必要方法</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.2cto.com/article/201412/363743.html" target="_blank" rel="noopener">http://www.2cto.com/article/201412/363743.html</a><br><a href="http://www.freebuf.com/articles/web/40520.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/40520.html</a><br><a href="http://www.freebuf.com/articles/web/42727.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/42727.html</a><br><a href="http://www.freebuf.com/articles/44481.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/44481.html</a><br><a href="http://www.freebuf.com/articles/web/55505.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/55505.html</a><br><a href="http://www.freebuf.com/author/black-hole" target="_blank" rel="noopener">http://www.freebuf.com/author/black-hole</a><br><a href="http://www.fooying.com/chinese-translationthe-ultimate-xss-protection-cheatsheet-for-developers/" target="_blank" rel="noopener">http://www.fooying.com/chinese-translationthe-ultimate-xss-protection-cheatsheet-for-developers/</a><br><a href="https://github.com/knownsec/KCon" target="_blank" rel="noopener">https://github.com/knownsec/KCon</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天主要学习了JavaScript模块化的前世今生，工程化等方面知识，还包括安全防护、性能优化等方面知识，算是正式完成了&lt;a href=&quot;https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：GTD任务工具改版</title>
    <link href="http://archmee.github.io/201704/2017-04-15.html"/>
    <id>http://archmee.github.io/201704/2017-04-15.html</id>
    <published>2017-04-14T16:00:00.000Z</published>
    <updated>2019-08-15T05:16:31.390Z</updated>
    
    <content type="html"><![CDATA[<p>这周干了大致这样几件事情</p><ul><li>4.9 学习使用jshint</li><li>4.10 使用artTemplate分离js中的html模板代码</li><li>4.13 学习并使用css预处理less</li><li>4.15 学习gulp基本用法</li></ul><p>关于jshint我已经写了篇blog，这里不再介绍，下面来谈谈其他几个小点。</p><h2 id="artTemplate"><a href="#artTemplate" class="headerlink" title="artTemplate"></a>artTemplate</h2><p>要说模板引擎众多，诸如Mustcache，和基于Mustcache的Handlebars、或者Underscore的template，或者jQuery自带的，但是最后我相中了doT和artTemplate，而选择artTemplate是因为官网文档友好，入门简单。而且维护者比较勤，距离我在代码中使用artTemplate才几天，我刚打开官网看到又有更新动态，从文档的更新可以看出作者在加入新功能和优化。<br><a href="https://github.com/aui/art-template" target="_blank" rel="noopener">artTemplate官网</a>，介绍如是</p><blockquote><p>art-template 是一个性能出众、设计巧妙的模板引擎，无论在 NodeJS 还是在浏览器中都可以运行。</p></blockquote><p>虽然官网介绍有预编译什么高级功能，但对我目前没什么用，我只需要基础功能即可。<br>artTemplate分为原生语法和简单语法，我选择了简单语法。<br>准备写从如何从下载到正式跑通的基础入门，但是不幸的是，官网文档更新后我都有点不认识了，所以要学习的同学请查看官网。<br><img src="http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/pcmoren_tanshou_org.png" alt> <img src="http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/pcmoren_tanshou_org.png" alt> <img src="http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/pcmoren_tanshou_org.png" alt></p><h2 id="CSS预处理器Less"><a href="#CSS预处理器Less" class="headerlink" title="CSS预处理器Less"></a>CSS预处理器Less</h2><p>由于CSS不具备编程能力，而随着现代Web应用开发的复杂度增加，预处理器和后处理器应运而生。预处理器有诸如Less、Sass、Stylus，Less虽稍弱一点但是简单，所以我选择了Less，等以后需要更强大功能的时候再选择其他的，后处理器有诸如PostCSS，它们之间的区别，在我给出的参考资料中有介绍，我就不献丑了。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ul><li>安装nodejs和npm</li><li>再安装<code>npm install less -g</code></li><li>然后在命令行编译<code>lessc file.less &gt; file.css</code></li><li>在html文件中引入css文件而不是less<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4>在浏览器端直接引入less文件，我没用过，不发言。<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4>安装一个图形化编译软件，比如<a href="http://koala-app.com/index-zh.html" target="_blank" rel="noopener">koala</a>，将less项目拖入，它会在less改变时自动编译成css<h4 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h4>结合IDE使用，比如SublimeText有专门的less2css插件。<h4 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h4>结合自动化构建工具使用，比如我用gulp，然后用gulp-less插件仍然可以完成编译工作</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>慕课网也有<a href="http://www.imooc.com/course/list?c=sassless" target="_blank" rel="noopener">less的入门课程</a><br>至于其它事宜，请查看<a href="http://lesscss.org/" target="_blank" rel="noopener">官网</a>，或者<a href="http://www.lesscss.net/" target="_blank" rel="noopener">Less中文网</a></p><p>关于各种预处理器的对比文章：</p><ul><li><a href="http://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="noopener">再谈 CSS 预处理器</a></li><li><a href="http://caibaojian.com/css-processor.html" target="_blank" rel="noopener">CSS 预处理器与 CSS 后处理器</a></li></ul><h2 id="使用gulp改善开发流程"><a href="#使用gulp改善开发流程" class="headerlink" title="使用gulp改善开发流程"></a>使用gulp改善开发流程</h2><blockquote><p>用自动化构建工具增强你的工作流程！</p></blockquote><p>gulp和Grunt属于同一个对比行列，区别是gulp是基于流，而Grunt基于文件；gulp采用js语言编程控制，而Grunt使用配置文件。</p><p><a href="http://gulpjs.com" target="_blank" rel="noopener">gulp官网</a> 和 <a href="http://www.gulpjs.com.cn/" target="_blank" rel="noopener">gulp 中文网</a> 提供了入门、文档、API、插件等介绍和使用方法<br>要想了解一个gulp插件如何使用的方法，直接到<a href="http://gulpjs.com/plugins/" target="_blank" rel="noopener">gulp插件官网</a>搜索你需要的插件，然后点进去就可以找到了。</p><p>我现在使用了这几个插件：</p><p>gulp-less：这里有一篇<a href="http://www.ydcss.com/archives/34" target="_blank" rel="noopener">gulp-less入门文章</a><br>gulp-browser-sync：这是一个开发时自动刷新浏览器的插件<br>gulp-imagemin：压缩图片<br>gulp-clean-css：压缩css<br>gulp-csslint：校验css<br>gulp-uglify：混淆压缩js<br>gulp-rename：重命名输出文件<br>gulp-concat：连接文件</p><p>del不属于gulp插件，只是一个npm插件，用于清理文件文件夹：<a href="http://www.gulpjs.com.cn/docs/recipes/delete-files-folder/" target="_blank" rel="noopener">http://www.gulpjs.com.cn/docs/recipes/delete-files-folder/</a></p><p>本来我还可以加入更多插件的，比如文件合并的gulp-concat，还有压缩js的gulp-uglify等，但是考虑后期代码还要做其他工作，暂时不想引入，所以后面再说</p><p>——真的是一条分割线—–</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周干了大致这样几件事情&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4.9 学习使用jshint&lt;/li&gt;
&lt;li&gt;4.10 使用artTemplate分离js中的html模板代码&lt;/li&gt;
&lt;li&gt;4.13 学习并使用css预处理less&lt;/li&gt;
&lt;li&gt;4.15 学习gulp基本用法
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
      <category term="jshint" scheme="http://archmee.github.io/tags/jshint/"/>
    
      <category term="artTemplate" scheme="http://archmee.github.io/tags/artTemplate/"/>
    
      <category term="less" scheme="http://archmee.github.io/tags/less/"/>
    
      <category term="gulp" scheme="http://archmee.github.io/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：使用jshint</title>
    <link href="http://archmee.github.io/201704/2017-04-10.html"/>
    <id>http://archmee.github.io/201704/2017-04-10.html</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2019-08-15T05:17:26.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解jshint"><a href="#了解jshint" class="headerlink" title="了解jshint"></a>了解jshint</h2><p>安装：<a href="http://jshint.com/install/" target="_blank" rel="noopener">http://jshint.com/install/</a><br>文档：<a href="http://jshint.com/docs/" target="_blank" rel="noopener">http://jshint.com/docs/</a><br>所有配置项：<a href="http://jshint.com/docs/options/" target="_blank" rel="noopener">http://jshint.com/docs/options/</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>jshint有一系列的默认警告，但是它也被设计可配置的。<br>官网上说有三种主要方法配置jshint</p><ul><li>命令行通过 –config 选项手动指定配置文件</li><li>.jshintrc后缀的文件</li><li>或者通过package.json中指定jshintConfig选项<br>还有下面两种算是辅助方法吧</li><li>内联配置也算是一种吧</li><li>在IDE的jshint插件中也可以配置</li></ul><p>jshint配置文件是一个简单的json文件，用来指定jshint选项的开或关，配置项在上面提供的网址中查看。示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"undef"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"unused"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"globals"</span>: &#123;</span><br><span class="line">    <span class="string">"MY_GLOBAL"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="内联配置"><a href="#内联配置" class="headerlink" title="内联配置"></a>内联配置</h3><p>jshint也可以采用内联配置，和内联css、js概念上差不多，就是直接将jshint配置项写到js文件的注释中，不过要以jshint提供的关键字开头才能识别，各个配置项之间用逗号分隔。例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* jshint undef: true, unused: true */</span></span><br><span class="line"><span class="comment">/* globals MY_GLOBAL */</span></span><br></pre></td></tr></table></figure></p><p>而且，这些注释是有函数作用域的，即如果你将配置注释放到函数内部，那么这些配置就只影响该函数。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>jshint指令</p><ul><li>jshint：/<em> jshint strict: true </em>/</li><li>jshint兼容的jslint：/<em> jslint vars: true </em>/</li><li>globals: /<em> globals MY_LIB: false </em>/，你也可以指定一个黑名单确保某些全局名称没有被使用：/<em> globals -BAD_LIB </em>/</li><li>exported：/<em> exported EXPORTED_LIB </em>/，告诉jshint在当前文件中定义的却未使用或在其他地方使用的全局变量</li><li>ignore：告诉jshint要忽略的代码块，在ignore:start 和 ignore:end 之间的代码将不会被传递给jshint：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code here will be linted with JSHint.</span></span><br><span class="line"><span class="comment">/* jshint ignore:start */</span></span><br><span class="line"><span class="comment">// Code here will be ignored by JSHint.</span></span><br><span class="line"><span class="comment">/* jshint ignore:end */</span></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">另外，也可以通过行尾注释来忽略单行</span></span><br><span class="line"><span class="string">ignoreThis(); // jshint ignore:line</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### jsint选项</span></span><br><span class="line"><span class="string">jshint选项有两种类型的选项：强制的 和 宽松的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">jshint --verbose jsfile，可以查看具体的代码警告，每种警告都有一个号码，可以通过jshint配置来忽略该警告：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">/* jshint -W034 */</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>不过这一条只对代码警告有用(W开头)，对代码错误无用(E开头)</li><li>和这个号码有关的警告都将被禁止<br>不过可以配置重新打开警告：/<em> jshint +W034 </em>/</li></ol><p>上面这个功能特别有用的地方就在于，当你知道某个有警告的代码是安全的，你可以禁用它，在随后的代码中在重新打开，比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">/*jshint -W089 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> y) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*jshint +W089 */</span></span><br></pre></td></tr></table></figure></p><p>其他细节描述需要自己去看文档，我懒得翻译了</p><h2 id="SublimeText插件"><a href="#SublimeText插件" class="headerlink" title="SublimeText插件"></a>SublimeText插件</h2><p>如果按照上述方法安装了jshint，那么久可以在命令行中开始使用了，但是对于经常开发的同学会不方便，所以是可以作为IDE的插件来使用的。<br>由于我使用的是ST3，那么我就只谈谈我如何基于ST3来使用的。<br>官网推荐了三个基于ST的插件，最强大的是SublimeLinter3（基于ST3），不过强大也就意味着复杂，安装配置都稍显复杂，因为SublimeLinter3只是一个代码校验工具管理器，它可以对多种语言进行校验，而jshint只是它的可安装的插件，所以如果要成功用上jshint，还要单独安装jshint插件并配置，差不多同时需要安装Nodejs、SublimeLinter3、jshint的npm插件、以及SublimeLinter3-jshint，详细的安装过程可参考<a href="https://gaohaoyang.github.io/2015/03/26/sublimeLinter/" target="_blank" rel="noopener">这篇博客</a>。<br>虽然繁琐，但是如果你的开发需要同时验证多种语言的话还是不错的一个解决方案，比如对CSS校验它就提供了SublimeLinter3-csslint，当然csslint也是一个可单独安装使用的工具，只是SublimeLinter3对它提供了支持。</p><p>不过对于仅仅只想验证js代码的我来说，SublimeLinter就太麻烦了，所以我选择了<a href="https://github.com/victorporof/Sublime-JSHint" target="_blank" rel="noopener">Sublime-JSHint Gutter</a>，进入ST的install package面板，输入<code>JSHint Gutter</code>即可一键安装（注意：不需要再单独安装jshint的npm插件）。如果英文吃力的话可以参考这篇博客 <a href="https://jinlong.github.io/2014/10/25/jshint-configuration/" target="_blank" rel="noopener">JSHint 配置浅析</a>。</p><p>按下 <code>Ctrl+Shift+j</code> 让你的代码接受考验吧。<br>如果有问题的话记得在package setting中打开JSHint Gutter的菜单看看有什么配置需要更改的就好了，比如node的PATH指向是否正确。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;了解jshint&quot;&gt;&lt;a href=&quot;#了解jshint&quot; class=&quot;headerlink&quot; title=&quot;了解jshint&quot;&gt;&lt;/a&gt;了解jshint&lt;/h2&gt;&lt;p&gt;安装：&lt;a href=&quot;http://jshint.com/install/&quot; target
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
      <category term="jshint" scheme="http://archmee.github.io/tags/jshint/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：GTD移动端适配</title>
    <link href="http://archmee.github.io/201704/2017-04-08.html"/>
    <id>http://archmee.github.io/201704/2017-04-08.html</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2019-08-15T05:18:24.552Z</updated>
    
    <content type="html"><![CDATA[<p>这可能是一篇流水账，但是用来梳理这都干了什么事情是一件很有意义的事情，尤其是对我自己而言。<br>首先，上一篇博客最后留下的计划都没有实现，因为我似乎忘了一件很重要的事情，那就是 <a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0004" target="_blank" rel="noopener">IFE2015 task4</a> 还没有完成，我决定尝试一下。当然，计划往往就不是用来实现的。</p><h2 id="事件大纲"><a href="#事件大纲" class="headerlink" title="事件大纲"></a>事件大纲</h2><ol><li>3月初 开始学习IFE2015 task4提供的移动端开发入门资料</li><li>3.13 完成了第一条，并准备开始实践——重构任务3之适配移动端</li><li>3.21 看了一本叫《SPA设计与架构》的书，在上一条开始后我并没有马上动手，而是买了这本书，书是好书，并且对比了几种框架来学习，并且围绕前端工程化讲解了SPA路由、模块化（requirejs）、自动构建（gulp）、单元测试（Qunit）、服务端通信和Promise的用法。但是目前对我的移动端适配一点用处都没有，而且还不打算对任务3进行完全重构，采用工具是后面的事情，但是这本书从思想上算是帮我拨开了重重迷雾。（有空上学习笔记）</li><li>3.31 完成移动端布局适配并在模拟器上成功测试，但是在真机测试时发现了诸多问题，并开始改进，有些什么样的问题以及如何解决的方案都在后面</li><li>4.5 已经解决了移动端真机上大部分问题，并且对界面做了很多美化调整和css的合并工作，</li><li>4.6至7 重构分类模块，改写了用户提示部分的功能，重构带到的目的写在后面。</li></ol><h2 id="适配移动端遇到的问题"><a href="#适配移动端遇到的问题" class="headerlink" title="适配移动端遇到的问题"></a>适配移动端遇到的问题</h2><ol><li>在没有处理手势的情况下，几个定宽100%的页面之间可以直接通过手指滚动，而且从页面底部的横向导航条可以看出宽度不是不是100%而是200%或者更多<br> 原因: 几个内部page虽然都是100%，但同时也是absolute定位，所以影响了外层main<br> 解决：对外层main绝对定位并定宽100%以及指定overflow为hidden</li><li>打开app隐藏工具栏<br> 解决：好吧，这条我用别人推荐的setTimeout+scrollTop方法没实现，只能手动上滑隐藏</li><li>添加编辑任务的页面有几个问题<ul><li>input text内的文字位置不对<br>  解决：input text继承了父元素的line-height高度导致的，重新指定为text框一样的高度即可</li><li>input date不能弹出日期选择器<br>  解决，因为之前在js中处理了指定的事件后就阻止了其他地方单击事件的行为，结果误杀了</li><li>字体太小需要调整<br>  解决：使用rem</li></ul></li><li>页面的滚动动画在qq浏览器中可以，但是在默认的红米2自带浏览器中却直接跳转，省略了中间的过渡动画，搜索得知该浏览器是opera的。<br> 原因：手机浏览器内核比较旧，不支持CSS3标准<br> 解决：在page类的规则中transition要写成带浏览器前缀的兼容方式，后面不指定对哪种行为的过渡，如果要指定transform，那就要写成带浏览器前缀的transform，比如-webkit-transition: -webkit-transform;）</li><li>页内区域滚动不方便甚至滚不动<br> 解决，要在加了overflow=auto希望滚动的绝对定位元素的外层绝对定位元素加上overflow=hidden，其他条件我没试过，只是我的情况刚好是这样</li><li>-webkit-内核的浏览器点击元素闪烁问题<br> 解决：-webkit-tap-highlight-color: transparent;</li><li>ipad上对transform实现的翻页效果不感冒，中间会白屏闪烁，而且对hover类不起作用，长按也不行<br> 解决：绑定ontuchend事件，事件处理函数为空即可，同时解决了这两个问题。</li><li>如何让一组按钮在容器中水平垂直居中 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">btns</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btns</span> <span class="selector-class">.btns-inner</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="重构带来的变化"><a href="#重构带来的变化" class="headerlink" title="重构带来的变化"></a>重构带来的变化</h2><p>我不是全部重构，只是单单对分类模块的数据存储的方式一直耿耿于怀。虽然还做了其他代码清理工作，但都不是重点。<br>之前有一篇博客我记录了实现task3的思路，以及数据存储方式。所有分类用key值存储在一个对象中，然后将这个汇总的对象用了一个名为category_list的key存进了localStorage，每次打开app都要加载分类数据，而且仅仅只有这一次读取，这个分类被读出后就一直保存在内存中使用直到关闭app或网页，每次分类数据发生变更则直接更改内存中的对象，然后再次更新到localStorage。<br>app当然还是可以运行，但是这种实现有什么问题？</p><ul><li>优点：这个方法的优点就是一次读取，终身使用（app打开期间），由于分类保存在内存中，所以每当分类有新的更新或读取操作都会很快，但是我的理解是，分类这个东西一般只在某一段时间高频率的添加删除更新数据，一般分类创建后后期更新非常少，更多的时候大家都是对任务操作频率更高一点。<br>还有一个优点是由于我的分类设计为多级的（不限），所以整个category不管数据还是DOM都是以树状结构呈现的，所以要遍历category树是肯定的，所以直接从内存读取速度也会很快，但是仅限于app打开时的首次加载。</li><li>缺点：一次读取所有分类数据在app运行期间一直滞留在内存中很少使用，严重浪费内存，这一条已经足够了。</li></ul><p>我用表格来模拟一下在重构前后localStorage的变化<br>重构前：</p><table><thead><tr><th>key</th><th>Value</th></tr></thead><tbody><tr><td>category_list</td><td>[分类对象1, 分类对象2, 分类对象3]</td></tr><tr><td>todoid1</td><td>todo对象</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>重构后：</p><table><thead><tr><th>key</th><th>Value</th></tr></thead><tbody><tr><td>topCatId</td><td>catid1</td></tr><tr><td>catid1</td><td>分类对象</td></tr><tr><td>todoid1</td><td>todo对象</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>可能有人发现多出了一个topCatId，好吧，其实前面忘了交代，考虑到让整个category更像只有一个根节点的树状，所以我要维护一个“顶级分类”，顶级分类下的子分类就是一级分类，下面的依次类推，而顶级分类仍然是一个分类对象，所以他要和其他分类放在一起组成一张“表”，所以我要拿到它的id确保它就是根节点。</p><p>重构之前也是有这个topCatId存在的，只是他没有被放置在localStorage中，而是写死在了程序中，那也就意味着不够灵活，如果发生变更，尤其是在程序员在更新程序时将其改变，那么也就意味着老用户在打开同一个网站或app时看不到原来的数据或者发生错误，因为程序在localStorage中得不到正确的数据，虽然用户原来的数据都还在。</p><p>而重构之后的方法则更为灵活，在程序初始化时，会读取topCatId，如果有，则开始遍历分类树了，如果没有，则新建一个“顶级分类”，将顶级分类的id存储为topCatId即可。perfect！</p><h2 id="PC和客户端展示"><a href="#PC和客户端展示" class="headerlink" title="PC和客户端展示"></a>PC和客户端展示</h2><p><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/201704080055.png" alt="GTD tool pc端"></p><p><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/201704080055.gif" alt="GTD tool 移动端"></p><h2 id="The-Next"><a href="#The-Next" class="headerlink" title="The Next"></a>The Next</h2><p>下一步就是学习nodejs、es6、vue2、less、sass、gulp、webpack、requirejs、seajs<br>等balabalabalabala，计划总是会变的，who knows！<br><img src="http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/pcmoren_tanshou_org.png" alt></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://junmer.github.io/mobile-dev-get-started/#/" target="_blank" rel="noopener">https://junmer.github.io/mobile-dev-get-started/#/</a><br><a href="https://github.com/jtyjty99999/mobileTech" target="_blank" rel="noopener">https://github.com/jtyjty99999/mobileTech</a><br><a href="https://github.com/maxzhang/maxzhang.github.com/issues/21" target="_blank" rel="noopener">https://github.com/maxzhang/maxzhang.github.com/issues/21</a><br><a href="https://github.com/maxzhang/maxzhang.github.com/issues/22" target="_blank" rel="noopener">https://github.com/maxzhang/maxzhang.github.com/issues/22</a><br><a href="https://github.com/maxzhang/maxzhang.github.com/issues/23" target="_blank" rel="noopener">https://github.com/maxzhang/maxzhang.github.com/issues/23</a><br><a href="https://github.com/maxzhang/maxzhang.github.com/issues/32" target="_blank" rel="noopener">https://github.com/maxzhang/maxzhang.github.com/issues/32</a><br><a href="http://www.css88.com/archives/6410" target="_blank" rel="noopener">http://www.css88.com/archives/6410</a><br><a href="http://www.meow.re/original/2015/04/27/screen-adaptation-in-mobileweb/" target="_blank" rel="noopener">http://www.meow.re/original/2015/04/27/screen-adaptation-in-mobileweb/</a><br><a href="https://isux.tencent.com/web-app-rem.html" target="_blank" rel="noopener">https://isux.tencent.com/web-app-rem.html</a><br><a href="http://www.cnblogs.com/yexiaochai/p/4219523.html" target="_blank" rel="noopener">http://www.cnblogs.com/yexiaochai/p/4219523.html</a><br><a href="http://www.cnblogs.com/rubyisaPM/p/4380056.html" target="_blank" rel="noopener">http://www.cnblogs.com/rubyisaPM/p/4380056.html</a><br><a href="http://www.codingserf.com/index.php/2014/07/responsive-and-mobile-1/" target="_blank" rel="noopener">http://www.codingserf.com/index.php/2014/07/responsive-and-mobile-1/</a><br><a href="http://www.codingserf.com/index.php/2014/08/responsive-and-mobile-2/" target="_blank" rel="noopener">http://www.codingserf.com/index.php/2014/08/responsive-and-mobile-2/</a><br><a href="http://www.html-js.com/article/2402" target="_blank" rel="noopener">http://www.html-js.com/article/2402</a><br><a href="http://www.html-js.com/article/2400" target="_blank" rel="noopener">http://www.html-js.com/article/2400</a><br><a href="http://www.w3cplus.com/css3/css3-3d-transform.html" target="_blank" rel="noopener">http://www.w3cplus.com/css3/css3-3d-transform.html</a><br><a href="http://www.w3cplus.com/mobile/mobile-terminal-refactoring-slider.html" target="_blank" rel="noopener">http://www.w3cplus.com/mobile/mobile-terminal-refactoring-slider.html</a><br><a href="http://www.w3cplus.com/blog/tags/429.html" target="_blank" rel="noopener">http://www.w3cplus.com/blog/tags/429.html</a><br><a href="http://www.codingserf.com/index.php/2014/02/css3-transitions-animations/" target="_blank" rel="noopener">http://www.codingserf.com/index.php/2014/02/css3-transitions-animations/</a><br><a href="https://gaohaoyang.github.io/2015/06/17/web-app/" target="_blank" rel="noopener">https://gaohaoyang.github.io/2015/06/17/web-app/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这可能是一篇流水账，但是用来梳理这都干了什么事情是一件很有意义的事情，尤其是对我自己而言。&lt;br&gt;首先，上一篇博客最后留下的计划都没有实现，因为我似乎忘了一件很重要的事情，那就是 &lt;a href=&quot;https://github.com/baidu-ife/ife/tree/
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
      <category term="web app" scheme="http://archmee.github.io/tags/web-app/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：移动WEB开发入门学习笔记</title>
    <link href="http://archmee.github.io/201703/2017-03-13.html"/>
    <id>http://archmee.github.io/201703/2017-03-13.html</id>
    <published>2017-03-12T16:00:00.000Z</published>
    <updated>2019-08-15T05:18:40.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动WEB开发入门"><a href="#移动WEB开发入门" class="headerlink" title="移动WEB开发入门"></a>移动WEB开发入门</h2><p><a href="https://junmer.github.io/mobile-dev-get-started/#/" target="_blank" rel="noopener">移动WEB开发入门</a></p><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p>px - 固定大小<br>em: 是相对父元素的字体大小单位<br>rem: 是相对根元素的字体大小单位，可用于多屏适配，统一修改</p><h3 id="横竖屏"><a href="#横竖屏" class="headerlink" title="横竖屏"></a>横竖屏</h3><p>监听横竖屏切换<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'orientationchange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// rerender something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>针对横竖屏的样式<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">media</span>=<span class="string">"all and (orientation:portrait)"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 竖屏 */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">media</span>=<span class="string">"all and (orientation:landscape)"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 横屏 */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="兼容Flex："><a href="#兼容Flex：" class="headerlink" title="兼容Flex："></a>兼容Flex：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;      <span class="comment">/* OLD - iOS 6-, Safari 3.1-6 */</span></span><br><span class="line">    <span class="attribute">display</span>: -moz-box;         <span class="comment">/* OLD - Firefox 19- (buggy but mostly works) */</span></span><br><span class="line">    <span class="attribute">display</span>: -ms-flexbox;      <span class="comment">/* TWEENER - IE 10 */</span></span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex;     <span class="comment">/* NEW - Chrome */</span></span><br><span class="line">    <span class="attribute">display</span>: flex;             <span class="comment">/* NEW, Spec - Opera 12.1, Firefox 20+ */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打开数字键盘："><a href="#打开数字键盘：" class="headerlink" title="打开数字键盘："></a>打开数字键盘：</h3><p> <code>&lt;input type=&quot;tel&quot;&gt;</code></p><h3 id="隐藏地址栏：-setTimeout-function-window-scrollTo-0-1-0"><a href="#隐藏地址栏：-setTimeout-function-window-scrollTo-0-1-0" class="headerlink" title="隐藏地址栏： setTimeout(function(){ window.scrollTo(0, 1); }, 0);"></a>隐藏地址栏： <code>setTimeout(function(){ window.scrollTo(0, 1); }, 0);</code></h3><h3 id="添加到主屏幕"><a href="#添加到主屏幕" class="headerlink" title="添加到主屏幕"></a>添加到主屏幕</h3><p>在iPhone,iPad,iTouch的safari上可以使用添加到主屏按钮将网站添加到主屏幕上：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">href</span>=<span class="string">"apple-touch-icon-iphone.png"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">sizes</span>=<span class="string">"72x72"</span> <span class="attr">href</span>=<span class="string">"apple-touch-icon-ipad.png"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">sizes</span>=<span class="string">"114x114"</span> <span class="attr">href</span>=<span class="string">"apple-touch-icon-iphone4.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="工具或库："><a href="#工具或库：" class="headerlink" title="工具或库："></a>工具或库：</h3><ul><li>click 有 300± ms 延迟 服用 <a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a> 后, 可以解决 click 的延迟, 还可以防止 穿透(跨页面穿透除外), 嘿嘿嘿</li><li>区域滚动 overflow:auto 不靠谱<ul><li>iscroll</li><li>saber-scroll</li></ul></li><li>hammerjs. 一个触摸手势库</li><li>食指点击目标尺寸是44 x 44像素，拇指是72 x72像素 finger friendly design</li><li><code>-WEBKIT-TAP-HIGHLIGHT-COLOR: RGBA(255,255,255,0)</code>，可以屏蔽点击元素时出现的阴影, 常用于有事件代理的父元素</li><li>font icon：矢量图标, 自由变化大小, 颜色; 妈妈再也不用担心我的切图</li><li>base64：减少一个请求, 首屏图片无延迟; 图片没法gzip，而css可以</li><li>lazyload：有流量就会放肆，没流量就会克制</li></ul><h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><ul><li>合理使用渐变/圆角/阴影</li><li>别太多, 低端机 hold 不住</li><li>代替js动画</li><li><p>性能好, 兼容好, why not?</p></li><li><p>translate3d：开启GPU硬件加速, 提升动画渲染性能</p></li></ul><h3 id="避免事项"><a href="#避免事项" class="headerlink" title="避免事项"></a>避免事项</h3><ul><li>localStorage：每个域的最大长度为5MB</li><li><p>iframe：卡 cry, viewport 失效, iOS 宽高失效, fixed定位错误</p></li><li><p>fixed + input什么仇什么怨</p></li><li>移动商桥 ios/android 分版本 hack</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul><li><p>安卓chrome远程调试<br>chrome://inspect/#devices</p></li><li><p>weinre<br>npm安装：npm install -g weinre<br>启动weinre：weinre –boundHost -all- –httpPort 8081</p></li><li><p>browserSync 神器推荐</p></li></ul><h2 id="移动前端不得不了解的HTML5-head-头标签"><a href="#移动前端不得不了解的HTML5-head-头标签" class="headerlink" title="移动前端不得不了解的HTML5 head 头标签"></a>移动前端不得不了解的HTML5 head 头标签</h2><p><a href="http://www.css88.com/archives/6410" target="_blank" rel="noopener">移动前端不得不了解的HTML5 head 头标签（2016最新版）</a></p><h3 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--移动端的页面这个可以忽略，具体可以查看本文Internet Explorer浏览器部分--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--具体可以查看本文 为移动设备添加 viewport 部分--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上 3 个 meta 标签 *必须* 放在 head 的最前面；其他任何的 head 内容必须在这些标签的 *后面* --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> <span class="comment">&lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Charset"><a href="#Charset" class="headerlink" title="Charset"></a>Charset</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>html5 之前网页中会这样写：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="lang属性："><a href="#lang属性：" class="headerlink" title="lang属性："></a>lang属性：</h3><p>简体中文：<code>&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;</code><br>繁体中文：<code>&lt;html lang=&quot;zh-cmn-Hant&quot;&gt;</code></p><h3 id="meta标签分类："><a href="#meta标签分类：" class="headerlink" title="meta标签分类："></a>meta标签分类：</h3><p>meta标签根据属性的不同，可分为两大部分：http-equiv 和 name 属性。</p><ul><li>http-equiv：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助浏览器正确地显示网页内容。</li><li>name属性：主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于浏览器，搜索引擎等机器人识别，等等。</li></ul><h3 id="推荐使用的meta标签"><a href="#推荐使用的meta标签" class="headerlink" title="推荐使用的meta标签:"></a>推荐使用的meta标签:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置文档的字符编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上 3 个 meta 标签 *必须* 放在 head 的最前面；其他任何的 head 内容必须在这些标签的 *后面* --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 允许控制资源的过度加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 尽早地放置在文档中 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 仅应用于该标签下的内容 --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- Web 应用的名称（仅当网站被用作为一个应用时才使用）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"application-name"</span> <span class="attr">content</span>=<span class="string">"应用名称"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 针对页面的简短描述（限制 150 字符）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在*某些*情况下，该描述是被用作搜索结果展示片段的一部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"一个页面描述"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 控制搜索引擎的抓取和索引行为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow,noodp"</span>&gt;</span><span class="comment">&lt;!-- 所有的搜索引擎 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"googlebot"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>&gt;</span><span class="comment">&lt;!-- 仅对 Google 有效 --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 告诉 Google 不显示网站链接的搜索框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"google"</span> <span class="attr">content</span>=<span class="string">"nositelinkssearchbox"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 告诉 Google 不提供此页面的翻译 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"google"</span> <span class="attr">content</span>=<span class="string">"notranslate"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 验证 Google 搜索控制台的所有权 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"google-site-verification"</span> <span class="attr">content</span>=<span class="string">"verification_token"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 用来命名软件或用于构建网页（如 - WordPress、Dreamweaver）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"generator"</span> <span class="attr">content</span>=<span class="string">"program"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 关于你的网站主题的简短描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"subject"</span> <span class="attr">content</span>=<span class="string">"你的网站主题"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 非常简短（少于 10 个字）的描述。主要用于学术论文。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"abstract"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 完整的域名或网址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">content</span>=<span class="string">"https://example.com/"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"directory"</span> <span class="attr">content</span>=<span class="string">"submission"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 基于网站内容给出一般的年龄分级 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"rating"</span> <span class="attr">content</span>=<span class="string">"General"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 允许控制 referrer 信息如何传递 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"never"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 禁用自动检测和格式化可能的电话号码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 通过设置为 “off” 完全退出 DNS 预取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 在客户端存储 cookie，web 浏览器的客户端识别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"set-cookie"</span> <span class="attr">content</span>=<span class="string">"name=value; expires=date; path=url"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 指定要显示在一个特定框架中的页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Window-Target"</span> <span class="attr">content</span>=<span class="string">"_value"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 地理标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"ICBM"</span> <span class="attr">content</span>=<span class="string">"latitude, longitude"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"geo.position"</span> <span class="attr">content</span>=<span class="string">"latitude;longitude"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 国家代码 (ISO 3166-1): 强制性, 州代码 (ISO 3166-2): 可选; 如 content="US" / content="US-NY" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"geo.region"</span> <span class="attr">content</span>=<span class="string">"country[-state]"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如 content="New York City" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"geo.placename"</span> <span class="attr">content</span>=<span class="string">"city/town"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SEO-优化部分："><a href="#SEO-优化部分：" class="headerlink" title="SEO 优化部分："></a>SEO 优化部分：</h3><ul><li><p>页面标题标签(head 头部必须)：<br><code>&lt;title&gt;your title&lt;/title&gt;</code></p></li><li><p>页面关键词 keywords：<br><code>&lt;meta name=&quot;keywords&quot; content=&quot;your keywords&quot;&gt;</code></p></li><li><p>页面描述内容 description：<br><code>&lt;meta name=&quot;description&quot; content=&quot;your description&quot;&gt;</code></p></li><li><p>定义网页作者 author：<br><code>&lt;meta name=&quot;author&quot; content=&quot;author,email address&quot;&gt;</code></p></li><li><p>定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。<br><code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;</code></p></li></ul><h3 id="favicon-图标"><a href="#favicon-图标" class="headerlink" title="favicon 图标"></a>favicon 图标</h3><p>IE 11, Chrome, Firefox, Safari, Opera支持设置：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"path/to/favicon-16.png"</span> <span class="attr">sizes</span>=<span class="string">"16x16"</span> <span class="attr">type</span>=<span class="string">"image/png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"path/to/favicon-32.png"</span> <span class="attr">sizes</span>=<span class="string">"32x32"</span> <span class="attr">type</span>=<span class="string">"image/png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"path/to/favicon-48.png"</span> <span class="attr">sizes</span>=<span class="string">"48x48"</span> <span class="attr">type</span>=<span class="string">"image/png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"path/to/favicon-62.png"</span> <span class="attr">sizes</span>=<span class="string">"62x62"</span> <span class="attr">type</span>=<span class="string">"image/png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"path/to/favicon-192.png"</span> <span class="attr">sizes</span>=<span class="string">"192x192"</span> <span class="attr">type</span>=<span class="string">"image/png"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><ul><li><p>viewport 可以让布局在移动浏览器上显示的更好。 通常会写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>width=device-width 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边(<a href="http://bigc.at/ios-webapp-viewport-meta.orz" target="_blank" rel="noopener">http://bigc.at/ios-webapp-viewport-meta.orz</a>)</p></li><li><p>content 参数：<br>  width viewport 宽度(数值/device-width)<br>  height viewport 高度(数值/device-height)<br>  initial-scale 初始缩放比例<br>  maximum-scale 最大缩放比例<br>  minimum-scale 最小缩放比例<br>  user-scalable 是否允许用户缩放(yes/no)</p></li><li><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width,</span></span></span><br><span class="line"><span class="tag"><span class="string">           height=device-height,</span></span></span><br><span class="line"><span class="tag"><span class="string">           inital-scale=1.0,</span></span></span><br><span class="line"><span class="tag"><span class="string">           maximum-scale=1.0,</span></span></span><br><span class="line"><span class="tag"><span class="string">           user-scalable=no;"</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="MobileWeb-适配总结"><a href="#MobileWeb-适配总结" class="headerlink" title="MobileWeb 适配总结"></a>MobileWeb 适配总结</h2><p><a href="www.meow.re/original/2015/04/27/screen-adaptation-in-mobileweb/">MobileWeb 适配总结</a></p><ol><li>固定高度，宽度自适应</li><li>flex</li><li>使用rem来</li></ol><h2 id="浅谈移动前端的最佳实践"><a href="#浅谈移动前端的最佳实践" class="headerlink" title="浅谈移动前端的最佳实践"></a>浅谈移动前端的最佳实践</h2><p><a href="http://www.cnblogs.com/yexiaochai/p/4219523.html" target="_blank" rel="noopener">浅谈移动前端的最佳实践</a></p><h3 id="单页or多页："><a href="#单页or多页：" class="headerlink" title="单页or多页："></a>单页or多页：</h3><p>spa也就是我们常常说的web应用程序webapp，被认为是业内的发展趋势，主要有两个优点：</p><ul><li>用户体验好</li><li>可以更好的降低服务器压力<br>但是单页有几个致命的缺点：</li><li>SEO支持不好，往往需要单独写程序处理SEO问题</li><li>webapp本身的内存管理难，Javascript、Css非常容易互相影响</li></ul><h3 id="Jquery-VS-Zepto"><a href="#Jquery-VS-Zepto" class="headerlink" title="Jquery VS Zepto"></a>Jquery VS Zepto</h3><p>主要对比在使用场景：jQuery体积大，兼容性好，Zepto体积小，兼容性不够，适用于移动端</p><h3 id="MVC框架选择"><a href="#MVC框架选择" class="headerlink" title="MVC框架选择"></a>MVC框架选择</h3><p>总结一句：不建议直接将业务库框架直接取来使用，更不建议使用过重的业务框架，最好是能明白框架想要解决的问题，与自己项目的实际需求，自己造轮子知根知底。</p><h3 id="框架建议"><a href="#框架建议" class="headerlink" title="框架建议"></a>框架建议</h3><ul><li>第三方库（基础库）：<br>requireJS+Zepto+阉割版underscore（将其中不太用到的方法去掉，主要使用模板引擎一块）+ Fastclick</li><li>MVC库/UI库：<br>建议自己写，不要太臃肿，可以抄袭，可以借鉴，不要完全拿来就用<br>这样出来的一套框架比较轻量级，知根知底，不会出现改不动的情况，最后提一句：不经过调研，没有实际场景在框架中玩模式，玩高级理念死得快，不要为技术而技术。</li></ul><h3 id="性能，网站是如何变慢的？"><a href="#性能，网站是如何变慢的？" class="headerlink" title="性能，网站是如何变慢的？"></a>性能，网站是如何变慢的？</h3><ul><li>尺寸——慢的根源<br>  所以，尺寸变大的主要原因是因为冗余代码的产生，如何消除冗余代码是一个重点，也是一个难点。</li><li>版本轮替——哪些能删的痛点<br>  业务团队不要依赖于框架的任何dom结构与css样式，特别不要将UI组件中的dom结构与样式单独抠出来使用，否则就准备肥皂吧</li></ul><p>网络请求，请求是前端优化的生命，优化到最后，优化到极致，都会在请求数、请求量上做文章，常用并且实用的手段有：</p><h4 id="CSS冗余的解决方案"><a href="#CSS冗余的解决方案" class="headerlink" title="CSS冗余的解决方案"></a>CSS冗余的解决方案</h4><ul><li>CSS Sprites：CSS Sprites可以有效的减低请求数，偶尔还可以降低请求量，但是随着发展，可能会有以下问题：<ul><li>新增难</li><li>删除难</li><li>调整难</li><li>响应式</li></ul></li></ul><h4 id="快的假象"><a href="#快的假象" class="headerlink" title="快的假象"></a>快的假象</h4><ol><li>lazyload：<br> 我们常说的延迟加载是图片延迟加载，其实非图片也可延迟加载，看实际需求即可。<ul><li>为img标签src设置统一的图片链接，而将真实链接地址装在自定义属性中。</li><li>所以开始时候图片是不会加载的，我们将满足条件的图片的src重置为自定义属性便可实现延迟加载功能</li></ul></li><li>fake页面：<br> 一个静态HTML页面，装载首屏的基本内容，让首页快速显示，然后js加载结束后会马上重新渲染整个页面，这个样子，用户就可以很快的看到页面响应，给用户一个快的错觉</li><li>预加载：<br> 这里的预加载是在浏览器空闲的时候加载后续页面所需资源，是一种浪费用户流量的行为，属于以空间换时间的做法，实施难度也比较高。预加载的前提是不影响主程序的情况下偷偷的加载，也就是在浏览器空闲的时候加载，但是浏览器空闲似乎变得不可控制</li></ol><h4 id="合并脚本js文件"><a href="#合并脚本js文件" class="headerlink" title="合并脚本js文件"></a>合并脚本js文件</h4><ol><li>为什么要降低请求数？<br> 每次http请求都会带上一些额外信息，会导致其它开销，比如域名解析、开启连接、发送请求等操作，上述spirit也因此产生。</li><li>浏览器并发数<br> chrome在请求资源下会有所限制，移动端的限制普遍在6个左右，这个时候在并发数被占满时，你的ajax便会被搁置，这在webapp中情况更加常见，所以网络限制的情况下请求数控制是必要的，而且可以降低服务器端的压力。</li></ol><h4 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h4><p>工作中实际使用的离线缓存有localstorage与Application cache，这两个皆是好东西，一个常用于ajax请求缓存，一个常用于静态资源缓存。</p><h3 id="移动革命——Hybrid"><a href="#移动革命——Hybrid" class="headerlink" title="移动革命——Hybrid"></a>移动革命——Hybrid</h3><ul><li>拒绝native UI</li><li>交互模型 <a href="http://images.cnitblog.com/blog/294743/201501/201903092504221.png" target="_blank" rel="noopener">http://images.cnitblog.com/blog/294743/201501/201903092504221.png</a></li><li>Hybrid的调试</li><li>多webview</li></ul><h3 id="不恰当的需求"><a href="#不恰当的需求" class="headerlink" title="不恰当的需求"></a>不恰当的需求</h3><ul><li>唤醒app</li><li>回退关闭弹出层</li><li>全站IScroll化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动WEB开发入门&quot;&gt;&lt;a href=&quot;#移动WEB开发入门&quot; class=&quot;headerlink&quot; title=&quot;移动WEB开发入门&quot;&gt;&lt;/a&gt;移动WEB开发入门&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://junmer.github.io/mobile-d
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
      <category term="web app" scheme="http://archmee.github.io/tags/web-app/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：总结 this、闭包、作用域作用域链、原型和原型链</title>
    <link href="http://archmee.github.io/201703/2017-02-06-2.html"/>
    <id>http://archmee.github.io/201703/2017-02-06-2.html</id>
    <published>2017-03-02T16:00:00.000Z</published>
    <updated>2019-08-15T05:20:20.726Z</updated>
    
    <content type="html"><![CDATA[<p>其实这篇总结问应该是在任务三的开始部分就完成的，但我一开始就投入了代码的怀抱，迟迟不肯动手，直到在任务三完成之后，并且在摸索任务四的时候才每天留了点时间将其完成。</p><hr><p>这几个js中的难点几乎每天都会准时出现在各大技术网站上，这让人不得不冲动自己也来总结一番，趁还没忘记最近看的一堆参考资料。<br>我试图用最简洁的方式交一份满意的答卷。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this在大多数OO语言中都是指当前对象引用，而在js中，却有几种不同的表现：<br>《js语言精粹》中明确指出this的值取决于调用的模式，js中一共有4中调用模式：</p><ol><li><strong>方法调用模式</strong>，一个函数作为对象的方法被调用时，this被绑定到该对象</li><li><strong>函数调用模式</strong>，一个普通函数(非方法)被调用时，this绑定到全局对象，浏览器中即window</li><li><strong>构造器调用模式</strong>，在一个函数前带上new关键字来调用，内部会创建一个连接到该函数原型的新对象，同时this被绑定到那个新对象上</li><li><strong>apply调用模式</strong>，js提供了apply和call两个方法来更改this的绑定对象</li></ol><p>最常见的困惑是一个对象方法返回一个函数，其实这个时候的函数已经属于全局对象了，所以执行返回的函数中的this指向全局对象。<br>在给DOM绑定事件时候的this时也容易让人困惑，可以从鸟哥的 <a href="www.laruence.com/2009/09/08/1076.html">深入理解Javascript之this关键字</a> 文中寻找答案。</p><p><strong>注意事项：</strong></p><ul><li>this始终指向此时<strong>函数/方法调用者</strong>，而不是在定义函数/方法时指向的对象。</li><li>this是<strong>执行上下文环境</strong>的一个属性，而不是某个变量对象/活动对象的属性。<br>这个特点很重要，因为和变量不同，this是没有一个类似搜寻变量的过程。当你在代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决于进入上下文时的情况。</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是什么呢？见名知意，即一个封闭的环境，即使用专业术语描述也相差无几。<br>闭包的作用是用来保存函数的执行上下文方便以后使用。<br>常见的闭包使用如 IIFE（立即执行表达式）、函数的柯里化，模块模式。<br>那么闭包在哪呢，通常闭包的形成都是在一个函数中返回一个函数的时候，由于返回的函数往往引用了父函数的上下文环境，导致父函数执行完成后内存没有得到回收/释放（引用计数机制），所以在返回的函数中可以访问父函数的上下文环境。这就形成了闭包。<br>上一个简单的示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        count += n;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(); </span><br><span class="line">sum(<span class="number">5</span>); <span class="comment">//5</span></span><br><span class="line">sum(<span class="number">2</span>); <span class="comment">//7</span></span><br></pre></td></tr></table></figure></p><p>示例中在父函数初始化了count变量，返回的函数中引用了count，sum保存了返回函数，在以后调用sum的过程中，count会始终存在并保存上次调用后的值，那么count存放在哪里的呢，它就是被存放在了返回的函数形成的闭包中（上下文环境）。关于是如何在返回的函数中执行的时候找到count变量的过程，那么就涉及到接下来要讲的作用域和作用域链了。</p><p><strong>注意事项：</strong></p><ul><li>由于每个标准函数在创建时候保存了[[Scope]]，所以理论上来讲，ECMAScript中的_所有函数都是闭包。<br>闭包是一个代码块（在ECMAScript中是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。</li></ul><h2 id="作用域作用域链"><a href="#作用域作用域链" class="headerlink" title="作用域作用域链"></a>作用域作用域链</h2><p>作用域是？<br>简单的说，作用域就是变量与函数的可访问范围，即作用域控制着标识符(变量/函数/形参等等)的可见性和生命周期。在JavaScript中，标识符的作用域只有全局作用域和函数作用域两种。没有用var声明的都属于全局作用域，if/for/while等语句块没有内部作用域，在其中声明的变量将属于当前函数的作用域。</p><p>那么作用域链是什么呢？<br>在定义函数的时候该函数内部会有一个[[scope]]属性，它指向定义该函数的函数的作用域链，这个链的底端是全局对象，顶端是当前活动对象。<br>作用域链的形成是从函数调用开始的，首先在全局环境中，当前活动对象就是GO，当执行一个函数的时候，会为该函数创建一个执行上下文(excution context)，在执行上下文中有初始化后的this，活动对象AO、变量对象VO等属性，然后将活动对象加入到作用域链顶端，加入的过程可能是在[[scope chain]]中加入，也可能是直接链接到<code>__parent__</code>。因为我看过的资料关于这个链的实现的描述大概分两种：</p><ul><li>js高程是一种类似数组的方式并且按函数调用栈的顺序保存其“作用域”的引用，<a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html" target="_blank" rel="noopener">如图</a><br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2011090414454524_scope_chain.jpg" alt="scope_chain实现"></li><li>其他资料也有描述的是一个<code>__parent__</code>的内部属性来维护“父作用域”的引用，<a href="http://www.nowamagic.net/librarys/veda/detail/1645" target="_blank" rel="noopener">比如下图</a><br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2012_03_21_09_parent_scope.png" alt="parent实现"></li></ul><p>虽然两种方式都可行，但是参照js原型链的实现方式，可能第二种方法更靠谱，复杂度为O(n)。因为如果按照第一种方式，每次都要拷贝父作用域的作用域链很麻烦，而且耗费内存，复杂度估计O(2n)。</p><p>作用域链的用途是什么呢，用来遍历查找标识符，闭包就是利用这点实现的。<br>查找一个标识符的顺序是：从作用域链的顶端，也就是自身的活动对象开始，如果存在则返回，如果不存在将继续搜索父函数的活动对象，依次查找，直到找到为止。如果整个作用域链上都无法找到（到全局对象结束），则返回undefined。</p><p><strong>注意事项：</strong></p><ul><li>js中的函数运行在他们被定义的作用域，而不是被执行时候的作用域</li><li>从作用域链的结构可以看出，在执行上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于执行上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。</li><li>在代码执行过程中，作用域链可以通过使用with语句和catch从句对象来扩充（它们的对象参数将会被作为活动对象加入到作用域链顶端）。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。这个事实导致作用域链查找变为<em>两个维度</em>：<ol><li>先查找作用域链上的当前节点对象（活动）</li><li>然后查找该对象的原型链（如果有），一直查找到原型链顶端，遍历作用域链，重复1,2步</li></ol></li></ul><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>首先需要搞清楚的问题是：当我们谈论原型时，我们到底在谈什么？</p><ol><li>每个函数都有一个<code>prototype</code>属性，它指向一个对象，该对象就是在当该函数用作构造函数创建对象实例时，作为其对象实例的原型。通过该函数构造的所有对象共享该原型中的方法和属性。函数是一个对象，它有自己的原型但不是<code>prototype</code>。</li><li>每个对象都有一个原型，根据浏览器不同一般表示为<code>[[Prototype]]</code>或者<code>__proto__</code>(好像已被最新标准实现)，这才是我们真正谈论的原型，它从哪里来呢，就是我们在第一点提到的构造函数的那个<code>prototype</code>属性。</li></ol><p>那么原型链是什么，用来干什么？<br>所有对象都有一个原型，而每个原型又有自己的一个原型，就样形成了原型链，原型链的顶端是[[object prototype]]，该原型对象的的原型为null，就是原型链的终点。<br>当查找一个对象的属性时，js会从对象自己开始，然后从对象原型开始向上遍历原型链，直到找到指定属性为止，但如果直到原型链终点都仍然没有找到指定的属性，就会返回undefined。<br>下面看一张图总结原型原型链，是鸟哥<a href="http://www.laruence.com/2010/05/13/1462.html" target="_blank" rel="noopener">文章中提到的一张图</a>，被我改进了一下，不过相交的地方不太好，有空重构一下。<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/20170310_prototype.jpg" alt="prototype"></p><p><strong>注意事项</strong><br>如果在对象实例中重写了原型链上的方法或属性，那么该实例中的方法或属性会屏蔽原型链中的同名方法或属性，如果想要访问原型链上的同名方法或属性，只能通过delete删除在该实例上定义的同名方法或属性。</p><p>最后，我总结了一条关于原型原型链和作用域作用域链的明显区别：<br>原型原型链是用于在对象中查找属性和方法等标识符，作用域作用域链是用于查找变量和函数等标识符。</p><hr><p>若有错误，望不吝指正。<br>参考资料请见上一篇学习摘录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实这篇总结问应该是在任务三的开始部分就完成的，但我一开始就投入了代码的怀抱，迟迟不肯动手，直到在任务三完成之后，并且在摸索任务四的时候才每天留了点时间将其完成。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这几个js中的难点几乎每天都会准时出现在各大技术网站上，这让人不得不冲动自己也来总结一
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：原生JS实现单页GTD应用</title>
    <link href="http://archmee.github.io/201702/2017-02-27.html"/>
    <id>http://archmee.github.io/201702/2017-02-27.html</id>
    <published>2017-02-24T16:00:00.000Z</published>
    <updated>2019-08-15T05:19:35.236Z</updated>
    
    <content type="html"><![CDATA[<p>从时间跨度上来说，几乎是两个月的时间，因为是在过年期间，所以会精力比较分散。<br>在1月下旬就完成了界面布局的工作，但是一直在思考尝试如何组织代码结构和数据结构。虽然说说网上有这方面的文章和书籍，但是我认为最开始还是要脱离别人的思维限制，先自己尝试更好，锻炼了自己的架构和思考能力，也会更清楚在无从下手到从0开发一个完整的项目的流程和遇到的问题，等完成后再对比成熟的方案也不失为一个好方案。在多次思考分析利弊之后，整个todo应用数据存储有了一个比较理想的方案，当然，数据都是存储在localStorage中，而整个软件采用模块模式来开发，但是被我分成了几个小模块。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块模式可以避免全局变量污染，并且可以很好的解耦。可能是我对模式的理解有偏差，我理想中应该是这样的架构，如下图，要涉及到发布/订阅模式以及MVC，但是不知道是否合适，因为js事件从本质来说就是发布/订阅模式（也可以说观察者）模式。毕竟是第一次实践设计模式的知识，只有慢慢试探了。<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/20170310_jiagou1.jpg" alt></p><p>但是我最终完成的架构却是这样的，整个app分为4个模块，分类列表主要负责分类的列表数据和模板，todo列表负责分类的数据和模板，todo详情部分负责单条todo的详情和展示模板等，一个app部分负责协调上述几个部分的工作。这并不是很好的设计，最主要的问题是其中的模板对数据的依赖导致耦合严重，在后面的重构过程中将改变整个软件架构。<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/20170310_jiagou2.jpg" alt></p><p>该应用的代码架构：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分类</span></span><br><span class="line">categoryModule =  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//操作 model &amp; template</span></span><br><span class="line">   <span class="comment">//返回接口</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//todo列表</span></span><br><span class="line">todoModule =  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//操作 model &amp; template</span></span><br><span class="line">   <span class="comment">//返回接口</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//todo详情</span></span><br><span class="line">todoDetail = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//操作 model &amp; template</span></span><br><span class="line">   <span class="comment">//返回接口</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//app controller</span></span><br><span class="line">appModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//code</span></span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//初始化分类列表</span></span><br><span class="line">        <span class="comment">//初始化todo列表</span></span><br><span class="line">        <span class="comment">//初始化todo详情界面</span></span><br><span class="line">        <span class="comment">//初始化事件绑定</span></span><br><span class="line">        <span class="comment">//等待用户交互触发事件并分发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><ul><li>所有分类数据汇总存储到一个对象，每个分类就是该对象中一个用id作为键值的对象，这样做是为了方便按id索引单条分类数据，每条分类数据都是独立的，没有嵌套关系。</li><li>整个对象中有一个在程序初始化时创建的分类对象作为顶级分类用于保存一级二级以及更多子分类，类似于DOM中的根节点。</li><li>每个分类对象保存了父分类id和子分类id映射表和，熟悉DOM的同学一下就能get到这是借鉴了DOM的思想，不同的是这里不是保存引用。</li><li>每个分类也保存了该分类下的todo列表映射，添加删除todo时要维护此表。</li><li>todo数据是按照id单独存放的，也就是说，要获取todo，知道它的id后直接从localStorage中取出来，这样做也是因为方便对单条todo进行操作。</li></ul><p>以下是具体数据结构：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分类列表</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"cid_1"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"cid_2"</span>: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单条分类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"addTime"</span>:<span class="number">1487710962417</span>, <span class="comment">//添加时间</span></span><br><span class="line">    <span class="string">"cid"</span>:<span class="string">"cid_1487710962417"</span>, <span class="comment">//分类id</span></span><br><span class="line">    <span class="string">"pid"</span>:<span class="string">"cid_0000000000001"</span>, <span class="comment">//父分类id</span></span><br><span class="line">    <span class="string">"title"</span>:<span class="string">"未命名分类1"</span>, <span class="comment">//分类名</span></span><br><span class="line">    <span class="string">"childCatList"</span>:[ <span class="comment">//保存直接子分类</span></span><br><span class="line">        <span class="string">"cid_1487883840564"</span>,</span><br><span class="line">        <span class="string">"cid_1487980933649"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"childTodoList"</span>:[ <span class="comment">//保存直接子todo</span></span><br><span class="line">        <span class="string">"tid_1487776376694"</span>,</span><br><span class="line">        <span class="string">"tid_1487776391312"</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单条todo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"addTime"</span>:<span class="number">1487776376694</span>, <span class="comment">//添加时间</span></span><br><span class="line">    <span class="string">"tid"</span>:<span class="string">"tid_1487776376694"</span>, <span class="comment">//todo id</span></span><br><span class="line">    <span class="string">"cid"</span>:<span class="string">"cid_1487710962417"</span>, <span class="comment">//分类id</span></span><br><span class="line">    <span class="string">"emergency"</span>:<span class="number">0</span>, <span class="comment">//紧急程度，暂时没用上</span></span><br><span class="line">    <span class="string">"title"</span>:<span class="string">"未命名任务"</span>, <span class="comment">//todo标题</span></span><br><span class="line">    <span class="string">"content"</span>:<span class="string">"出门交电费"</span>, <span class="comment">//todo内容</span></span><br><span class="line">    <span class="string">"status"</span>:<span class="number">1</span>, <span class="comment">//状态1和-1</span></span><br><span class="line">    <span class="string">"expireTime"</span>:<span class="number">1487721600000</span> <span class="comment">//失效时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>在2月25号完成了该任务，翻看了一下IFE2015 task3的初级班和中级班的提交列表，发现自己实现得算是非常好的了，不过也花了好长时间。下面上图：<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2017-02-25_090953.png" alt></p><p>遇到的问题：</p><ul><li>高度自适应布局，最开始我使用了float来布局，但是高度不能自适应<br>解决：最后在网上找到了高度自适应布局方案，使用了绝对定位技术，设置top和bottom为0或者你需要撑开的上下间隔即可。</li><li>分类列表和todo列表设置了overflow:scroll，但是不管内容有没有超出滚动条都始终显示在那里很碍眼。<br>  解决：设置overflow为auto而不是scroll</li><li>待解决：如何架构这个程序？</li></ul><p>接下来的计划就是看完《设计模式》剩下的几章，以及刷一遍CSS3，ES6，然后开始学习React或者Vue就找工作了。</p><blockquote><p>这篇文章不是一笔写成，而是在完成任务三的过程中多次更新，所以不以发布时间为准。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从时间跨度上来说，几乎是两个月的时间，因为是在过年期间，所以会精力比较分散。&lt;br&gt;在1月下旬就完成了界面布局的工作，但是一直在思考尝试如何组织代码结构和数据结构。虽然说说网上有这方面的文章和书籍，但是我认为最开始还是要脱离别人的思维限制，先自己尝试更好，锻炼了自己的架构和
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：学习笔记和资料</title>
    <link href="http://archmee.github.io/201702/2017-02-06-1.html"/>
    <id>http://archmee.github.io/201702/2017-02-06-1.html</id>
    <published>2017-01-31T16:00:00.000Z</published>
    <updated>2019-08-15T05:27:37.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul><li>理解一个函数的原型属性(function’s prototype property )其实和实际的原型(prototype)没有关系对我们来说至关重要。</li><li>A prototype chain is a finite chain of objects which is used to implemented inheritance and shared properties.（原型链是一个用于实现继承和共享属性的有限对象链）</li><li>还有一点我们需要注意的是，我们可以赋值任何类型的对象到原型上，但是不能赋值原子类型的值，比如如下代码是无效的：<code>Cat.Prototype = 5;</code></li><li>原型原型链是用于对象标识符查找（属性和方法），而作用域作用域链是用于普通标识符的查找（变量和函数）</li></ul><h2 id="作用域、作用域链、闭包"><a href="#作用域、作用域链、闭包" class="headerlink" title="作用域、作用域链、闭包"></a>作用域、作用域链、闭包</h2><ul><li>当在函数中访问一个变量的时候，搜索顺序是先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索父函数的活动对象，依次查找，直到找到为止。如果整个作用域链上都无法找到，则返回undefined。</li><li><p>如果函数存在Prototype原型对象，则在查找完自身的活动对象后再查找自身的原型对象，这就是Javascript中的变量查找机制。（<strong>经如下代码证明这一点是错误的</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(i); <span class="comment">//0</span></span><br><span class="line">        alert(y); <span class="comment">//error</span></span><br><span class="line">        alert(x); <span class="comment">//error</span></span><br><span class="line">    &#125;;</span><br><span class="line">    b.prototype.y=<span class="string">'y=5'</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.x=<span class="string">'x=10'</span>;</span><br><span class="line"><span class="keyword">var</span> c=a();</span><br><span class="line">c();</span><br></pre></td></tr></table></figure></li><li><p>在代码执行过程中，作用域链可以通过使用with语句和catch从句对象来增强（将它们的对象参数作为活动对象加入到作用域链顶端）。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。这个事实导致作用域链查找变为<em>两个维度</em>：</p><ol><li>首先是查找作用域链上的活动对象</li><li>然后在每个作用域链上的活动对象上查找该对象的原型链（如果有原型）</li></ol></li><li><p>注意，由于_每个<em>（标准的）函数都在创建的时候保存了[[Scope]]，所以理论上来讲，ECMAScript中的</em>所有函数_都是_闭包_。<br>闭包是一个代码块（在ECMAScript是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。</p></li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li>this始终指向此时函数/方法调用者，而不是在定义函数/方法时指向的对象。</li><li><p>任何对象都可以作为上下文的this值。我想再次澄清对与ECMAScript中，与执行上下文相关的一些描述——特别是this的误解。通常，this 被错误地描述为变量对象（活动对象）的属性。 请牢记：</p><blockquote><p>this是执行上下文环境的一个属性，而不是某个变量对象/活动对象的属性<br>  这个特点很重要，因为和变量不同，this是没有一个类似搜寻变量的过程。当你在代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决于进入上下文时的情况。</p></blockquote></li><li><p>注意this这个值在一个继承机制中，是指向它的当前对象，而不是从原型链上找到它时所属于的对象。</p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>有一种叫作冒充继承的方式代码如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = Animal.prototype;</span><br></pre></td></tr></table></figure><p>这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。<br>为了解决这个问题，后来增加了一个在中间桥接的空白对象。<br>比如下面这个extend函数，就是YUI库如何实现继承的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">　　　　F.prototype = Parent.prototype;</span><br><span class="line">　　　　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">　　　　Child.prototype.constructor = Child;</span><br><span class="line">　　　　Child.uber = Parent.prototype;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的 hasOwnProperty 函数来获取正确的结果<br>// 使用{}对象的 hasOwnProperty<br><code>{}.hasOwnProperty.call()</code> </p></li><li><p>在使用第三方JS类库的时候，往往有时候他们定义的原型方法是不能满足我们的需要，但是又离不开这个类库，所以这时候我们就需要重写他们的原型中的一个或者多个属性或function，我们可以通过声明的同样的名称（标识符）的形式来达到覆盖重写的功能</p></li><li><p>在浏览器中setTimeout、setInterval和匿名函数执行时的this是全局对象window</p></li><li><p>apply用于改变函数执行时的当前对象，当无参数时，当前对象为window，有参数时当前对象为该参数。</p></li><li><p>激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被称为被调用者(callee) 。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。</p></li></ul><h2 id="深入理解作用域"><a href="#深入理解作用域" class="headerlink" title="深入理解作用域"></a>深入理解作用域</h2><p>来自 <a href="http://www.laruence.com/2009/05/28/863.html" target="_blank" rel="noopener">Javascript作用域原理：</a></p><ul><li>在JS中“一切皆是对象, 函数也是”</li><li>在对应作用域内，函数定义会提升，但函数表达式没有提升</li><li>JS权威指南中有一句很精辟的描述：“JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里”</li><li>ECMA262中所述作用域的实现：<ol><li>任何执行上下文时刻的作用域, 都是由作用域链(scope chain)来实现</li><li>在一个函数被定义的时候, 会将该函数的<code>[[scope]]</code>属性指向它此时的作用域链(scope chain)</li><li>在一个函数被调用的时候，会创建一个活动对象，然后在活动对象中加入<code>this</code>和<code>arguments</code>属性，对于每一个函数的形参和变量，都命名为该活动对象的命名属性, 然后将这个活动对象加入到此时的作用域链的最前端</li></ol></li><li>在调用函数执行之前, 会首先创建一个活动对象, 然后搜寻这个函数中的形参、局部变量定义和函数定义, 将它们作为这个活动对象的同名属性, 对于形参则直接赋值，对于局部变量定义，变量的值会在真正执行的时候才计算，此时只是简单的赋为<code>undefined</code>。</li><li>JS作为一门解释执行的语言其实是有预编译的过程的, JS在执行每一段代码之前, 都会首先处理<code>var</code>关键字和<code>function</code>定义式(函数定义式和函数表达式)。</li><li>JS的预编译是以段为处理单元的… 而段是按<code>script</code>标记来分的，所以一个script就是一个处理单元。　</li></ul><p>来自 <a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html" target="_blank" rel="noopener">理解 JavaScript 作用域和作用域链</a></p><ul><li>函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JS引擎访问的内部属性。其中一个内部属性是<code>[[Scope]]</code>，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</li><li><p>在定义函数时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图所示（注意：图片只例举了全部变量中的一部分）：<br><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414435366.jpg" alt></p></li><li><p>执行此函数时会创建一个称为“运行时上下文(execution context)”的内部对象，运行时上下文定义了函数执行时的环境。每个运行时上下文都有自己的作用域链，用于标识符解析，当运行时上下文被创建时，它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。<br>而形参和变量按照它们出现在函数中的顺序被复制到运行时上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、<code>arguments</code>以及<code>this</code>，然后此对象会被加入到作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示：<br><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414444843.jpg" alt></p></li><li><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。</p></li><li>函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被<code>with</code>语句和<code>catch</code>语句影响。<br>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着该函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。如下图所示：<br><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414454524.jpg" alt><br>当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域链的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中，此时的作用域链图和上图类似。<br>因此在程序中应避免使用with语句，由于try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免，可通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>学习时，发现部分链接已经无效，并且自己补充了一些。</p><p>js基础：<br><a href="http://weizhifeng.net/javascript-the-core.html" target="_blank" rel="noopener">http://weizhifeng.net/javascript-the-core.html</a><br><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank" rel="noopener">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1643" target="_blank" rel="noopener">http://www.nowamagic.net/librarys/veda/detail/1643</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1644" target="_blank" rel="noopener">http://www.nowamagic.net/librarys/veda/detail/1644</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1645" target="_blank" rel="noopener">http://www.nowamagic.net/librarys/veda/detail/1645</a></p><p>面向对象：<br><a href="http://www.ruanyifeng.com/blog/2010/05/object-ooriented_javascript_encapsulation.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/05/object-ooriented_javascript_encapsulation.html</a><br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html</a><br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1642" target="_blank" rel="noopener">http://www.nowamagic.net/librarys/veda/detail/1642</a><br><a href="http://www.cnblogs.com/fool/archive/2010/10/16/1853126.html" target="_blank" rel="noopener">http://www.cnblogs.com/fool/archive/2010/10/16/1853126.html</a><br><a href="http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html" target="_blank" rel="noopener">http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html</a></p><p>this：<br><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html</a><br><a href="http://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/index.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/index.html</a><br><a href="http://www.cnblogs.com/justany/archive/2012/11/01/the_keyword_this_in_javascript.html" target="_blank" rel="noopener">http://www.cnblogs.com/justany/archive/2012/11/01/the_keyword_this_in_javascript.html</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1647" target="_blank" rel="noopener">http://www.nowamagic.net/librarys/veda/detail/1647</a></p><p>原型：<br><a href="http://blog.jobbole.com/9648/" target="_blank" rel="noopener">http://blog.jobbole.com/9648/</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1641" target="_blank" rel="noopener">http://www.nowamagic.net/librarys/veda/detail/1641</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1648" target="_blank" rel="noopener">http://www.nowamagic.net/librarys/veda/detail/1648</a><br><a href="http://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangfupeng1988/p/3977924.html</a></p><p>闭包：<br><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a><br><a href="http://www.cnblogs.com/rubylouvre/archive/2009/07/24/1530074.html" target="_blank" rel="noopener">http://www.cnblogs.com/rubylouvre/archive/2009/07/24/1530074.html</a><br><a href="http://coolshell.cn/articles/6731.html" target="_blank" rel="noopener">http://coolshell.cn/articles/6731.html</a><br><a href="http://kb.cnblogs.com/page/105708/" target="_blank" rel="noopener">http://kb.cnblogs.com/page/105708/</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1646" target="_blank" rel="noopener">http://www.nowamagic.net/librarys/veda/detail/1646</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;理解一个函数的原型属性(function’s prototype property )其实和实际的原型(prototype)没有
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：完结《Head First HTML5》</title>
    <link href="http://archmee.github.io/201701/2017-01-08.html"/>
    <id>http://archmee.github.io/201701/2017-01-08.html</id>
    <published>2017-01-07T16:00:00.000Z</published>
    <updated>2019-08-15T05:28:19.538Z</updated>
    
    <content type="html"><![CDATA[<p>这10天看完了《Head First HTML5》和IFE2015春Task3的参考资料，对this、闭包、作用域和作用域链、原型和原型链都有了更深的理解，但是自己的总结还没写，估计下一篇博客内容就是总结js中这几个非常核心的知识点，脑海中已经有了大概的雏形，希望尽量简洁，一针见血掐中要害。</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>《Head First HTML5》在一年多以前看过一遍，当时在没有系统学习js基础的情况下看完了，但在现在看来当时并没有完全看懂，但至少h5的关键技术都知道了，想来和前面4章讲了js的基础还是有很大关系的，其实我更希望省略掉前面4章，因为毕竟作为想学习h5的人来说应该已经通过其他书籍对js有了系统的学习，所以这4章对js的入门讲解就显得很鸡肋，因为对没学过js的人通过这4章根本学不会js，已经学会js的又不需要，所以这4章只是徒增了这本书的厚度，导致读起来非常不爽快，而且违背了该书的“节约纸张”的基本信条（因为该书到处都在提醒读者他们为了节约纸张省略了部分代码）。但是后面6章还是真的深入浅出的讲解了h5的几个关键技术：</p><ul><li>5.地理定位</li><li>6.JSONP跨域（这个不属于h5）</li><li>7.Canvas画布</li><li>8.Video</li><li>9.本地存储localStorage</li><li>10.Web多线程（Worker）</li></ul><h2 id="IFE2015-Task3"><a href="#IFE2015-Task3" class="headerlink" title="IFE2015 Task3"></a>IFE2015 Task3</h2><p>在<a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0003" target="_blank" rel="noopener">IFE2015 Task3</a> 页面提供了很多深入学习js的参考资料，我看了大部分，除了《Eloquent JavaScript》和javascript设计模式相关的内容，因为我的案头边就有一本正在看的《JavaScript设计模式》，而且设计模式这个内容不是看看书就能学好的，而是要通过大量代码实践才能学习其精华，所以目前只需要了解即可。</p><ul><li>看完学习资料摘录片段也总结成了一篇博客</li><li>和一篇学习笔记总结有关this、闭包、作用域作用域链、原型和原型链</li></ul><h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>下一步主要有下面几件事</p><ul><li>总结前面提到的javascript中关于this、闭包、作用域作用域链、原型和原型链的学习笔记</li><li>完成IFE2015 Task3的TODO应用</li><li>以及更多还没学习的东西如编码规范、响应式布局、CSS3、Less、Sass、PostCSS、BootStrap、ES6、webpack或gulp、JQ、移动端、SPA、NodeJS、Vue和React至少要学习一个</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这10天看完了《Head First HTML5》和IFE2015春Task3的参考资料，对this、闭包、作用域和作用域链、原型和原型链都有了更深的理解，但是自己的总结还没写，估计下一篇博客内容就是总结js中这几个非常核心的知识点，脑海中已经有了大概的雏形，希望尽量简洁，
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：手风琴效果和菜单</title>
    <link href="http://archmee.github.io/201612/2016-12-27.html"/>
    <id>http://archmee.github.io/201612/2016-12-27.html</id>
    <published>2016-12-25T16:00:00.000Z</published>
    <updated>2019-08-15T05:30:08.040Z</updated>
    
    <content type="html"><![CDATA[<p>这十几天做的事情很少，很少看书，都在写代码，但是代码也写得很少，最开始只是单纯想写一个手风琴图片效果，但是找到一个手风琴的菜单，也想尝试一下，就同时设计写了几个菜单效果，但在实现的时候，可能是在大半夜思路不清晰的原因，导致写的代码混乱，对事件的处理也很混乱，在终于完成了几个效果后，几天前开始了重构，一下子就思路清晰了很多，代码实现思路也更简单，省去了些代码行数，今天在终于实现了手风琴图盘效果后，才想起最近的总结还没完成。</p><p>中间还看了IFE2015 task3的几篇关于作用域链和原型链的文章，除了理解作用域链和原型链外，还对其他几方面诸如闭包/this理解都更加清晰了。</p><p>今晚上对move.js（个人在完善的一个动画函数）进行了更新，加入了对 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a> 的支持，这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需求。这样就可以将原来使用setTimeout的动画作为一种降级方案，当然只有比较新的浏览器才支持这个API，所以我是用了<a href="https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="noopener">这篇文章: requestAnimationFrame for Smart Animating</a>中提到的Erik Möller提供的Polyfill<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x) &#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame =</span><br><span class="line">          <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelAnimationFrame'</span>] || <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">window</span>.requestAnimationFrame)</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime));</span><br><span class="line">            <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; callback(currTime + timeToCall); &#125;,</span><br><span class="line">              timeToCall);</span><br><span class="line">            lastTime = currTime + timeToCall;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">window</span>.cancelAnimationFrame)</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            clearTimeout(id);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>上文提到的几个效果：</p><ol><li><p><a href="https://github.com/Archmee/Front-End-Demo/tree/master/fancy/dropdown-menu" target="_blank" rel="noopener">几个菜单</a><br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/dropmenu.jpg" alt></p></li><li><p><a href="https://github.com/Archmee/Front-End-Demo/blob/master/fancy/shoufengqin.html" target="_blank" rel="noopener">手风琴图片</a>（图片来自C&amp;A官网，侵删）<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/shoufengqin.jpg" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这十几天做的事情很少，很少看书，都在写代码，但是代码也写得很少，最开始只是单纯想写一个手风琴图片效果，但是找到一个手风琴的菜单，也想尝试一下，就同时设计写了几个菜单效果，但在实现的时候，可能是在大半夜思路不清晰的原因，导致写的代码混乱，对事件的处理也很混乱，在终于完成了几个
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：《Javascript 语言精粹》学习笔记</title>
    <link href="http://archmee.github.io/201612/2016-12-12.html"/>
    <id>http://archmee.github.io/201612/2016-12-12.html</id>
    <published>2016-12-11T16:00:00.000Z</published>
    <updated>2019-08-15T05:31:08.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript语言精粹简要笔记"><a href="#javascript语言精粹简要笔记" class="headerlink" title="javascript语言精粹简要笔记"></a>javascript语言精粹简要笔记</h1><p>由于个人很喜欢DC这本书的这种开篇方式，所以将其对莎士比亚著作的引用也写进来了，以下如未做特殊说明，引用内容均来自该书。</p><p>##1. 精华</p><blockquote><p>……我不过略有些讨人喜欢的地方而已，怎么会有什么迷人的魔力？</p></blockquote><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h2><blockquote><p>我很熟悉它，早就在文法书上念过了</p></blockquote><p>作者用铁路图（语法图）来表示了js语法中的</p><ul><li>空白，多行注释<code>/**/</code>会和<code>/a*/</code>这样的正则表达式冲突</li><li>标识符，可以以字母、下划线、美元符号开头</li><li>数字，js只有一个数字类型，内部表示为64位浮点数，isNaN可以检测NaN类型</li><li>字符串，字符串一旦创建，就不可变</li><li>语句，js的代码块不会创建新的作用域</li><li>表达式</li><li>字面量</li><li>函数</li></ul><h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3. 对象"></a>3. 对象</h2><blockquote><p>对于丑陋的事物，爱会闭目无视</p></blockquote><ul><li>js对象是可变的键值对集合，属性名可以是包括空字符串在内的任意字符串，属性值可以是除了<code>undefined</code>外的任何值</li><li>每个对象都连接到一个原型对象，所有通过对象字面量创建的对象都连接到<code>Object.prototype</code></li><li>从原型链中检索属性值的过程称为委托</li></ul><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><blockquote><p>所有的过失都在未犯以前，都已定下应处的惩罚</p></blockquote><ul><li>js中函数就是对象</li><li>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数，除了声明时定义的形参，每个函数还接收两个附加参数<code>this</code>和<code>arguments</code></li><li><code>this</code>的值取决于调用的模式，js中一共有4中调用模式：<ul><li><strong>方法调用模式</strong>，一个函数作为对象的属性就是方法，当一个方法被调用时，<code>this</code>被绑定到该对象</li><li><strong>函数调用模式</strong>，一个普通函数(非方法)被调用时，<code>this</code>绑定到全局对象</li><li><strong>构造器调用模式</strong>，在一个函数前带上<code>new</code>关键字来调用，内部会创建一个连接到该函数原型的新对象，同时<code>this</code>被绑定到那个新对象上</li><li><strong>apply调用模式</strong>，js提供了<code>apply</code>和<code>call</code>两个方法来更改<code>this</code>的绑定对象</li></ul></li><li><code>arguments</code>保存了调用时的参数列表，它只是一个‘类数组对象’，除了有一个length属性外，没有任何数组方法</li><li>js允许给语言的基本类型扩充功能</li><li>js只有函数作用域和全局作用域</li><li>可以使用函数和闭包来构建模块，模块模式的一般形式是：一个定义了私有变量和函数的的函数；利用闭包可以创建可以访问私有变量和函数的特权函数；</li></ul><h2 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h2><blockquote><p>……往往会把一件完整的东西化成无数的形象，就像凹凸镜一般，从正面望去，只见一片模糊</p></blockquote><p>本章作者介绍了几种实现继承的方式：</p><ul><li>伪类：用繁琐的模仿其他面向对象语言的方式来实现继承</li><li>原型：也叫差异化继承，通过创建一个父类对象，然后在其基础上添加自定义属性</li><li>函数化：也叫应用模块模式，通过4个步骤来实现<ol><li>创建一个新对象</li><li>有选择的定义私有变量和方法</li><li>给这个新对象扩充方法</li><li>返回那个对象</li></ol></li></ul><h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h2><blockquote><p>你这披着羊皮的狼，我要把你赶走</p></blockquote><ul><li>js数组的length没有上界</li><li>js数组也是对象，js中一切皆对象</li><li>使用数组还是对象？一个简单的规则是：当属性名是小而连续的整数时，使用数组，否则使用对象</li></ul><h2 id="7-正则表达式"><a href="#7-正则表达式" class="headerlink" title="7. 正则表达式"></a>7. 正则表达式</h2><blockquote><p>相反地，选到一个称心如意的配偶，就能百年谐和，幸福无穷</p></blockquote><ul><li>js中会用到正则表达式的方法有：<code>regexp.exec</code>、 <code>regexp.test</code>、<code>string.match</code>、<code>string.replace</code>、 <code>string.split</code>、<code>string.search</code></li><li>正则表达式分组<ul><li>捕获型<code>()</code></li><li>非捕获型<code>(?:)</code></li><li>向前正匹配<code>(?=)</code>（！bad）</li><li>向前负匹配<code>(?!)</code> （！bad）</li></ul></li></ul><h2 id="8-方法"><a href="#8-方法" class="headerlink" title="8. 方法"></a>8. 方法</h2><blockquote><p>他虽疯，但却有他的一套理论</p></blockquote><h2 id="9-代码风格"><a href="#9-代码风格" class="headerlink" title="9. 代码风格"></a>9. 代码风格</h2><blockquote><p>好一串嘟嘟囔囔的头衔！</p></blockquote><p>讲了作者推崇的一些风格，比如缩进4个空格、不允许case语句穿越、唯一全局变量等等</p><h2 id="10-优美的特性"><a href="#10-优美的特性" class="headerlink" title="10. 优美的特性"></a>10. 优美的特性</h2><blockquote><p>我让你的脚玷污我的嘴唇，让你的肖像玷污我的眼睛，让你的每一部分玷污我的心，等候着你的答复</p></blockquote><h2 id="附录A-毒瘤"><a href="#附录A-毒瘤" class="headerlink" title="附录A. 毒瘤"></a>附录A. 毒瘤</h2><blockquote><p>那会在一言一行中证明其可怕</p></blockquote><ul><li>js对全局变量的依赖降低了程序的可靠性</li><li>由于js有函数作用域但是没有块级作用域，所以更好的方式是在每个函数开头部分声明所有变量</li><li>由于js的自动插入分号机制，建议将<code>{</code>放在上一行的结束而不是新行</li><li>Unicode把一对字符视为一个单一字符，js认为一对字符是两个不同的字符</li><li>第二个可选参数是基数，建议总是带上10作为基数</li><li>js没有真正的数组</li><li>js中的众多假值，如下表：</li></ul><table><thead><tr><th>值</th><th>类型</th></tr></thead><tbody><tr><td>0</td><td>Number</td></tr><tr><td>NaN</td><td>Number</td></tr><tr><td>“abc”</td><td>String</td></tr><tr><td>false</td><td>Boolean</td></tr><tr><td>null</td><td>Object</td></tr><tr><td>undefined</td><td>Undefined</td></tr></tbody></table><ul><li>hasOwnProperty可以被重写覆盖</li><li>js中的对象永远不会是真的空对象</li></ul><h2 id="附录B-糟粕"><a href="#附录B-糟粕" class="headerlink" title="附录B. 糟粕"></a>附录B. 糟粕</h2><blockquote><p>现在要请你告诉我，你究竟为了我哪一点坏处而开始爱我起来呢？</p></blockquote><ul><li>使用<code>===</code>和<code>!==</code>来判断是否相等，而不是<code>==</code>和<code>!=</code></li><li>避免使用with，除了不可预料外，它还会阻断变量名的词法作用域绑定</li><li>避免使用eval，由于它需要运行编译器，所以降低了语言的性能，还削弱了程序的安全性，除此之外，也尽量避免Function构造器、setTimeout和setInterval的字符串形式的参数</li><li>移除continue会使性能得到改善</li><li>避免使用switch语句的case条件穿越</li><li>对<code>if</code>,<code>while</code>,<code>do</code>,<code>for</code>总是使用代码块</li><li>将<code>++</code>和<code>--</code>替换为<code>+=</code>和<code>-=</code></li><li>js位运算的多次转换反而会降低位运算带来的性能提高</li><li>使用function表达式而不是语句</li><li>js有一套类型的包装对象，应该尽量避免使用基本类型值的包装对象来创建基本类型</li><li>对于js中的对象，一个更好的策略是不使用new（个人感觉没必要）</li><li>避免使用void</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;javascript语言精粹简要笔记&quot;&gt;&lt;a href=&quot;#javascript语言精粹简要笔记&quot; class=&quot;headerlink&quot; title=&quot;javascript语言精粹简要笔记&quot;&gt;&lt;/a&gt;javascript语言精粹简要笔记&lt;/h1&gt;&lt;p&gt;由于个人很喜
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第： IFE2015 遇到的问题和解决办法</title>
    <link href="http://archmee.github.io/201612/2016-12-11.html"/>
    <id>http://archmee.github.io/201612/2016-12-11.html</id>
    <published>2016-12-11T05:11:00.000Z</published>
    <updated>2019-08-15T05:43:34.130Z</updated>
    
    <content type="html"><![CDATA[<p>在完成任务ife2015任务二中遇到的问题和解决方案：<br><strong>ps</strong>：很多和 <a href="https://github.com/baidu-ife/ife/blob/master/2015_spring/task/task0002/review/IFE-review.md" target="_blank" rel="noopener">ife review</a> 重复的地方不再列出</p><h2 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a>util.js</h2><ul><li>低版本浏览器没有Array.indexOf方法，使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="noopener">MDN的indexOf Polyfill</a></li><li>低版本浏览器没有Object.keys方法，也使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener">MDN的keys Polyfill</a></li><li>遍历对象的时候要使用hasDontEnumerBug和propertyIsEnumerable（已解决：用了MDN提供的object.keys的pollyfill）<br>疑：不是用hasOwnProperty方法可以解决吗???</li><li>获取元素在窗口中的位置除了用offsetParent遍历的方法外还有getBoundingClientRect的方法（已解决，直接调用）</li><li>setCookie调用差8个小时，好像UTC的问题(已解决，不用toUTCString()而用toString，在没找到好的解决方案前暂时这样)</li><li>$方法的改进，比如按照属性值匹配那个没有加tag（已解决），比如是否可以采用更优的从右向左扫描(放弃)</li></ul><h2 id="task0003"><a href="#task0003" class="headerlink" title="task0003"></a>task0003</h2><h3 id="轮播图小点li在在父元素ul中水平居中方法"><a href="#轮播图小点li在在父元素ul中水平居中方法" class="headerlink" title="轮播图小点li在在父元素ul中水平居中方法"></a>轮播图小点li在在父元素ul中水平居中方法</h3><ol><li>父元素text-align:center,子元素要为inline或inline-block</li><li>父元素不用设置，子元素要为block类型，子元素设置margin:0 auto; display:table;</li><li>通过定位，父元素设置相对定位:<ul><li>子元素定宽，然后绝对定位，left和right都为0，margin:0 auto;</li><li>子元素定宽，然后绝对定位，{left:50%; margin-left:-50%;} 问题是通常不确定子元素的宽度</li><li>子元素绝对定位，{left:50%; transform:translateX(-50%);}（ie9不兼容）</li><li>父和子之间需要一层包裹wrap，wrap要设置为绝对定位并left:50%; 然后子元素相对定位, 然后left:-50%（注意是负值）（未验证！！！）</li></ul></li><li>父元素用flex显示，个人还没学过，暂不详解，但兼容性不好<ul><li>父元素display:flex，然后justify-content: center;</li><li>父元素display:flex，子元素margin:0 auto;</li></ul></li><li>使用以上方法需要定宽的，可以在js运行时获取子元素宽度，然后就好办了</li></ol><h3 id="轮播图上下一张按钮的垂直居中"><a href="#轮播图上下一张按钮的垂直居中" class="headerlink" title="轮播图上下一张按钮的垂直居中"></a>轮播图上下一张按钮的垂直居中</h3><p>绝对定位且是inline-block的a元素要实现在父元素中垂直居中，父元素中vertical-align不起作用，因为vertical-align是对inline元素，line-height设在a上是a的行高，结果是a中的元素垂直居中，而line-height设置在父元素上的话，a由于是绝对定位，所以会出现了a中的文字垂直居中了，而a还在绝对定位的初始位置，这并不是想要的效果。<br>针对绝对定位且定宽高的元素垂直居中，网上找到的解决方案是：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">top</span>: <span class="number">0</span>;<span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: auto <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>小结：</strong><br>通过上两个居中案例得出，如果一个固定宽高绝对定位的block元素要在父元素中水平居中对齐或者垂直居中对齐，可用top和bottom为0(垂直)，left和bottom为0(水平)，或4个方向都为0(水平垂直居中)，并同时使用<code>margin:auto</code>可实现，当然，如果如果该元素不是绝对定位且定宽高的block元素的话，可使用其他方案（上述中block也包括inline-block）</p><h3 id="背景透明，文字不透明的解决方案"><a href="#背景透明，文字不透明的解决方案" class="headerlink" title="背景透明，文字不透明的解决方案"></a>背景透明，文字不透明的解决方案</h3><p><a href="http://www.cnblogs.com/PeunZhang/p/4089894.html" target="_blank" rel="noopener">来自该文章链接#10楼评论</a></p><blockquote><p>兼容IE，栗如：<br>非IE：<code>background:rgba(0,0,0,0.5);</code><br>IE：<code>filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#7f000000,endColorstr=#7f000000);</code><br>rgba和IE下filter数值的转换：<br>rgba透明值 =&gt; IE filter值<br>0.1 =&gt; 19<br>0.2 =&gt; 33<br>0.3 =&gt; 4C<br>0.4 =&gt; 66<br>0.5 =&gt; 7F<br>0.6 =&gt; 99<br>0.7 =&gt; B2<br>0.8 =&gt; C8<br>0.9 =&gt; E5<br>转换公式：alpha*255再转换成16进制即可</p></blockquote><p><strong>注意1</strong>：使用filter的时候background要使用IE不支持的方式，比如rgba，否则话会导致background生效而filter无效<br><strong>注意2</strong>：最好和下面提到的兼容样式方法结合起来使用</p><h3 id="IE6-7的链接虚线外框"><a href="#IE6-7的链接虚线外框" class="headerlink" title="IE6/7的链接虚线外框"></a>IE6/7的链接虚线外框</h3><p><a href="http://www.cnblogs.com/something/archive/2013/05/21/3090428.html" target="_blank" rel="noopener">css去掉a标签点击后的虚线框</a><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">blr</span>:<span class="built_in">expression</span>(this.onFocus=this.blur());&#125;</span><br></pre></td></tr></table></figure></p><p>当然css表达式不是一种好的方案，但如果和下面提到的兼容样式结合起来就会好很多，至少可以将通用css和兼容特定浏览器的css分开来</p><h3 id="兼容样式"><a href="#兼容样式" class="headerlink" title="兼容样式"></a>兼容样式</h3><p><a href="http://www.cnblogs.com/PeunZhang/archive/2012/04/09/2437563.html" target="_blank" rel="noopener">CSS hack方案整理</a><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 支持IE6、7 */</span></span><br><span class="line">@<span class="keyword">media</span> screen\<span class="number">9</span> &#123; <span class="comment">/*兼容ie67的css*/</span> &#125;</span><br><span class="line"><span class="comment">/* 支持IE8 */</span></span><br><span class="line">@<span class="keyword">media</span> \<span class="number">0s</span>creen\ &#123;<span class="comment">/*兼容ie8的css*/</span>&#125;</span><br><span class="line"><span class="comment">/* 支持IE6、7、8 */</span></span><br><span class="line">@<span class="keyword">media</span>  \<span class="number">0s</span>creen\,screen\<span class="number">9</span>&#123;<span class="comment">/*兼容ie678的css*/</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="task0004"><a href="#task0004" class="headerlink" title="task0004"></a>task0004</h2><ul><li>监听text/search等文本框的输入时除了要监听input事件还要在ie8及低版本浏览器中监听propertychange事件</li><li>唯独ie9在按删除键时不会触发input或propertychange事件，所以我们直接针对ie9检测keydown事件的keyCode是否是删除键做处理</li></ul><h2 id="task0005"><a href="#task0005" class="headerlink" title="task0005"></a>task0005</h2><ul><li>拖动时的文字选中问题，其他浏览器在拖动过程中阻止默认事件即可，而IE拖动时的文字选中，要用setCapture/releaseCapture</li><li>ie7的offset值和其他浏览器不一样，所以用getBoundingClientRect函数获取</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在完成任务ife2015任务二中遇到的问题和解决方案：&lt;br&gt;&lt;strong&gt;ps&lt;/strong&gt;：很多和 &lt;a href=&quot;https://github.com/baidu-ife/ife/blob/master/2015_spring/task/task0002/re
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：学习小结</title>
    <link href="http://archmee.github.io/201612/2016-12-08.html"/>
    <id>http://archmee.github.io/201612/2016-12-08.html</id>
    <published>2016-12-07T16:00:00.000Z</published>
    <updated>2019-08-15T07:16:09.386Z</updated>
    
    <content type="html"><![CDATA[<p>从上次更新博客以来，时间已经过去了一个月，在这一个月当中完成的事情则是相当少，如果非要找个借口的话，那就是今年成都的冬季来地措不及防的早，整个这一个月除了几天少见有太阳，其他时候则全都在阴霾的笼罩之下。而我的行动也因此变得迟缓，哈哈哈哈哈哈哈哈哈哈哈~，不过也并不是完全荒废的。</p><ol><li>开始看《CSS权威指南》，已经看到了第5章，本来看之前以为这书会像传说中的像字典一样无聊，可是当我真正开始看的时候，才发现并没有，相反让我沉浸在书中对技术的细节描写当中，但是确实这本书不是我的当务之急，所以我还是会放一放</li><li>然后拿起了《JS语言精粹》这本书，目前正在看第5章。</li><li>将上篇博客中提到的IFE2015任务二进行了重(chong)构(xie)，我翻了一下github的提交记录：<ul><li>11.20 完成util.js，所以差不多从7号到20这13天都是在修改util.js，在IFE2015任务仓库的提交页面下，我把初级班和中级班的一半人的实现都看了一遍，大部分代码都差不多，但我还是从中搜集了一些好的实现放在了我的代码中。在看别人的代码过程中，我也在思考对比实现孰优孰劣，甚至对于自己有些复杂的实现，都要重新拟清原来的实现思路，因此也发现了以前未发现的一些隐藏Bug</li><li>11.21 调整task0002_1，将原来的内部脚本改为外部脚本文件，并对代码进行了调整，比如原来一个功能全部写在一个函数中完成，现在按照功能单独提出来调用。如果和util.js做的事情有重复的地方改为调用，所以现在task0002的5个小练习都依赖util.js</li><li>11.22 调整task0002_2</li><li>11.24 重构task0002_4</li><li>11.26 更改task0002_5的实现方式使其更简洁优雅 :)</li><li>12.07 完成task0002_3轮播的重构，<a href="https://archmee.github.io/201608/2016-08-29.html">以前实现过这个功能并写了篇博客分析实现思路</a>，而现在花了点时间改用面向对象的思想实现，感觉和组件有点像了：)</li></ul></li></ol><p>下面是5个小练习的完成效果截图，<a href="https://github.com/Archmee/Front-End-Demo/tree/master/ife_task/ife_task_2" target="_blank" rel="noopener">代码见github</a></p><ol><li>提取兴趣爱好（根据输入中的分隔符分割兴趣爱好条目，并创建成可勾选复选框）<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_1.jpg" alt="提取兴趣爱好"></li><li>倒计时（计算了每次定时器的产生的误差做误差补偿）<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_2.jpg" alt="倒计时"></li><li>轮播图（利用构造器可创建多个轮播，不过每个轮播器需要自定义大小）<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_3.jpg" alt="轮播图"><br>（ps：轮播图来自jd.com，侵删)</li><li>输入提示框（类似百度搜索框，不过是本地数据，输入匹配的部分会高亮，方向键上下移动，单击或回车选中）<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_4.jpg" alt="输入提示框"></li><li>拖拽界面交互（在有拖动类的容器内任意拖放）<br><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_5.jpg" alt="拖拽界面交互"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从上次更新博客以来，时间已经过去了一个月，在这一个月当中完成的事情则是相当少，如果非要找个借口的话，那就是今年成都的冬季来地措不及防的早，整个这一个月除了几天少见有太阳，其他时候则全都在阴霾的笼罩之下。而我的行动也因此变得迟缓，哈哈哈哈哈哈哈哈哈哈哈~，不过也并不是完全荒废
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：IFE2015 task2</title>
    <link href="http://archmee.github.io/201611/2016-11-06.html"/>
    <id>http://archmee.github.io/201611/2016-11-06.html</id>
    <published>2016-11-05T16:00:00.000Z</published>
    <updated>2019-08-15T05:45:25.856Z</updated>
    
    <content type="html"><![CDATA[<p>这几天将之前未完成的IFE 2015 任务二完成了，但是代码结构和编程思想都不是很理想，尤其是看了当时IFE团队review了IFE 2015的同学们的代码，指出的一些问题以及改进建议，<a href="https://github.com/baidu-ife/ife/blob/master/2015_spring/task/task0002/review/IFE-review.md" target="_blank" rel="noopener">IFE Team review地址</a>。甚至还给出了<a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0002/review/demo" target="_blank" rel="noopener">参考代码</a>，目前为止我只看了util js部分，其他都还没看。<br>我也对自己的代码中有的问题进行了小结：</p><ul><li>代码：完成任务的时候图一时方便，所以css和js都直接写到了相应的标签中而没有单独写到各自的文件中，因为我认为这不是当下最要紧的问题</li><li>编程思想：虽然代码中做到了结构行为样式分离，但是JS代码混成了一团，耦合度高，而且还是完全在使用以前的面向过程的编程思路，连最基本的使用函数分解任务降低耦合度都没有做到</li></ul><p>针对以上出现的问题，接下来几天想将部分代码进行重构和调整。<br>以下是完成的任务二的小练习1、2、4、5的Demo，之所以没有做小练习3-轮播，是因为我之前做过同样的东西：</p><ul><li><a href="https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_1.html" target="_blank" rel="noopener">1. 文本框</a></li><li><a href="https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_2.html" target="_blank" rel="noopener">2. 倒计时</a></li><li><a href="https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_4.html" target="_blank" rel="noopener">4. Auto suggestion</a></li><li><a href="https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_5.html" target="_blank" rel="noopener">5. 界面拖拽</a></li></ul><p>——2016.12.08更新——-<br>更新：重构了任务2的第3个小练习，地址如下：</p><ul><li><a href="https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_3.html" target="_blank" rel="noopener">3. 轮播</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天将之前未完成的IFE 2015 任务二完成了，但是代码结构和编程思想都不是很理想，尤其是看了当时IFE团队review了IFE 2015的同学们的代码，指出的一些问题以及改进建议，&lt;a href=&quot;https://github.com/baidu-ife/ife/bl
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅：完结《JS高级编程》</title>
    <link href="http://archmee.github.io/201610/2016-10-30.html"/>
    <id>http://archmee.github.io/201610/2016-10-30.html</id>
    <published>2016-10-29T16:00:00.000Z</published>
    <updated>2019-08-15T05:46:01.494Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在25号左右看完了JS《JS高级编程》一书。内容简要如下：</p><ul><li>23 离线应用与客户端缓存（Cookie、sessionStorage、localStorage、IndexedDB）</li><li>24 最佳实践</li><li>25 新兴的API</li></ul></li><li><p>在26号开始刷<a href="http://www.imooc.com/course/programdetail/pid/32" target="_blank" rel="noopener">慕课网的前端计划</a>，但直接跳过了HTML、CSS、JS的初级部分，本想看完DOM事件后完成IFE2015任务二的部分</p></li><li>但是27号下午开始感冒了</li><li>28号高烧腰痛难忍不能坐立，甚至下午出去逛超市差不多是挪着步子回来的，本打算第二天去医院挂个急诊，结果</li><li>29号好多了，本以为痊愈了，但晚上开始口苦鼻塞、头痛欲裂，侧夜难眠</li><li>30早上起来整个嘴唇都脱皮了，感觉上火比较严重，但是整个人感觉好多了，下午去药房随便拿了点药了事。我都觉得自己奇怪，病痛都差不多痊愈了才去买药来吃，想来也是因为自己忍受不了去医院挂号的麻烦。</li></ul><p>接下来希望尽快完成IFE2015任务二吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;在25号左右看完了JS《JS高级编程》一书。内容简要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;23 离线应用与客户端缓存（Cookie、sessionStorage、localStorage、IndexedDB）&lt;/li&gt;
&lt;li&gt;24 最佳实践&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
</feed>
