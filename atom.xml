<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archmee</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://archmee.github.io/"/>
  <updated>2017-03-12T18:47:04.703Z</updated>
  <id>http://archmee.github.io/</id>
  
  <author>
    <name>archmee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IFE 2015 task3资料学习总结</title>
    <link href="http://archmee.github.io/201703/2017-02-06-2.html"/>
    <id>http://archmee.github.io/201703/2017-02-06-2.html</id>
    <published>2017-03-02T16:00:00.000Z</published>
    <updated>2017-03-12T18:47:04.703Z</updated>
    
    <content type="html">&lt;p&gt;其实这篇总结问应该是在任务三的开始部分就完成的，但我一开始就投入了代码的怀抱，迟迟不肯动手，直到在任务三完成之后，并且在摸索任务四的时候才每天留了点时间将其完成。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这几个js中的难点几乎每天都会准时出现在各大技术网站上，这让人不得不冲动自己也来总结一番，趁还没忘记最近看的一堆参考资料。&lt;br&gt;我试图用最简洁的方式交一份满意的答卷。&lt;/p&gt;
&lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;p&gt;this在大多数OO语言中都是指当前对象引用，而在js中，却有几种不同的表现：&lt;br&gt;《js语言精粹》中明确指出this的值取决于调用的模式，js中一共有4中调用模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法调用模式&lt;/strong&gt;，一个函数作为对象的方法被调用时，this被绑定到该对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数调用模式&lt;/strong&gt;，一个普通函数(非方法)被调用时，this绑定到全局对象，浏览器中即window&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造器调用模式&lt;/strong&gt;，在一个函数前带上new关键字来调用，内部会创建一个连接到该函数原型的新对象，同时this被绑定到那个新对象上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;apply调用模式&lt;/strong&gt;，js提供了apply和call两个方法来更改this的绑定对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最常见的困惑是一个对象方法返回一个函数，其实这个时候的函数已经属于全局对象了，所以执行返回的函数中的this指向全局对象。&lt;br&gt;在给DOM绑定事件时候的this时也容易让人困惑，可以从鸟哥的 &lt;a href=&quot;www.laruence.com/2009/09/08/1076.html&quot;&gt;深入理解Javascript之this关键字&lt;/a&gt; 文中寻找答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this始终指向此时&lt;strong&gt;函数/方法调用者&lt;/strong&gt;，而不是在定义函数/方法时指向的对象。&lt;/li&gt;
&lt;li&gt;this是&lt;strong&gt;执行上下文环境&lt;/strong&gt;的一个属性，而不是某个变量对象/活动对象的属性。&lt;br&gt;这个特点很重要，因为和变量不同，this是没有一个类似搜寻变量的过程。当你在代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决于进入上下文时的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;闭包是什么呢？见名知意，即一个封闭的环境，即使用专业术语描述也相差无几。&lt;br&gt;闭包的作用是用来保存函数的执行上下文方便以后使用。&lt;br&gt;常见的闭包使用如 IIFE（立即执行表达式）、函数的柯里化，模块模式。&lt;br&gt;那么闭包在哪呢，通常闭包的形成都是在一个函数中返回一个函数的时候，由于返回的函数往往引用了父函数的上下文环境，导致父函数执行完成后内存没有得到回收/释放（引用计数机制），所以在返回的函数中可以访问父函数的上下文环境。这就形成了闭包。&lt;br&gt;上一个简单的示例：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;n&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count += n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sum(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sum(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例中在父函数初始化了count变量，返回的函数中引用了count，sum保存了返回函数，在以后调用sum的过程中，count会始终存在并保存上次调用后的值，那么count存放在哪里的呢，它就是被存放在了返回的函数形成的闭包中（上下文环境）。关于是如何在返回的函数中执行的时候找到count变量的过程，那么就涉及到接下来要讲的作用域和作用域链了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于每个标准函数在创建时候保存了[[Scope]]，所以理论上来讲，ECMAScript中的_所有函数都是闭包。&lt;br&gt;闭包是一个代码块（在ECMAScript中是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;作用域作用域链&quot;&gt;&lt;a href=&quot;#作用域作用域链&quot; class=&quot;headerlink&quot; title=&quot;作用域作用域链&quot;&gt;&lt;/a&gt;作用域作用域链&lt;/h2&gt;&lt;p&gt;作用域是？&lt;br&gt;简单的说，作用域就是变量与函数的可访问范围，即作用域控制着标识符(变量/函数/形参等等)的可见性和生命周期。在JavaScript中，标识符的作用域只有全局作用域和函数作用域两种。没有用var声明的都属于全局作用域，if/for/while等语句块没有内部作用域，在其中声明的变量将属于当前函数的作用域。&lt;/p&gt;
&lt;p&gt;那么作用域链是什么呢？&lt;br&gt;在定义函数的时候该函数内部会有一个[[scope]]属性，它指向定义该函数的函数的作用域链，这个链的底端是全局对象，顶端是当前活动对象。&lt;br&gt;作用域链的形成是从函数调用开始的，首先在全局环境中，当前活动对象就是GO，当执行一个函数的时候，会为该函数创建一个执行上下文(excution context)，在执行上下文中有初始化后的this，活动对象AO、变量对象VO等属性，然后将活动对象加入到作用域链顶端，加入的过程可能是在[[scope chain]]中加入，也可能是直接链接到&lt;code&gt;__parent__&lt;/code&gt;。因为我看过的资料关于这个链的实现的描述大概分两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;js高程是一种类似数组的方式并且按函数调用栈的顺序保存其“作用域”的引用，&lt;a href=&quot;http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2011090414454524_scope_chain.jpg&quot; alt=&quot;scope_chain实现&quot;&gt;&lt;/li&gt;
&lt;li&gt;其他资料也有描述的是一个&lt;code&gt;__parent__&lt;/code&gt;的内部属性来维护“父作用域”的引用，&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1645&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;比如下图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2012_03_21_09_parent_scope.png&quot; alt=&quot;parent实现&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然两种方式都可行，但是参照js原型链的实现方式，可能第二种方法更靠谱，复杂度为O(n)。因为如果按照第一种方式，每次都要拷贝父作用域的作用域链很麻烦，而且耗费内存，复杂度估计O(2n)。&lt;/p&gt;
&lt;p&gt;作用域链的用途是什么呢，用来遍历查找标识符，闭包就是利用这点实现的。&lt;br&gt;查找一个标识符的顺序是：从作用域链的顶端，也就是自身的活动对象开始，如果存在则返回，如果不存在将继续搜索父函数的活动对象，依次查找，直到找到为止。如果整个作用域链上都无法找到（到全局对象结束），则返回undefined。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从作用域链的结构可以看出，在执行上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于执行上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。&lt;/li&gt;
&lt;li&gt;在代码执行过程中，作用域链可以通过使用with语句和catch从句对象来扩充（它们的对象参数将会被作为活动对象加入到作用域链顶端）。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。这个事实导致作用域链查找变为&lt;em&gt;两个维度&lt;/em&gt;：&lt;ol&gt;
&lt;li&gt;先查找作用域链上的当前节点对象（活动）&lt;/li&gt;
&lt;li&gt;然后查找该对象的原型链（如果有），一直查找到原型链顶端，遍历作用域链，重复1,2步&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;原型和原型链&quot;&gt;&lt;a href=&quot;#原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;原型和原型链&quot;&gt;&lt;/a&gt;原型和原型链&lt;/h2&gt;&lt;p&gt;首先需要搞清楚的问题是：当我们谈论原型时，我们到底在谈什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个函数都有一个&lt;code&gt;prototype&lt;/code&gt;属性，它指向一个对象，该对象就是在当该函数用作构造函数创建对象实例时，作为其对象实例的原型。通过该函数构造的所有对象共享该原型中的方法和属性。函数是一个对象，它有自己的原型但不是&lt;code&gt;prototype&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;每个对象都有一个原型，根据浏览器不同一般表示为&lt;code&gt;[[Prototype]]&lt;/code&gt;或者&lt;code&gt;__proto__&lt;/code&gt;(好像已被最新标准实现)，这才是我们真正谈论的原型，它从哪里来呢，就是我们在第一点提到的构造函数的那个&lt;code&gt;prototype&lt;/code&gt;属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么原型链是什么，用来干什么？&lt;br&gt;所有对象都有一个原型，而每个原型又有自己的一个原型，就样形成了原型链，原型链的顶端是[[object prototype]]，该原型对象的的原型为null，就是原型链的终点。&lt;br&gt;当查找一个对象的属性时，js会从对象自己开始，然后从对象原型开始向上遍历原型链，直到找到指定属性为止，但如果直到原型链终点都仍然没有找到指定的属性，就会返回undefined。&lt;br&gt;下面看一张图总结原型原型链，是鸟哥&lt;a href=&quot;http://www.laruence.com/2010/05/13/1462.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文章中提到的一张图&lt;/a&gt;，被我改进了一下，不过相交的地方不太好，有空重构一下。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/20170310_prototype.jpg&quot; alt=&quot;prototype&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后，我总结了一条关于原型原型链和作用域作用域链的明显区别：&lt;br&gt;原型原型链是用于在对象中查找属性和方法等标识符，作用域作用域链是用于查找变量和函数等标识符。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;若有错误，望不吝指正。&lt;br&gt;参考资料请见上一篇学习摘录。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实这篇总结问应该是在任务三的开始部分就完成的，但我一开始就投入了代码的怀抱，迟迟不肯动手，直到在任务三完成之后，并且在摸索任务四的时候才每天留了点时间将其完成。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这几个js中的难点几乎每天都会准时出现在各大技术网站上，这让人不得不冲动自己也来总结一
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 186~233 天</title>
    <link href="http://archmee.github.io/201702/2017-02-27.html"/>
    <id>http://archmee.github.io/201702/2017-02-27.html</id>
    <published>2017-02-24T16:00:00.000Z</published>
    <updated>2017-03-12T18:28:11.097Z</updated>
    
    <content type="html">&lt;p&gt;从时间跨度上来说，几乎是两个月的时间，因为是在过年期间，所以会精力比较分散。&lt;br&gt;在1月下旬就完成了界面布局的工作，但是一直在思考尝试如何组织代码结构和数据结构。虽然说说网上有这方面的文章和书籍，但是我认为最开始还是要脱离别人的思维限制，先自己尝试更好，锻炼了自己的架构和思考能力，也会更清楚在无从下手到从0开发一个完整的项目的流程和遇到的问题，等完成后再对比成熟的方案也不失为一个好方案。在多次思考分析利弊之后，整个todo应用数据存储有了一个比较理想的方案，当然，数据都是存储在localStorage中，而整个软件采用模块模式来开发，但是被我分成了几个小模块。&lt;/p&gt;
&lt;h2 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; title=&quot;模块&quot;&gt;&lt;/a&gt;模块&lt;/h2&gt;&lt;p&gt;模块模式可以避免全局变量污染，并且可以很好的解耦。可能是我对模式的理解有偏差，我理想中应该是这样的架构，如下图，要涉及到发布/订阅模式以及MVC，但是不知道是否合适，因为js事件从本质来说就是发布/订阅模式（也可以说观察者）模式。毕竟是第一次实践设计模式的知识，只有慢慢试探了。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/20170310_jiagou1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是我最终完成的架构却是这样的，整个app分为4个模块，分类列表主要负责分类的列表数据和模板，todo列表负责分类的数据和模板，todo详情部分负责单条todo的详情和展示模板等，一个app部分负责协调上述几个部分的工作。这并不是很好的设计，最主要的问题是其中的模板对数据的依赖导致耦合严重，在后面的重构过程中将改变整个软件架构。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/20170310_jiagou2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;该应用的代码架构：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//分类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;categoryModule =  (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//操作 model &amp;amp; template&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//返回接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//todo列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;todoModule =  (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//操作 model &amp;amp; template&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//返回接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//todo详情&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;todoDetail = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//操作 model &amp;amp; template&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//返回接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//app controller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;appModule = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    init: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//初始化分类列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//初始化todo列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//初始化todo详情界面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//初始化事件绑定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//等待用户交互触发事件并分发事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据存储&quot;&gt;&lt;a href=&quot;#数据存储&quot; class=&quot;headerlink&quot; title=&quot;数据存储&quot;&gt;&lt;/a&gt;数据存储&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;所有分类数据汇总存储到一个对象，每个分类就是该对象中一个用id作为键值的对象，这样做是为了方便按id索引单条分类数据，每条分类数据都是独立的，没有嵌套关系。&lt;/li&gt;
&lt;li&gt;整个对象中有一个在程序初始化时创建的分类对象作为顶级分类用于保存一级二级以及更多子分类，类似于DOM中的根节点。&lt;/li&gt;
&lt;li&gt;每个分类对象保存了父分类id和子分类id映射表和，熟悉DOM的同学一下就能get到这是借鉴了DOM的思想，不同的是这里不是保存引用。&lt;/li&gt;
&lt;li&gt;每个分类也保存了该分类下的todo列表映射，添加删除todo时要维护此表。&lt;/li&gt;
&lt;li&gt;todo数据是按照id单独存放的，也就是说，要获取todo，知道它的id后直接从localStorage中取出来，这样做也是因为方便对单条todo进行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是具体数据结构：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//分类列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;cid_1&quot;&lt;/span&gt;: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;cid_2&quot;&lt;/span&gt;: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//单条分类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;addTime&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1487710962417&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//添加时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;cid&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;cid_1487710962417&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//分类id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;pid&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;cid_0000000000001&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//父分类id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;未命名分类1&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//分类名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;childCatList&quot;&lt;/span&gt;:[ &lt;span class=&quot;comment&quot;&gt;//保存直接子分类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;cid_1487883840564&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;cid_1487980933649&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;childTodoList&quot;&lt;/span&gt;:[ &lt;span class=&quot;comment&quot;&gt;//保存直接子todo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;tid_1487776376694&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;tid_1487776391312&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//单条todo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;addTime&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1487776376694&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//添加时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;tid&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;tid_1487776376694&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//todo id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;cid&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;cid_1487710962417&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//分类id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;emergency&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//紧急程度，暂时没用上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;未命名任务&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//todo标题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;content&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;出门交电费&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//todo内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;status&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//状态1和-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;expireTime&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1487721600000&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//失效时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;完成&quot;&gt;&lt;a href=&quot;#完成&quot; class=&quot;headerlink&quot; title=&quot;完成&quot;&gt;&lt;/a&gt;完成&lt;/h2&gt;&lt;p&gt;在2月25号完成了该任务，翻看了一下IFE2015 task3的初级班和中级班的提交列表，发现自己实现得算是非常好的了，不过也花了好长时间。下面上图：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2017-02-25_090953.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;遇到的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高度自适应布局，最开始我使用了float来布局，但是高度不能自适应&lt;br&gt;解决：最后在网上找到了高度自适应布局方案，使用了绝对定位技术，设置top和bottom为0或者你需要撑开的上下间隔即可。&lt;/li&gt;
&lt;li&gt;分类列表和todo列表设置了overflow:scroll，但是不管内容有没有超出滚动条都始终显示在那里很碍眼。&lt;br&gt;  解决：设置overflow为auto而不是scroll&lt;/li&gt;
&lt;li&gt;待解决：如何架构这个程序？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的计划就是看完《设计模式》剩下的几章，以及刷一遍CSS3，ES6，然后开始学习React或者Vue就找工作了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章不是一笔写成，而是在完成任务三的过程中多次更新，所以不以发布时间为准。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从时间跨度上来说，几乎是两个月的时间，因为是在过年期间，所以会精力比较分散。&lt;br&gt;在1月下旬就完成了界面布局的工作，但是一直在思考尝试如何组织代码结构和数据结构。虽然说说网上有这方面的文章和书籍，但是我认为最开始还是要脱离别人的思维限制，先自己尝试更好，锻炼了自己的架构和
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>IFE 2015 task3资料学习摘录</title>
    <link href="http://archmee.github.io/201702/2017-02-06-1.html"/>
    <id>http://archmee.github.io/201702/2017-02-06-1.html</id>
    <published>2017-01-31T16:00:00.000Z</published>
    <updated>2017-03-08T21:06:05.184Z</updated>
    
    <content type="html">&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;理解一个函数的原型属性(function’s prototype property )其实和实际的原型(prototype)没有关系对我们来说至关重要。&lt;/li&gt;
&lt;li&gt;A prototype chain is a finite chain of objects which is used to implemented inheritance and shared properties.（原型链是一个用于实现继承和共享属性的有限对象链）&lt;/li&gt;
&lt;li&gt;还有一点我们需要注意的是，我们可以赋值任何类型的对象到原型上，但是不能赋值原子类型的值，比如如下代码是无效的：&lt;code&gt;Cat.Prototype = 5;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;原型原型链是用于对象标识符查找（属性和方法），而作用域作用域链是用于普通标识符的查找（变量和函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;作用域、作用域链、闭包&quot;&gt;&lt;a href=&quot;#作用域、作用域链、闭包&quot; class=&quot;headerlink&quot; title=&quot;作用域、作用域链、闭包&quot;&gt;&lt;/a&gt;作用域、作用域链、闭包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当在函数中访问一个变量的时候，搜索顺序是先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索父函数的活动对象，依次查找，直到找到为止。如果整个作用域链上都无法找到，则返回undefined。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果函数存在Prototype原型对象，则在查找完自身的活动对象后再查找自身的原型对象，这就是Javascript中的变量查找机制。（&lt;strong&gt;经如下代码证明这一点是错误的&lt;/strong&gt;）&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;b&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(i); &lt;span class=&quot;comment&quot;&gt;//0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(y); &lt;span class=&quot;comment&quot;&gt;//error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(x); &lt;span class=&quot;comment&quot;&gt;//error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b.prototype.y=&lt;span class=&quot;string&quot;&gt;&#39;y=5&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.prototype.x=&lt;span class=&quot;string&quot;&gt;&#39;x=10&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; c=a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在代码执行过程中，作用域链可以通过使用with语句和catch从句对象来增强（将它们的对象参数作为活动对象加入到作用域链顶端）。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。这个事实导致作用域链查找变为&lt;em&gt;两个维度&lt;/em&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先是查找作用域链上的活动对象&lt;/li&gt;
&lt;li&gt;然后在每个作用域链上的活动对象上查找该对象的原型链（如果有原型）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意，由于&lt;em&gt;每个&lt;/em&gt;（标准的）函数都在创建的时候保存了[[Scope]]，所以理论上来讲，ECMAScript中的&lt;em&gt;所有函数&lt;/em&gt;都是&lt;em&gt;闭包&lt;/em&gt;。&lt;br&gt;闭包是一个代码块（在ECMAScript是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;this始终指向此时函数/方法调用者，而不是在定义函数/方法时指向的对象。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何对象都可以作为上下文的this值。我想再次澄清对与ECMAScript中，与执行上下文相关的一些描述——特别是this的误解。通常，this 被错误地描述为变量对象（活动对象）的属性。 请牢记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;this是执行上下文环境的一个属性，而不是某个变量对象/活动对象的属性&lt;br&gt;  这个特点很重要，因为和变量不同，this是没有一个类似搜寻变量的过程。当你在代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决于进入上下文时的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意this这个值在一个继承机制中，是指向它的当前对象，而不是从原型链上找到它时所属于的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有一种叫作冒充继承的方式代码如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Cat.prototype = Animal.prototype;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。&lt;br&gt;为了解决这个问题，后来增加了一个在中间桥接的空白对象。&lt;br&gt;比如下面这个extend函数，就是YUI库如何实现继承的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Child, Parent&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　　　&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; F = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　　　F.prototype = Parent.prototype;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　　　Child.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; F();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　　　Child.prototype.constructor = Child;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　　　Child.uber = Parent.prototype;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的 hasOwnProperty 函数来获取正确的结果&lt;br&gt;// 使用{}对象的 hasOwnProperty&lt;br&gt;&lt;code&gt;{}.hasOwnProperty.call()&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在使用第三方JS类库的时候，往往有时候他们定义的原型方法是不能满足我们的需要，但是又离不开这个类库，所以这时候我们就需要重写他们的原型中的一个或者多个属性或function，我们可以通过声明的同样的名称（标识符）的形式来达到覆盖重写的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在浏览器中setTimeout、setInterval和匿名函数执行时的this是全局对象window&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;apply用于改变函数执行时的当前对象，当无参数时，当前对象为window，有参数时当前对象为该参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被称为被调用者(callee) 。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;深入理解作用域&quot;&gt;&lt;a href=&quot;#深入理解作用域&quot; class=&quot;headerlink&quot; title=&quot;深入理解作用域&quot;&gt;&lt;/a&gt;深入理解作用域&lt;/h2&gt;&lt;p&gt;来自 &lt;a href=&quot;http://www.laruence.com/2009/05/28/863.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Javascript作用域原理：&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在JS中“一切皆是对象, 函数也是”&lt;/li&gt;
&lt;li&gt;在对应作用域内，函数定义会提升，但函数表达式没有提升&lt;/li&gt;
&lt;li&gt;JS权威指南中有一句很精辟的描述：“JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里”&lt;/li&gt;
&lt;li&gt;ECMA262中所述作用域的实现：&lt;ol&gt;
&lt;li&gt;任何执行上下文时刻的作用域, 都是由作用域链(scope chain)来实现&lt;/li&gt;
&lt;li&gt;在一个函数被定义的时候, 会将该函数的&lt;code&gt;[[scope]]&lt;/code&gt;属性指向它此时的作用域链(scope chain)&lt;/li&gt;
&lt;li&gt;在一个函数被调用的时候，会创建一个活动对象，然后在活动对象中加入&lt;code&gt;this&lt;/code&gt;和&lt;code&gt;arguments&lt;/code&gt;属性，对于每一个函数的形参和变量，都命名为该活动对象的命名属性, 然后将这个活动对象加入到此时的作用域链的最前端&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在调用函数执行之前, 会首先创建一个活动对象, 然后搜寻这个函数中的形参、局部变量定义和函数定义, 将它们作为这个活动对象的同名属性, 对于形参则直接赋值，对于局部变量定义，变量的值会在真正执行的时候才计算，此时只是简单的赋为&lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;JS作为一门解释执行的语言其实是有预编译的过程的, JS在执行每一段代码之前, 都会首先处理&lt;code&gt;var&lt;/code&gt;关键字和&lt;code&gt;function&lt;/code&gt;定义式(函数定义式和函数表达式)。&lt;/li&gt;
&lt;li&gt;JS的预编译是以段为处理单元的… 而段是按&lt;code&gt;script&lt;/code&gt;标记来分的，所以一个script就是一个处理单元。　&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来自 &lt;a href=&quot;http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;理解 JavaScript 作用域和作用域链&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JS引擎访问的内部属性。其中一个内部属性是&lt;code&gt;[[Scope]]&lt;/code&gt;，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在定义函数时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图所示（注意：图片只例举了全部变量中的一部分）：&lt;br&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2011/36987/2011090414435366.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行此函数时会创建一个称为“运行时上下文(execution context)”的内部对象，运行时上下文定义了函数执行时的环境。每个运行时上下文都有自己的作用域链，用于标识符解析，当运行时上下文被创建时，它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。&lt;br&gt;而形参和变量按照它们出现在函数中的顺序被复制到运行时上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、&lt;code&gt;arguments&lt;/code&gt;以及&lt;code&gt;this&lt;/code&gt;，然后此对象会被加入到作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示：&lt;br&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2011/36987/2011090414444843.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被&lt;code&gt;with&lt;/code&gt;语句和&lt;code&gt;catch&lt;/code&gt;语句影响。&lt;br&gt;当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着该函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。如下图所示：&lt;br&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2011/36987/2011090414454524.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域链的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中，此时的作用域链图和上图类似。&lt;br&gt;因此在程序中应避免使用with语句，由于try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免，可通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;学习时，发现部分链接已经无效，并且自己补充了一些。&lt;/p&gt;
&lt;p&gt;js基础：&lt;br&gt;&lt;a href=&quot;http://weizhifeng.net/javascript-the-core.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://weizhifeng.net/javascript-the-core.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/javascript-the-core/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dmitrysoshnikov.com/ecmascript/javascript-the-core/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1643&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1643&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1644&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1644&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1645&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1645&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;面向对象：&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-ooriented_javascript_encapsulation.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2010/05/object-ooriented_javascript_encapsulation.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1642&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1642&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/fool/archive/2010/10/16/1853126.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/fool/archive/2010/10/16/1853126.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;this：&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/index.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/justany/archive/2012/11/01/the_keyword_this_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/justany/archive/2012/11/01/the_keyword_this_in_javascript.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1647&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1647&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原型：&lt;br&gt;&lt;a href=&quot;http://blog.jobbole.com/9648/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.jobbole.com/9648/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1641&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1641&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1648&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1648&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/wangfupeng1988/p/3977924.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/wangfupeng1988/p/3977924.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;闭包：&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/rubylouvre/archive/2009/07/24/1530074.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/rubylouvre/archive/2009/07/24/1530074.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://coolshell.cn/articles/6731.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolshell.cn/articles/6731.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kb.cnblogs.com/page/105708/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://kb.cnblogs.com/page/105708/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1646&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1646&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;理解一个函数的原型属性(function’s prototype property )其实和实际的原型(prototype)没有
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 174~185 天</title>
    <link href="http://archmee.github.io/201701/2017-01-08.html"/>
    <id>http://archmee.github.io/201701/2017-01-08.html</id>
    <published>2017-01-07T16:00:00.000Z</published>
    <updated>2017-03-12T18:50:14.996Z</updated>
    
    <content type="html">&lt;p&gt;这10天看完了《Head First HTML5》和IFE2015春Task3的参考资料，对this、闭包、作用域和作用域链、原型和原型链都有了更深的理解，但是自己的总结还没写，估计下一篇博客内容就是总结js中这几个非常核心的知识点，脑海中已经有了大概的雏形，希望尽量简洁，一针见血掐中要害。&lt;/p&gt;
&lt;h2 id=&quot;HTML5&quot;&gt;&lt;a href=&quot;#HTML5&quot; class=&quot;headerlink&quot; title=&quot;HTML5&quot;&gt;&lt;/a&gt;HTML5&lt;/h2&gt;&lt;p&gt;《Head First HTML5》在一年多以前看过一遍，当时在没有系统学习js基础的情况下看完了，但在现在看来当时并没有完全看懂，但至少h5的关键技术都知道了，想来和前面4章讲了js的基础还是有很大关系的，其实我更希望省略掉前面4章，因为毕竟作为想学习h5的人来说应该已经通过其他书籍对js有了系统的学习，所以这4章对js的入门讲解就显得很鸡肋，因为对没学过js的人通过这4章根本学不会js，已经学会js的又不需要，所以这4章只是徒增了这本书的厚度，导致读起来非常不爽快，而且违背了该书的“节约纸张”的基本信条（因为该书到处都在提醒读者他们为了节约纸张省略了部分代码）。但是后面6章还是真的深入浅出的讲解了h5的几个关键技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5.地理定位&lt;/li&gt;
&lt;li&gt;6.JSONP跨域（这个不属于h5）&lt;/li&gt;
&lt;li&gt;7.Canvas画布&lt;/li&gt;
&lt;li&gt;8.Video&lt;/li&gt;
&lt;li&gt;9.本地存储localStorage&lt;/li&gt;
&lt;li&gt;10.Web多线程（Worker）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;IFE2015-Task3&quot;&gt;&lt;a href=&quot;#IFE2015-Task3&quot; class=&quot;headerlink&quot; title=&quot;IFE2015 Task3&quot;&gt;&lt;/a&gt;IFE2015 Task3&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0003&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IFE2015 Task3&lt;/a&gt; 页面提供了很多深入学习js的参考资料，我看了大部分，除了《Eloquent JavaScript》和javascript设计模式相关的内容，因为我的案头边就有一本正在看的《JavaScript设计模式》，而且设计模式这个内容不是看看书就能学好的，而是要通过大量代码实践才能学习其精华，所以目前只需要了解即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;看完学习资料摘录片段也总结成了一篇博客&lt;/li&gt;
&lt;li&gt;和一篇学习笔记总结有关this、闭包、作用域作用域链、原型和原型链&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Next&quot;&gt;&lt;a href=&quot;#Next&quot; class=&quot;headerlink&quot; title=&quot;Next&quot;&gt;&lt;/a&gt;Next&lt;/h2&gt;&lt;p&gt;下一步主要有下面几件事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总结前面提到的javascript中关于this、闭包、作用域作用域链、原型和原型链的学习笔记&lt;/li&gt;
&lt;li&gt;完成IFE2015 Task3的TODO应用&lt;/li&gt;
&lt;li&gt;以及更多还没学习的东西如编码规范、响应式布局、CSS3、Less、Sass、PostCSS、BootStrap、ES6、webpack或gulp、JQ、移动端、SPA、NodeJS、Vue和React至少要学习一个&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这10天看完了《Head First HTML5》和IFE2015春Task3的参考资料，对this、闭包、作用域和作用域链、原型和原型链都有了更深的理解，但是自己的总结还没写，估计下一篇博客内容就是总结js中这几个非常核心的知识点，脑海中已经有了大概的雏形，希望尽量简洁，
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 159~173 天</title>
    <link href="http://archmee.github.io/201612/2016-12-27.html"/>
    <id>http://archmee.github.io/201612/2016-12-27.html</id>
    <published>2016-12-25T16:00:00.000Z</published>
    <updated>2016-12-26T20:00:29.258Z</updated>
    
    <content type="html">&lt;p&gt;这十几天做的事情很少，很少看书，都在写代码，但是代码也写得很少，最开始只是单纯想写一个手风琴图片效果，但是找到一个手风琴的菜单，也想尝试一下，就同时设计写了几个菜单效果，但在实现的时候，可能是在大半夜思路不清晰的原因，导致写的代码混乱，对事件的处理也很混乱，在终于完成了几个效果后，几天前开始了重构，一下子就思路清晰了很多，代码实现思路也更简单，省去了些代码行数，今天在终于实现了手风琴图盘效果后，才想起最近的总结还没完成。&lt;/p&gt;
&lt;p&gt;中间还看了IFE2015 task3的几篇关于作用域链和原型链的文章，除了理解作用域链和原型链外，还对其他几方面诸如闭包/this理解都更加清晰了。&lt;/p&gt;
&lt;p&gt;今晚上对move.js（个人在完善的一个动画函数）进行了更新，加入了对 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;requestAnimationFrame&lt;/a&gt; 的支持，这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需求。这样就可以将原来使用setTimeout的动画作为一种降级方案，当然只有比较新的浏览器才支持这个API，所以我是用了&lt;a href=&quot;https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章: requestAnimationFrame for Smart Animating&lt;/a&gt;中提到的Erik Möller提供的Polyfill&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; lastTime = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vendors = [&lt;span class=&quot;string&quot;&gt;&#39;webkit&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;moz&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; x &amp;lt; vendors.length &amp;amp;&amp;amp; !&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.requestAnimationFrame; ++x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.requestAnimationFrame = &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;[vendors[x]+&lt;span class=&quot;string&quot;&gt;&#39;RequestAnimationFrame&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.cancelAnimationFrame =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;[vendors[x]+&lt;span class=&quot;string&quot;&gt;&#39;CancelAnimationFrame&#39;&lt;/span&gt;] || &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;[vendors[x]+&lt;span class=&quot;string&quot;&gt;&#39;CancelRequestAnimationFrame&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.requestAnimationFrame)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.requestAnimationFrame = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;callback, element&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; currTime = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;().getTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; timeToCall = &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; - (currTime - lastTime));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id = &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; callback(currTime + timeToCall); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              timeToCall);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lastTime = currTime + timeToCall;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.cancelAnimationFrame)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.cancelAnimationFrame = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;id&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clearTimeout(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上文提到的几个效果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/tree/master/fancy/dropdown-menu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;几个菜单&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/dropmenu.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/blob/master/fancy/shoufengqin.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;手风琴图片&lt;/a&gt;（图片来自C&amp;amp;A官网，侵删）&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/shoufengqin.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这十几天做的事情很少，很少看书，都在写代码，但是代码也写得很少，最开始只是单纯想写一个手风琴图片效果，但是找到一个手风琴的菜单，也想尝试一下，就同时设计写了几个菜单效果，但在实现的时候，可能是在大半夜思路不清晰的原因，导致写的代码混乱，对事件的处理也很混乱，在终于完成了几个
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 158 天</title>
    <link href="http://archmee.github.io/201612/2016-12-12.html"/>
    <id>http://archmee.github.io/201612/2016-12-12.html</id>
    <published>2016-12-11T16:00:00.000Z</published>
    <updated>2016-12-12T20:32:12.243Z</updated>
    
    <content type="html">&lt;h1 id=&quot;javascript语言精粹简要笔记&quot;&gt;&lt;a href=&quot;#javascript语言精粹简要笔记&quot; class=&quot;headerlink&quot; title=&quot;javascript语言精粹简要笔记&quot;&gt;&lt;/a&gt;javascript语言精粹简要笔记&lt;/h1&gt;&lt;p&gt;由于个人很喜欢DC这本书的这种开篇方式，所以将其对莎士比亚著作的引用也写进来了，以下如未做特殊说明，引用内容均来自该书。&lt;/p&gt;
&lt;p&gt;##1. 精华&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;……我不过略有些讨人喜欢的地方而已，怎么会有什么迷人的魔力？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-语法&quot;&gt;&lt;a href=&quot;#2-语法&quot; class=&quot;headerlink&quot; title=&quot;2. 语法&quot;&gt;&lt;/a&gt;2. 语法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我很熟悉它，早就在文法书上念过了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者用铁路图（语法图）来表示了js语法中的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空白，多行注释&lt;code&gt;/**/&lt;/code&gt;会和&lt;code&gt;/a*/&lt;/code&gt;这样的正则表达式冲突&lt;/li&gt;
&lt;li&gt;标识符，可以以字母、下划线、美元符号开头&lt;/li&gt;
&lt;li&gt;数字，js只有一个数字类型，内部表示为64位浮点数，isNaN可以检测NaN类型&lt;/li&gt;
&lt;li&gt;字符串，字符串一旦创建，就不可变&lt;/li&gt;
&lt;li&gt;语句，js的代码块不会创建新的作用域&lt;/li&gt;
&lt;li&gt;表达式&lt;/li&gt;
&lt;li&gt;字面量&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-对象&quot;&gt;&lt;a href=&quot;#3-对象&quot; class=&quot;headerlink&quot; title=&quot;3. 对象&quot;&gt;&lt;/a&gt;3. 对象&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;对于丑陋的事物，爱会闭目无视&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;js对象是可变的键值对集合，属性名可以是包括空字符串在内的任意字符串，属性值可以是除了&lt;code&gt;undefined&lt;/code&gt;外的任何值&lt;/li&gt;
&lt;li&gt;每个对象都连接到一个原型对象，所有通过对象字面量创建的对象都连接到&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从原型链中检索属性值的过程称为委托&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-函数&quot;&gt;&lt;a href=&quot;#4-函数&quot; class=&quot;headerlink&quot; title=&quot;4. 函数&quot;&gt;&lt;/a&gt;4. 函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;所有的过失都在未犯以前，都已定下应处的惩罚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;js中函数就是对象&lt;/li&gt;
&lt;li&gt;调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数，除了声明时定义的形参，每个函数还接收两个附加参数&lt;code&gt;this&lt;/code&gt;和&lt;code&gt;arguments&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt;的值取决于调用的模式，js中一共有4中调用模式：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法调用模式&lt;/strong&gt;，一个函数作为对象的属性就是方法，当一个方法被调用时，&lt;code&gt;this&lt;/code&gt;被绑定到该对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数调用模式&lt;/strong&gt;，一个普通函数(非方法)被调用时，&lt;code&gt;this&lt;/code&gt;绑定到全局对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造器调用模式&lt;/strong&gt;，在一个函数前带上&lt;code&gt;new&lt;/code&gt;关键字来调用，内部会创建一个连接到该函数原型的新对象，同时&lt;code&gt;this&lt;/code&gt;被绑定到那个新对象上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;apply调用模式&lt;/strong&gt;，js提供了&lt;code&gt;apply&lt;/code&gt;和&lt;code&gt;call&lt;/code&gt;两个方法来更改&lt;code&gt;this&lt;/code&gt;的绑定对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arguments&lt;/code&gt;保存了调用时的参数列表，它只是一个‘类数组对象’，除了有一个length属性外，没有任何数组方法&lt;/li&gt;
&lt;li&gt;js允许给语言的基本类型扩充功能&lt;/li&gt;
&lt;li&gt;js只有函数作用域和全局作用域&lt;/li&gt;
&lt;li&gt;可以使用函数和闭包来构建模块，模块模式的一般形式是：一个定义了私有变量和函数的的函数；利用闭包可以创建可以访问私有变量和函数的特权函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;5-继承&quot;&gt;&lt;a href=&quot;#5-继承&quot; class=&quot;headerlink&quot; title=&quot;5. 继承&quot;&gt;&lt;/a&gt;5. 继承&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;……往往会把一件完整的东西化成无数的形象，就像凹凸镜一般，从正面望去，只见一片模糊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本章作者介绍了几种实现继承的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伪类：用繁琐的模仿其他面向对象语言的方式来实现继承&lt;/li&gt;
&lt;li&gt;原型：也叫差异化继承，通过创建一个父类对象，然后在其基础上添加自定义属性&lt;/li&gt;
&lt;li&gt;函数化：也叫应用模块模式，通过4个步骤来实现&lt;ol&gt;
&lt;li&gt;创建一个新对象&lt;/li&gt;
&lt;li&gt;有选择的定义私有变量和方法&lt;/li&gt;
&lt;li&gt;给这个新对象扩充方法&lt;/li&gt;
&lt;li&gt;返回那个对象&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;6-数组&quot;&gt;&lt;a href=&quot;#6-数组&quot; class=&quot;headerlink&quot; title=&quot;6. 数组&quot;&gt;&lt;/a&gt;6. 数组&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;你这披着羊皮的狼，我要把你赶走&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;js数组的length没有上界&lt;/li&gt;
&lt;li&gt;js数组也是对象，js中一切皆对象&lt;/li&gt;
&lt;li&gt;使用数组还是对象？一个简单的规则是：当属性名是小而连续的整数时，使用数组，否则使用对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;7-正则表达式&quot;&gt;&lt;a href=&quot;#7-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;7. 正则表达式&quot;&gt;&lt;/a&gt;7. 正则表达式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;相反地，选到一个称心如意的配偶，就能百年谐和，幸福无穷&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;js中会用到正则表达式的方法有：&lt;code&gt;regexp.exec&lt;/code&gt;、 &lt;code&gt;regexp.test&lt;/code&gt;、&lt;code&gt;string.match&lt;/code&gt;、&lt;code&gt;string.replace&lt;/code&gt;、 &lt;code&gt;string.split&lt;/code&gt;、&lt;code&gt;string.search&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正则表达式分组&lt;ul&gt;
&lt;li&gt;捕获型&lt;code&gt;()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非捕获型&lt;code&gt;(?:)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;向前正匹配&lt;code&gt;(?=)&lt;/code&gt;（！bad）&lt;/li&gt;
&lt;li&gt;向前负匹配&lt;code&gt;(?!)&lt;/code&gt; （！bad）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;8-方法&quot;&gt;&lt;a href=&quot;#8-方法&quot; class=&quot;headerlink&quot; title=&quot;8. 方法&quot;&gt;&lt;/a&gt;8. 方法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;他虽疯，但却有他的一套理论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;9-代码风格&quot;&gt;&lt;a href=&quot;#9-代码风格&quot; class=&quot;headerlink&quot; title=&quot;9. 代码风格&quot;&gt;&lt;/a&gt;9. 代码风格&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;好一串嘟嘟囔囔的头衔！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讲了作者推崇的一些风格，比如缩进4个空格、不允许case语句穿越、唯一全局变量等等&lt;/p&gt;
&lt;h2 id=&quot;10-优美的特性&quot;&gt;&lt;a href=&quot;#10-优美的特性&quot; class=&quot;headerlink&quot; title=&quot;10. 优美的特性&quot;&gt;&lt;/a&gt;10. 优美的特性&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我让你的脚玷污我的嘴唇，让你的肖像玷污我的眼睛，让你的每一部分玷污我的心，等候着你的答复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;附录A-毒瘤&quot;&gt;&lt;a href=&quot;#附录A-毒瘤&quot; class=&quot;headerlink&quot; title=&quot;附录A. 毒瘤&quot;&gt;&lt;/a&gt;附录A. 毒瘤&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;那会在一言一行中证明其可怕&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;js对全局变量的依赖降低了程序的可靠性&lt;/li&gt;
&lt;li&gt;由于js有函数作用域但是没有块级作用域，所以更好的方式是在每个函数开头部分声明所有变量&lt;/li&gt;
&lt;li&gt;由于js的自动插入分号机制，建议将&lt;code&gt;{&lt;/code&gt;放在上一行的结束而不是新行&lt;/li&gt;
&lt;li&gt;Unicode把一对字符视为一个单一字符，js认为一对字符是两个不同的字符&lt;/li&gt;
&lt;li&gt;第二个可选参数是基数，建议总是带上10作为基数&lt;/li&gt;
&lt;li&gt;js没有真正的数组&lt;/li&gt;
&lt;li&gt;&lt;p&gt;js中的众多假值&lt;/p&gt;
&lt;p&gt;  | 值 | 类型 |&lt;br&gt;  |:——–|:——–|&lt;br&gt;  | 0 | Number |&lt;br&gt;  | NaN | Number |&lt;br&gt;  | ‘’ | String |&lt;br&gt;  | false | Boolean |&lt;br&gt;  | null | Object |&lt;br&gt;  | undefined | Undefined |&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;hasOwnProperty可以被重写覆盖&lt;/li&gt;
&lt;li&gt;js中的对象永远不会是真的空对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;附录B-糟粕&quot;&gt;&lt;a href=&quot;#附录B-糟粕&quot; class=&quot;headerlink&quot; title=&quot;附录B. 糟粕&quot;&gt;&lt;/a&gt;附录B. 糟粕&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;现在要请你告诉我，你究竟为了我哪一点坏处而开始爱我起来呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;===&lt;/code&gt;和&lt;code&gt;!==&lt;/code&gt;来判断是否相等，而不是&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;避免使用with，除了不可预料外，它还会阻断变量名的词法作用域绑定&lt;/li&gt;
&lt;li&gt;避免使用eval，由于它需要运行编译器，所以降低了语言的性能，还削弱了程序的安全性，除此之外，也尽量避免Function构造器、setTimeout和setInterval的字符串形式的参数&lt;/li&gt;
&lt;li&gt;移除continue会使性能得到改善&lt;/li&gt;
&lt;li&gt;避免使用switch语句的case条件穿越&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;if&lt;/code&gt;,&lt;code&gt;while&lt;/code&gt;,&lt;code&gt;do&lt;/code&gt;,&lt;code&gt;for&lt;/code&gt;总是使用代码块&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;--&lt;/code&gt;替换为&lt;code&gt;+=&lt;/code&gt;和&lt;code&gt;-=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;js位运算的多次转换反而会降低位运算带来的性能提高&lt;/li&gt;
&lt;li&gt;使用function表达式而不是语句&lt;/li&gt;
&lt;li&gt;js有一套类型的包装对象，应该尽量避免使用基本类型值的包装对象来创建基本类型&lt;/li&gt;
&lt;li&gt;对于js中的对象，一个更好的策略是不使用new（个人感觉没必要）&lt;/li&gt;
&lt;li&gt;避免使用void&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript语言精粹简要笔记&quot;&gt;&lt;a href=&quot;#javascript语言精粹简要笔记&quot; class=&quot;headerlink&quot; title=&quot;javascript语言精粹简要笔记&quot;&gt;&lt;/a&gt;javascript语言精粹简要笔记&lt;/h1&gt;&lt;p&gt;由于个人很喜
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 155~157 天</title>
    <link href="http://archmee.github.io/201612/2016-12-11.html"/>
    <id>http://archmee.github.io/201612/2016-12-11.html</id>
    <published>2016-12-11T05:11:00.000Z</published>
    <updated>2016-12-11T09:18:21.886Z</updated>
    
    <content type="html">&lt;p&gt;在完成任务ife2015任务二中遇到的问题和解决方案：&lt;br&gt;&lt;strong&gt;ps&lt;/strong&gt;：很多和 &lt;a href=&quot;https://github.com/baidu-ife/ife/blob/master/2015_spring/task/task0002/review/IFE-review.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ife review&lt;/a&gt; 重复的地方不再列出&lt;/p&gt;
&lt;h2 id=&quot;util-js&quot;&gt;&lt;a href=&quot;#util-js&quot; class=&quot;headerlink&quot; title=&quot;util.js&quot;&gt;&lt;/a&gt;util.js&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;低版本浏览器没有Array.indexOf方法，使用了&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN的indexOf Polyfill&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;低版本浏览器没有Object.keys方法，也使用了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN的keys Polyfill&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历对象的时候要使用hasDontEnumerBug和propertyIsEnumerable（已解决：用了MDN提供的object.keys的pollyfill）&lt;br&gt;疑：不是用hasOwnProperty方法可以解决吗???&lt;/li&gt;
&lt;li&gt;获取元素在窗口中的位置除了用offsetParent遍历的方法外还有getBoundingClientRect的方法（已解决，直接调用）&lt;/li&gt;
&lt;li&gt;setCookie调用差8个小时，好像UTC的问题(已解决，不用toUTCString()而用toString，在没找到好的解决方案前暂时这样)&lt;/li&gt;
&lt;li&gt;$方法的改进，比如按照属性值匹配那个没有加tag（已解决），比如是否可以采用更优的从右向左扫描(放弃)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;task0003&quot;&gt;&lt;a href=&quot;#task0003&quot; class=&quot;headerlink&quot; title=&quot;task0003&quot;&gt;&lt;/a&gt;task0003&lt;/h2&gt;&lt;h3 id=&quot;轮播图小点li在在父元素ul中水平居中方法&quot;&gt;&lt;a href=&quot;#轮播图小点li在在父元素ul中水平居中方法&quot; class=&quot;headerlink&quot; title=&quot;轮播图小点li在在父元素ul中水平居中方法&quot;&gt;&lt;/a&gt;轮播图小点li在在父元素ul中水平居中方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;父元素text-align:center,子元素要为inline或inline-block&lt;/li&gt;
&lt;li&gt;父元素不用设置，子元素要为block类型，子元素设置margin:0 auto; display:table;&lt;/li&gt;
&lt;li&gt;通过定位，父元素设置相对定位:&lt;ul&gt;
&lt;li&gt;子元素定宽，然后绝对定位，left和right都为0，margin:0 auto;&lt;/li&gt;
&lt;li&gt;子元素定宽，然后绝对定位，{left:50%; margin-left:-50%;} 问题是通常不确定子元素的宽度&lt;/li&gt;
&lt;li&gt;子元素绝对定位，{left:50%; transform:translateX(-50%);}（ie9不兼容）&lt;/li&gt;
&lt;li&gt;父和子之间需要一层包裹wrap，wrap要设置为绝对定位并left:50%; 然后子元素相对定位, 然后left:-50%（注意是负值）（未验证！！！）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;父元素用flex显示，个人还没学过，暂不详解，但兼容性不好&lt;ul&gt;
&lt;li&gt;父元素display:flex，然后justify-content: center;&lt;/li&gt;
&lt;li&gt;父元素display:flex，子元素margin:0 auto;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用以上方法需要定宽的，可以在js运行时获取子元素宽度，然后就好办了&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;轮播图上下一张按钮的垂直居中&quot;&gt;&lt;a href=&quot;#轮播图上下一张按钮的垂直居中&quot; class=&quot;headerlink&quot; title=&quot;轮播图上下一张按钮的垂直居中&quot;&gt;&lt;/a&gt;轮播图上下一张按钮的垂直居中&lt;/h3&gt;&lt;p&gt;绝对定位且是inline-block的a元素要实现在父元素中垂直居中，父元素中vertical-align不起作用，因为vertical-align是对inline元素，line-height设在a上是a的行高，结果是a中的元素垂直居中，而line-height设置在父元素上的话，a由于是绝对定位，所以会出现了a中的文字垂直居中了，而a还在绝对定位的初始位置，这并不是想要的效果。&lt;br&gt;针对绝对定位且定宽高的元素垂直居中，网上找到的解决方案是：&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;rules&quot;&gt;&amp;#123; &lt;span class=&quot;rule&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;top&lt;/span&gt;:&lt;span class=&quot;value&quot;&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;rule&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;bottom&lt;/span&gt;:&lt;span class=&quot;value&quot;&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;rule&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;:&lt;span class=&quot;value&quot;&gt; auto &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;br&gt;通过上两个居中案例得出，如果一个固定宽高绝对定位的block元素要在父元素中水平居中对齐或者垂直居中对齐，可用top和bottom为0(垂直)，left和bottom为0(水平)，或4个方向都为0(水平垂直居中)，并同时使用&lt;code&gt;margin:auto&lt;/code&gt;可实现，当然，如果如果该元素不是绝对定位且定宽高的block元素的话，可使用其他方案（上述中block也包括inline-block）&lt;/p&gt;
&lt;h3 id=&quot;背景透明，文字不透明的解决方案&quot;&gt;&lt;a href=&quot;#背景透明，文字不透明的解决方案&quot; class=&quot;headerlink&quot; title=&quot;背景透明，文字不透明的解决方案&quot;&gt;&lt;/a&gt;背景透明，文字不透明的解决方案&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/PeunZhang/p/4089894.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;来自该文章链接#10楼评论&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;兼容IE，栗如：&lt;br&gt;非IE：&lt;code&gt;background:rgba(0,0,0,0.5);&lt;/code&gt;&lt;br&gt;IE：&lt;code&gt;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#7f000000,endColorstr=#7f000000);&lt;/code&gt;&lt;br&gt;rgba和IE下filter数值的转换：&lt;br&gt;rgba透明值 =&amp;gt; IE filter值&lt;br&gt;0.1 =&amp;gt; 19&lt;br&gt;0.2 =&amp;gt; 33&lt;br&gt;0.3 =&amp;gt; 4C&lt;br&gt;0.4 =&amp;gt; 66&lt;br&gt;0.5 =&amp;gt; 7F&lt;br&gt;0.6 =&amp;gt; 99&lt;br&gt;0.7 =&amp;gt; B2&lt;br&gt;0.8 =&amp;gt; C8&lt;br&gt;0.9 =&amp;gt; E5&lt;br&gt;转换公式：alpha*255再转换成16进制即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意1&lt;/strong&gt;：使用filter的时候background要使用IE不支持的方式，比如rgba，否则话会导致background生效而filter无效&lt;br&gt;&lt;strong&gt;注意2&lt;/strong&gt;：最好和下面提到的兼容样式方法结合起来使用&lt;/p&gt;
&lt;h3 id=&quot;IE6-7的链接虚线外框&quot;&gt;&lt;a href=&quot;#IE6-7的链接虚线外框&quot; class=&quot;headerlink&quot; title=&quot;IE6/7的链接虚线外框&quot;&gt;&lt;/a&gt;IE6/7的链接虚线外框&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/something/archive/2013/05/21/3090428.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;css去掉a标签点击后的虚线框&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;rules&quot;&gt;&amp;#123; &lt;span class=&quot;rule&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;blr&lt;/span&gt;:&lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;function&quot;&gt;expression&lt;/span&gt;(this.onFocus=this.&lt;span class=&quot;function&quot;&gt;blur&lt;/span&gt;())&lt;/span&gt;&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然css表达式不是一种好的方案，但如果和下面提到的兼容样式结合起来就会好很多，至少可以将通用css和兼容特定浏览器的css分开来&lt;/p&gt;
&lt;h3 id=&quot;兼容样式&quot;&gt;&lt;a href=&quot;#兼容样式&quot; class=&quot;headerlink&quot; title=&quot;兼容样式&quot;&gt;&lt;/a&gt;兼容样式&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/PeunZhang/archive/2012/04/09/2437563.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS hack方案整理&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 支持IE6、7 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;media&lt;/span&gt; screen\&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;/*兼容ie67的css*/&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 支持IE8 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;media&lt;/span&gt; \&lt;span class=&quot;number&quot;&gt;0s&lt;/span&gt;creen\ &lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/*兼容ie8的css*/&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 支持IE6、7、8 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;media&lt;/span&gt;  \&lt;span class=&quot;number&quot;&gt;0s&lt;/span&gt;creen\,screen\&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/*兼容ie678的css*/&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;task0004&quot;&gt;&lt;a href=&quot;#task0004&quot; class=&quot;headerlink&quot; title=&quot;task0004&quot;&gt;&lt;/a&gt;task0004&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;监听text/search等文本框的输入时除了要监听input事件还要在ie8及低版本浏览器中监听propertychange事件&lt;/li&gt;
&lt;li&gt;唯独ie9在按删除键时不会触发input或propertychange事件，所以我们直接针对ie9检测keydown事件的keyCode是否是删除键做处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;task0005&quot;&gt;&lt;a href=&quot;#task0005&quot; class=&quot;headerlink&quot; title=&quot;task0005&quot;&gt;&lt;/a&gt;task0005&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;拖动时的文字选中问题，其他浏览器在拖动过程中阻止默认事件即可，而IE拖动时的文字选中，要用setCapture/releaseCapture&lt;/li&gt;
&lt;li&gt;ie7的offset值和其他浏览器不一样，所以用getBoundingClientRect函数获取&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在完成任务ife2015任务二中遇到的问题和解决方案：&lt;br&gt;&lt;strong&gt;ps&lt;/strong&gt;：很多和 &lt;a href=&quot;https://github.com/baidu-ife/ife/blob/master/2015_spring/task/task0002/re
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 124~154 天</title>
    <link href="http://archmee.github.io/201612/2016-12-08.html"/>
    <id>http://archmee.github.io/201612/2016-12-08.html</id>
    <published>2016-12-07T16:00:00.000Z</published>
    <updated>2016-12-11T09:17:06.898Z</updated>
    
    <content type="html">&lt;p&gt;从上次更新博客以来，时间已经过去了一个月，在这一个月当中完成的事情则是相当少，如果非要找个借口的话，那就是今年成都的冬季来地措不及防的早，整个这一个月除了几天少见有太阳，其他时候则全都在阴霾的笼罩之下。而我的行动也因此变得迟缓，哈哈哈哈哈哈哈哈哈哈哈~，不过也并不是完全荒废的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开始看《CSS权威指南》，已经看到了第5章，本来看之前以为这书会像传说中的像字典一样无聊，可是当我真正开始看的时候，才发现并没有，相反让我沉浸在书中对技术的细节描写当中，但是确实这本书不是我的当务之急，所以我还是会放一放&lt;/li&gt;
&lt;li&gt;然后拿起了《JS语言精粹》这本书，目前正在看第5章。&lt;/li&gt;
&lt;li&gt;将上篇博客中提到的IFE2015任务二进行了重(chong)构(xie)，我翻了一下github的提交记录：&lt;ul&gt;
&lt;li&gt;11.20 完成util.js，所以差不多从7号到20这13天都是在修改util.js，在IFE2015任务仓库的提交页面下，我把初级班和中级班的一半人的实现都看了一遍，大部分代码都差不多，但我还是从中搜集了一些好的实现放在了我的代码中。在看别人的代码过程中，我也在思考对比实现孰优孰劣，甚至对于自己有些复杂的实现，都要重新拟清原来的实现思路，因此也发现了以前未发现的一些隐藏Bug&lt;/li&gt;
&lt;li&gt;11.21 调整task0002_1，将原来的内部脚本改为外部脚本文件，并对代码进行了调整，比如原来一个功能全部写在一个函数中完成，现在按照功能单独提出来调用。如果和util.js做的事情有重复的地方改为调用，所以现在task0002的5个小练习都依赖util.js&lt;/li&gt;
&lt;li&gt;11.22 调整task0002_2&lt;/li&gt;
&lt;li&gt;11.24 重构task0002_4&lt;/li&gt;
&lt;li&gt;11.26 更改task0002_5的实现方式使其更简洁优雅 :)&lt;/li&gt;
&lt;li&gt;12.07 完成task0002_3轮播的重构，&lt;a href=&quot;https://archmee.github.io/201608/2016-08-29.html&quot;&gt;以前实现过这个功能并写了篇博客分析实现思路&lt;/a&gt;，而现在花了点时间改用面向对象的思想实现，感觉和组件有点像了：)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是5个小练习的完成效果截图，&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/tree/master/ife_task/ife_task_2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码见github&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提取兴趣爱好（根据输入中的分隔符分割兴趣爱好条目，并创建成可勾选复选框）&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_1.jpg&quot; alt=&quot;提取兴趣爱好&quot;&gt;&lt;/li&gt;
&lt;li&gt;倒计时（计算了每次定时器的产生的误差做误差补偿）&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_2.jpg&quot; alt=&quot;倒计时&quot;&gt;&lt;/li&gt;
&lt;li&gt;轮播图（利用构造器可创建多个轮播，不过每个轮播器需要自定义大小）&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_3.jpg&quot; alt=&quot;轮播图&quot;&gt;&lt;br&gt;（ps：轮播图来自jd.com，侵删)&lt;/li&gt;
&lt;li&gt;输入提示框（类似百度搜索框，不过是本地数据，输入匹配的部分会高亮，方向键上下移动，单击或回车选中）&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_4.jpg&quot; alt=&quot;输入提示框&quot;&gt;&lt;/li&gt;
&lt;li&gt;拖拽界面交互（在有拖动类的容器内任意拖放）&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/task2_5.jpg&quot; alt=&quot;拖拽界面交互&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从上次更新博客以来，时间已经过去了一个月，在这一个月当中完成的事情则是相当少，如果非要找个借口的话，那就是今年成都的冬季来地措不及防的早，整个这一个月除了几天少见有太阳，其他时候则全都在阴霾的笼罩之下。而我的行动也因此变得迟缓，哈哈哈哈哈哈哈哈哈哈哈~，不过也并不是完全荒废
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 117~123 天</title>
    <link href="http://archmee.github.io/201611/2016-11-06.html"/>
    <id>http://archmee.github.io/201611/2016-11-06.html</id>
    <published>2016-11-05T16:00:00.000Z</published>
    <updated>2016-12-11T06:04:42.728Z</updated>
    
    <content type="html">&lt;p&gt;这几天将之前未完成的IFE 2015 任务二完成了，但是代码结构和编程思想都不是很理想，尤其是看了当时IFE团队review了IFE 2015的同学们的代码，指出的一些问题以及改进建议，&lt;a href=&quot;https://github.com/baidu-ife/ife/blob/master/2015_spring/task/task0002/review/IFE-review.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IFE Team review地址&lt;/a&gt;。甚至还给出了&lt;a href=&quot;https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0002/review/demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考代码&lt;/a&gt;，目前为止我只看了util js部分，其他都还没看。&lt;br&gt;我也对自己的代码中有的问题进行了小结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码：完成任务的时候图一时方便，所以css和js都直接写到了相应的标签中而没有单独写到各自的文件中，因为我认为这不是当下最要紧的问题&lt;/li&gt;
&lt;li&gt;编程思想：虽然代码中做到了结构行为样式分离，但是JS代码混成了一团，耦合度高，而且还是完全在使用以前的面向过程的编程思路，连最基本的使用函数分解任务降低耦合度都没有做到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对以上出现的问题，接下来几天想将部分代码进行重构和调整。&lt;br&gt;以下是完成的任务二的小练习1、2、4、5的Demo，之所以没有做小练习3-轮播，是因为我之前做过同样的东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1. 文本框&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2. 倒计时&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_4.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;4. Auto suggestion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_5.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;5. 界面拖拽&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;——2016.12.08更新——-&lt;br&gt;更新：重构了任务2的第3个小练习，地址如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/blob/master/ife_task/ife_task_2/task0002_3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;3. 轮播&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这几天将之前未完成的IFE 2015 任务二完成了，但是代码结构和编程思想都不是很理想，尤其是看了当时IFE团队review了IFE 2015的同学们的代码，指出的一些问题以及改进建议，&lt;a href=&quot;https://github.com/baidu-ife/ife/bl
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 107~116 天</title>
    <link href="http://archmee.github.io/201610/2016-10-30.html"/>
    <id>http://archmee.github.io/201610/2016-10-30.html</id>
    <published>2016-10-29T16:00:00.000Z</published>
    <updated>2016-10-30T13:24:13.665Z</updated>
    
    <content type="html">&lt;p&gt;在25号左右看完了JS《JS高级编程》一书。内容简要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;23 离线应用与客户端缓存&lt;ul&gt;
&lt;li&gt;数据存储：Cookie、sessionStorage、localStorage、IndexedDB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;24 最佳实践&lt;/li&gt;
&lt;li&gt;25 新兴的API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在26号开始刷&lt;a href=&quot;http://www.imooc.com/course/programdetail/pid/32&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;慕课网的前端计划&lt;/a&gt;，但直接跳过了HTML、CSS、JS的初级部分，本想看完DOM事件后完成IFE2015任务二的部分，但是27号下午开始感冒了，28号高烧腰痛难忍不能坐立，甚至下午出去逛超市差不多是挪着步子回来的，本打算第二天去医院挂个急诊，结果29号好多了，本以为痊愈了，但晚上开始口苦鼻塞、头痛欲裂，侧夜难眠，30早上起来整个嘴唇都脱皮了，感觉上火比较严重，但是整个人感觉好多了，下午去药房随便拿了点药了事。我都觉得自己奇怪，病痛都差不多痊愈了才去买药来吃，想来也是因为自己忍受不了去医院挂号的麻烦。&lt;br&gt;接下来希望尽快完成IFE2015任务二&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在25号左右看完了JS《JS高级编程》一书。内容简要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;23 离线应用与客户端缓存&lt;ul&gt;
&lt;li&gt;数据存储：Cookie、sessionStorage、localStorage、IndexedDB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 97~106 天</title>
    <link href="http://archmee.github.io/201610/2016-10-20.html"/>
    <id>http://archmee.github.io/201610/2016-10-20.html</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2016-10-26T14:21:25.034Z</updated>
    
    <content type="html">&lt;p&gt;这10天左右时间从js高程第14章看到了第22章，其中15、16、18、19章只是翻了一下，没有详读，因为html5的api部分，我想等到真正使用的时候再细读，现在只需要了解大概就行了，而XML也不是当务之急，何况现在已经是JSON的天下了。百度IFE2015春季的题目正在做任务2，虽然都是入门开始的，但是感觉题目还是偏难的，如果没有看过js高程这种大部头或者到网上找答案，初学者应该很难完成的，至少只看百度IFE给的资料是没办法完成任务的。&lt;br&gt;章节列表如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;15.使用Canvas绘图&lt;ul&gt;
&lt;li&gt;2D上下文&lt;/li&gt;
&lt;li&gt;WebGL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;16.HTML5脚本编程&lt;ul&gt;
&lt;li&gt;原生拖放&lt;/li&gt;
&lt;li&gt;媒体元素（Audio和Video）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;17.错误处理与调试&lt;/li&gt;
&lt;li&gt;18.Javascript与XML&lt;/li&gt;
&lt;li&gt;19.E4X（ES原生支持XML）&lt;/li&gt;
&lt;li&gt;20.JSON&lt;/li&gt;
&lt;li&gt;21.Ajax与Comet&lt;ul&gt;
&lt;li&gt;XMLHttpRequest对象&lt;/li&gt;
&lt;li&gt;XMLHttpRequest 2级&lt;/li&gt;
&lt;li&gt;进度事件&lt;/li&gt;
&lt;li&gt;跨源资源共享&lt;/li&gt;
&lt;li&gt;图像Ping、JSONP、Comet、Web Sockets 等跨域技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;22.高级技巧&lt;ul&gt;
&lt;li&gt;高级函数（安全的类型检测、作用域安全的构造函数、惰性载入函数、函数绑定、函数柯里化）&lt;/li&gt;
&lt;li&gt;防篡改对象（不可扩展对象、密封的对象、冻结的对象）&lt;/li&gt;
&lt;li&gt;高级定时器（重复的定时器、Yielding Process、函数节流）&lt;/li&gt;
&lt;li&gt;自定义事件&lt;/li&gt;
&lt;li&gt;拖放&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;眼看这本书就要看完了，是时候做点东西再继续看书了，纠结到底是先刷百度IFE2015的任务3呢，还是2016的任务2呢？2015任务3直接开始做一个单页应用，我感觉自己虽然js快学完了，但是要构建这样一个应用还是很困难，当然如果只是基于已有的操作DOM的知识当然能够实现出来，但是这不算一种好的实现方式，在知乎上有人说是看了《基于javascript的MVC富应用开发》这本书才做出来的，也就是说根据我现有的知识储备可能做出来的东西也只是糟糕的实现。而2016的任务2算是开发一些常见的模块化的组件，应该难度会稍微简单一点，但是我只是浏览了一下题目，没有详细看任务要求，难度也不是非常确定。&lt;/p&gt;
&lt;p&gt;下一步要看的书也在计划当中了。。。&lt;br&gt;至于什么时候能找工作，就另说了，至少要完成一个项目后再说吧！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这10天左右时间从js高程第14章看到了第22章，其中15、16、18、19章只是翻了一下，没有详读，因为html5的api部分，我想等到真正使用的时候再细读，现在只需要了解大概就行了，而XML也不是当务之急，何况现在已经是JSON的天下了。百度IFE2015春季的题目正在
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 96 天</title>
    <link href="http://archmee.github.io/201610/2016-10-10.html"/>
    <id>http://archmee.github.io/201610/2016-10-10.html</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2016-10-26T14:20:54.863Z</updated>
    
    <content type="html">&lt;p&gt;今天完成了JS高程的第14章，并且开始做百度前端学院2015任务二：JS部分。&lt;br&gt;看了一篇学习资料 &lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript 的性能优化：加载和执行&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;概要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个文件必须等到前一个文件下载并执行完成才会开始下载。在这些文件逐个下载过程中，用户看到的是一片空白的页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从 IE 8、Firefox 3.5、Safari 4 和 Chrome 2 开始都允许并行下载 JavaScript 文件。这是个好消息，因为&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签在下载外部资源时不会阻塞其他&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签。遗憾的是，JavaScript 下载过程仍然会阻塞其他资源的下载,比如样式文件和图片。尽管脚本的下载过程不会互相影响，但页面仍然必须等待所有 JavaScript 代码下载并执行完成才能继续。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由于脚本会阻塞页面其他资源的下载，因此推荐将所有&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签尽可能放到&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签的底部，以尽量减少对整个页面下载的影响。这是优化 JavaScript 的首要规则：将脚本放在底部。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器在解析 HTML 页面的过程中每遇到一个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，都会因执行脚本而导致一定的延时，因此最小化延迟时间将会明显改善页面的总体性能。所以减少页面包含的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签数量有助于改善这一情况，不管是内嵌的还是外链的。可以把多个文件合并成一个，这样只需要引用一个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，就可以减少性能消耗。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了确保内嵌脚本在执行时能获得最精确的样式信息，建议不要把内嵌脚本紧跟在&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;标签后面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽管下载单个较大的 JavaScript 文件只产生一次 HTTP 请求，却会锁死浏览器的一大段时间。为避免这种情况，需要通过一些特定的技术向页面中逐步加载 JavaScript 文件，这样做在某种程度上来说不会阻塞浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当一个带有 defer 属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与其他资源文件一起并行下载。&lt;br&gt;任何带有 defer 属性的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素在 DOM 完成加载之前都不会被执行，无论内嵌或者是外链脚本都是如此。&lt;br&gt;说明：defer只有 IE 和 Firefox 3.5支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTML 5 为&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签定义了一个新的扩展属性：async。它的作用和 defer 一样，能够异步地加载和执行脚本，不因为加载脚本而阻塞页面的加载。&lt;br&gt;在有 async 的情况下，JS 脚本一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果 JavaScript 脚本前后有依赖性，使用 async 就很有可能出现错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过标准 DOM 函数创建&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素&lt;br&gt;Firefox、Opera, Chorme 和 Safari 3+会在&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;节点接收完成之后发出一个 onload 事件。您可以监听这一事件，以得到脚本准备好的通知。&lt;br&gt;大部分浏览器将按照服务器返回它们的次序下载并运行不同的JS代码文件。您可以将下载操作串联在一起以保证他们的次序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过 XHR 对象加载 JavaScript 脚本最主要的限制是：JavaScript 文件必须与页面放置在同一个域内，不能从 CDN 下载，所以大型网页通常不采用 XHR 脚本注入技术。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文总结：&lt;br&gt;采用阻塞方法加载JS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将所有的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签放到页面底部，也就是闭合标签之前，这能确保在脚本执行前页面已经完成了渲染。&lt;/li&gt;
&lt;li&gt;尽可能地合并脚本。页面中的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用无阻塞下载 JavaScript 脚本的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）或者HTML5添加的async属性；&lt;/li&gt;
&lt;li&gt;使用动态创建的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素来下载并执行代码；&lt;/li&gt;
&lt;li&gt;使用 XHR 对象下载 JavaScript 代码并注入页面中。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天完成了JS高程的第14章，并且开始做百度前端学院2015任务二：JS部分。&lt;br&gt;看了一篇学习资料 &lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/index.html&quot; targe
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 84~95 天</title>
    <link href="http://archmee.github.io/201610/2016-10-09.html"/>
    <id>http://archmee.github.io/201610/2016-10-09.html</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2016-10-26T14:19:24.952Z</updated>
    
    <content type="html">&lt;p&gt;在国庆节前后接近两周的时间学习了JS高程7~13章，第7章还属于比较重要的语法知识，而从第8章开始后面就是BOM和DOM等部分，讲解了大量api的用法，遂不打算一一做笔记了，这里仅仅列一下第7章的纲要&lt;/p&gt;
&lt;h2 id=&quot;7-函数表达式&quot;&gt;&lt;a href=&quot;#7-函数表达式&quot; class=&quot;headerlink&quot; title=&quot;7.函数表达式&quot;&gt;&lt;/a&gt;7.函数表达式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在使用递归调用时，用arguments.callee比使用函数名更保险&lt;/li&gt;
&lt;li&gt;闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数&lt;/li&gt;
&lt;li&gt;闭包会引用包含函数的整个活动对象&lt;/li&gt;
&lt;li&gt;可以用匿名函数模仿块级作用域减少向全局作用域添加过多的变量和函数&lt;/li&gt;
&lt;li&gt;JS用特权方法来访问私有变量和函数&lt;/li&gt;
&lt;li&gt;JS是以对象字面量的方式来创建单例对象的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于这段时间的主要工作，其一是想快点把JS高程刷完，并且同时刷百度前端学院的一些题，书完了之后，就做百度前端学院的大作业，2015春季和2016春季都可以选择&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在国庆节前后接近两周的时间学习了JS高程7~13章，第7章还属于比较重要的语法知识，而从第8章开始后面就是BOM和DOM等部分，讲解了大量api的用法，遂不打算一一做笔记了，这里仅仅列一下第7章的纲要&lt;/p&gt;
&lt;h2 id=&quot;7-函数表达式&quot;&gt;&lt;a href=&quot;#7-函数表
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 78~83 天</title>
    <link href="http://archmee.github.io/201609/2016-09-26.html"/>
    <id>http://archmee.github.io/201609/2016-09-26.html</id>
    <published>2016-09-25T16:00:00.000Z</published>
    <updated>2016-10-26T14:19:11.952Z</updated>
    
    <content type="html">&lt;p&gt;差不多用了一周时间才完成了第6章，感觉大脑开启了暴力模式&lt;/p&gt;
&lt;h2 id=&quot;6-面向对象&quot;&gt;&lt;a href=&quot;#6-面向对象&quot; class=&quot;headerlink&quot; title=&quot;6.面向对象&quot;&gt;&lt;/a&gt;6.面向对象&lt;/h2&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;p&gt;ES中有两种属性：数据属性和访问器属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据属性有4个描述其行为的特性：&lt;ul&gt;
&lt;li&gt;Configurable&lt;/li&gt;
&lt;li&gt;Enumerable&lt;/li&gt;
&lt;li&gt;Writable&lt;/li&gt;
&lt;li&gt;Value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问器属性也有4个特性：&lt;ul&gt;
&lt;li&gt;Configurable&lt;/li&gt;
&lt;li&gt;Enumberable&lt;/li&gt;
&lt;li&gt;Get&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ES5提供了&lt;code&gt;Object.defineProperty()&lt;/code&gt;方法来修改属性默认的特性，&lt;code&gt;Object.defineProperties()&lt;/code&gt;方法可以通过描述符一次定义多个属性，&lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt;方法可以获取给定属性的描述符。&lt;/p&gt;
&lt;h3 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;：在函数里面创建对象并初始化属性和方法，然后返回对象，创建对象直接调用函数即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造函数模式&lt;/strong&gt;：将利用函数是对象的本质，在函数内直接对this进行初始化。缺点是对象的方法没有达到复用的目的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原型模式&lt;/strong&gt;：为了达到复用的目的，将对象属性和方法放进对象原型（object.prototype）中，这样每个对象就共享了属性和方法，而且每个实例可以定义自己专属的属性和方法，且会覆盖原型中的同名属性和方法。注意使用对象字面量语法会重写object.prototype，相当于是使用新对象覆盖了原型对象，导致某些引用关系丢失。这种模式的缺点是对原型对象中的引用类型的操作会共享给所有实例。&lt;br&gt;利用原型对象可以为原生对象添加新方法或重写&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合构造函数模式和原型模式&lt;/strong&gt;：对不需要共享的属性或方法用构造函数来定义，需要共享的属性或方法写进原型对象（推荐）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态原型模式&lt;/strong&gt;：和组合模式类似，只是它把所有信息封装在构造函数中，也在构造函数初始化原型（经检查有必要时）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄生构造函数模式&lt;/strong&gt;：和工厂模式类似，只是在创建对象时不是直接调用函数，而是使用new关键字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳妥构造函数模式&lt;/strong&gt;：和寄生模式类似，区别在：一是没有公共属性， 新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数（这一点又和工厂模式类似）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些有关的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isPrototype()&lt;/code&gt;方法可以确定一个对象实例的原型，&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;返回一个对象的原型&lt;/li&gt;
&lt;li&gt;delete 操作符可以删除实例中定义的属性和方法。&lt;/li&gt;
&lt;li&gt;in 操作符用来确认是否能够访问指定对象的指定属性&lt;/li&gt;
&lt;li&gt;ES5中的&lt;code&gt;Object.keys()&lt;/code&gt;可以获取对象上所有可枚举的实例属性，而&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;方法可以获取所有实例属性，无论它是否可枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原型链&lt;/strong&gt;：使用要继承自的父类型的实例覆盖子类型的原型。所有函数的默认原型都是Object的实例。该种继承方法的缺点：一是父类型的实例属性顺理成章的成了现在对象的原型属性；二是在创建子类型实例时，不能向父类型构造函数传递参数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;借用构造函数&lt;/strong&gt;：方法是在子类型的构造函数内部调用父类型构造函数（用apply或call方法），这下可以传递参数了，但没有解决函数复用的问题，而且父类型的原型对象中的方法对子类型不可见。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合继承&lt;/strong&gt;：将原型链和借用构造函数的技术组合到一块，其背后的思想是使用原型链实现对原型属性和方法的继承。其缺点是在构造函数中和用实例覆盖子类型的原型对象的过程中，调用了2次父类型的构造函数，导致父类型的实例属性有2份，1份在子类型原型对象中，1份在子类型实例中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原型式继承&lt;/strong&gt;：它的实现思路是在函数内借助给定的参数（对象）覆盖函数中一个全新的对象的原型，然后返回这个全新的对象，利用该函数实现了继承，每个实例都可以对自己的属性和方法进行自定义。这个技术和&lt;u&gt;原型继承&lt;/u&gt;的思路差不多，用对象实例去重写子类型的原型，只是它把步骤放到了函数里面，并且是返回了一个被更改过原型的空白对象。&lt;br&gt;  ES5的&lt;code&gt;Object.create()&lt;/code&gt;方法规范化了原型式继承，它用来创建并返回一个继承后的子对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄生式继承&lt;/strong&gt;：是和原型式继承紧密相关的一种方式，但是原型式继承返回的子类型没有任何自定义的属性和方法，所以寄生式继承是完成了二次封装，用来完善子类型的属性和方法。思路是创建一个函数，在函数中调用原型式继承中封装的步骤，然后定义子类型中应有的属性和方法。但是也没有解决方法复用的问题，相当于每个实例中都有一份自己的方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄生组合式继承&lt;/strong&gt;：通过借用构造函数继承来继承属性，通过原型链的混成形式来继承方法。基本思路是：不必为了指定子类型的原型而调用父类型的构造函数，我们需要的只是父类型的原型对象的一个副本而已。只是利用一个中间对象的实例覆盖了子类型的原型对象，而在子类型的构造函数中又调用父类型构造函数以达到继承属性的目的。（最常用最常用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;instanceof 操作符可以测试实例与原型链中出现过的构造函数。&lt;code&gt;isPrototypeOf()&lt;/code&gt;测试调用该方法的原型是否是这个实例(参数)的原型&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;差不多用了一周时间才完成了第6章，感觉大脑开启了暴力模式&lt;/p&gt;
&lt;h2 id=&quot;6-面向对象&quot;&gt;&lt;a href=&quot;#6-面向对象&quot; class=&quot;headerlink&quot; title=&quot;6.面向对象&quot;&gt;&lt;/a&gt;6.面向对象&lt;/h2&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 77 天</title>
    <link href="http://archmee.github.io/201609/2016-09-19.html"/>
    <id>http://archmee.github.io/201609/2016-09-19.html</id>
    <published>2016-09-18T16:00:00.000Z</published>
    <updated>2016-10-26T14:17:49.553Z</updated>
    
    <content type="html">&lt;p&gt;后来想了一下，还是总结一下较好&lt;/p&gt;
&lt;h2 id=&quot;1-JS简介&quot;&gt;&lt;a href=&quot;#1-JS简介&quot; class=&quot;headerlink&quot; title=&quot;1. JS简介&quot;&gt;&lt;/a&gt;1. JS简介&lt;/h2&gt;&lt;p&gt;第1章主要讲了JS的起源和发展历程，以及JS的基本组成情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个完整的JS实现包含三个部分：&lt;ul&gt;
&lt;li&gt;核心（ECMAScript）&lt;/li&gt;
&lt;li&gt;文档对象模型（DOM）&lt;/li&gt;
&lt;li&gt;浏览器对象模型（BOM）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Web浏览器只是ES实现可能的宿主环境之一&lt;/li&gt;
&lt;li&gt;DOM级别&lt;ul&gt;
&lt;li&gt;DOM1级：由2个模块组成，DOM Core和DOM HTML&lt;/li&gt;
&lt;li&gt;DOM2级：引入了更多新模块，在原来DOM的基础上又扩充了鼠标和用户界面事件、范围、遍历等。而且通过对象接口增加了对CSS的支持&lt;/li&gt;
&lt;li&gt;DOM3级：进一步扩展了DOM，引入了以统一方式加载和保存文档的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BOM只处理浏览器和框架&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-在HTML中使用JS&quot;&gt;&lt;a href=&quot;#2-在HTML中使用JS&quot; class=&quot;headerlink&quot; title=&quot;2. 在HTML中使用JS&quot;&gt;&lt;/a&gt;2. 在HTML中使用JS&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素定义了6个属性：&lt;ul&gt;
&lt;li&gt;src：指定要执行的JS文件位置&lt;/li&gt;
&lt;li&gt;charset：JS文件的编码&lt;/li&gt;
&lt;li&gt;async：异步加载脚本，但不依赖引入顺序&lt;/li&gt;
&lt;li&gt;defer：在文档完全被解析和显示之后才执行脚本（立即下载，延迟执行）&lt;/li&gt;
&lt;li&gt;language：已废弃&lt;/li&gt;
&lt;li&gt;type：编写的代码的内容类型，常见&lt;code&gt;&amp;lt;text/javascript&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;不仅可以放在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;里面，还可以放在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;里面（最好是结束标签之前）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文档模式：混杂模式和标准模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;noscript&amp;gt;&lt;/code&gt;用在不支持JS的浏览器中显示替换内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-基本概念&quot;&gt;&lt;a href=&quot;#3-基本概念&quot; class=&quot;headerlink&quot; title=&quot;3. 基本概念&quot;&gt;&lt;/a&gt;3. 基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;标识符：首字符必须是字母、下划线(_)、美元符号($)。其他字符可以是字母、数字、下划线和美元符号&lt;/li&gt;
&lt;li&gt;严格模式：&lt;code&gt;&amp;quot;use strict&amp;quot;&lt;/code&gt;可以放在脚本的开头对整个脚本开启严格模式，也可以放在函数内部让函数在严格模式下执行&lt;/li&gt;
&lt;li&gt;JS代码语句不强制使用&lt;code&gt;;&lt;/code&gt;结束代码，但是建议不要省略&lt;/li&gt;
&lt;li&gt;标识符不能是&lt;strong&gt;关键字&lt;/strong&gt;和&lt;strong&gt;保留字&lt;/strong&gt;（测试时发现标识符可以是汉字，但是不建议使用）&lt;/li&gt;
&lt;li&gt;JS变量是松散类型（弱类型），即可以用来保存任何类型的数据&lt;/li&gt;
&lt;li&gt;JS声明变量使用&lt;code&gt;var&lt;/code&gt;关键字就是局部变量，否则就是全局变量&lt;/li&gt;
&lt;li&gt;可以使用一条语句定义多个变量，用逗号隔开即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-4-数据类型&quot;&gt;&lt;a href=&quot;#3-4-数据类型&quot; class=&quot;headerlink&quot; title=&quot;3.4 数据类型&quot;&gt;&lt;/a&gt;3.4 数据类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ES有5种简单数据类型：&lt;strong&gt;Undefined、Null、Boolean、Number、String&lt;/strong&gt;。还有1种复杂数据类型 &lt;strong&gt;Object&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeof&lt;/code&gt;用来检测数据类型，它是一个操作符而不是函数，所以调用时可以用圆括号也可以不用&lt;/li&gt;
&lt;li&gt;声明变量未初始化值是”undefined”，对于没有声明的变量只能执行typeof检测数据类型，结果是”undefined”&lt;/li&gt;
&lt;li&gt;null表示一个空对象引用，所以执行&lt;code&gt;typeof null;&lt;/code&gt;结果是”object”&lt;/li&gt;
&lt;li&gt;undefined值是派生自null值的，因此相等性测试结果是true&lt;/li&gt;
&lt;li&gt;Boolean类型的true和false是区分大小写的，其他形式的都只是标识符，&lt;code&gt;Boolean()&lt;/code&gt;可以将其他值转换为Boolean值&lt;/li&gt;
&lt;li&gt;保存浮点数需要的内存空间是保存整数值的2倍&lt;/li&gt;
&lt;li&gt;永远不要测试某个特定的浮点数值&lt;/li&gt;
&lt;li&gt;ES能够保存的最大数值保存在Number.MAX_VALUE中，最小数值是Number.MIN_VALUE&lt;/li&gt;
&lt;li&gt;超出JS数值范围的值被自动转换成-Infinite(负无穷)或Infinite(正无穷)，&lt;code&gt;isFinite()&lt;/code&gt;函数可以用来确定一个数值是不是&lt;strong&gt;有穷的&lt;/strong&gt;（在最大和最小之间）&lt;/li&gt;
&lt;li&gt;NaN（Not a Number），这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。NaN与任何值都不相等，包括NaN自身。&lt;code&gt;isNaN()&lt;/code&gt;函数接收到参数后，会尝试将这个值转换为数值，然后确定这个参数是否“不是数值”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number()&lt;/code&gt;、&lt;code&gt;parseInt()&lt;/code&gt;和&lt;code&gt;parseFloat()&lt;/code&gt;可以将非数值转换为数值。parseInt第2个参数可以指定转换时使用的基数&lt;/li&gt;
&lt;li&gt;数值、布尔值、对象和字符串值都有&lt;code&gt;toString()&lt;/code&gt;方法，但null和undefined值没有这个方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String()&lt;/code&gt;方法可以将任何类型的值转换为字符串&lt;/li&gt;
&lt;li&gt;ES中的对象其实是一组数据和功能的集合，Object的每个实例都具有下列属性和方法，由于在ES中Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法&lt;ul&gt;
&lt;li&gt;constructor&lt;/li&gt;
&lt;li&gt;hasOwnProperty(name)&lt;/li&gt;
&lt;li&gt;isPrototypeOf(object)&lt;/li&gt;
&lt;li&gt;propertyIsEnumerable(propertyName)&lt;/li&gt;
&lt;li&gt;toLocalString()&lt;/li&gt;
&lt;li&gt;toString()&lt;/li&gt;
&lt;li&gt;valueOf()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-5-操作符&quot;&gt;&lt;a href=&quot;#3-5-操作符&quot; class=&quot;headerlink&quot; title=&quot;3.5 操作符&quot;&gt;&lt;/a&gt;3.5 操作符&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;相等(==)和不相等(!=)是先转换再比较，全等(===)和不全等(！==)仅比较不转换，作者推荐使用全等和不全等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-6-语句&quot;&gt;&lt;a href=&quot;#3-6-语句&quot; class=&quot;headerlink&quot; title=&quot;3.6 语句&quot;&gt;&lt;/a&gt;3.6 语句&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;label语句可以在代码中添加标签，以便将来使用（比如跳转），通常配合循环语句使用&lt;/li&gt;
&lt;li&gt;with语句的作用是将代码的作用域设置到一个特定的对象中（严格模式不允许使用，且with语句导致性能下降，也不建议使用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-7-函数&quot;&gt;&lt;a href=&quot;#3-7-函数&quot; class=&quot;headerlink&quot; title=&quot;3.7 函数&quot;&gt;&lt;/a&gt;3.7 函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ES函数不介意传递进来多少个参数，也不在乎传递进来的参数是什么数据类型，在函数内部可以通过访问arguments对象来访问这个参数数组&lt;/li&gt;
&lt;li&gt;如果在ES中定义了2个同名函数，则该名字只属于后定义的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-变量、作用域和内存问题&quot;&gt;&lt;a href=&quot;#4-变量、作用域和内存问题&quot; class=&quot;headerlink&quot; title=&quot;4. 变量、作用域和内存问题&quot;&gt;&lt;/a&gt;4. 变量、作用域和内存问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基本类型和引用类型的值&lt;ul&gt;
&lt;li&gt;基本类型占据固定大小的空间，保存在栈内存中；引用类型的值是对象，保存在堆内存中。&lt;/li&gt;
&lt;li&gt;ES中所有参数都是按值传递的&lt;/li&gt;
&lt;li&gt;instanceOf操作符用于识别该变量是否是某个对象的实例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行环境及作用域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个执行环境都有一个与之关联的&lt;strong&gt;变量对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;全局执行环境被认为是window对象&lt;/li&gt;
&lt;li&gt;标识符解析是沿着作用域链一级一级搜索标识符的过程。搜索的过程始终从作用域链的前端开始，然后逐级向后回溯，直到找到标识符为止，如果找到全局执行环境的变量对象还没有找到标识符，就会发生错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行环境的类型只有2种——全局和局部（函数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;catch和with语句可以延长作用域链&lt;/li&gt;
&lt;li&gt;JS没有块级作用域&lt;/li&gt;
&lt;li&gt;垃圾收集通常有2个策略：标记清除和引用计数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;5-引用类型&quot;&gt;&lt;a href=&quot;#5-引用类型&quot; class=&quot;headerlink&quot; title=&quot;5. 引用类型&quot;&gt;&lt;/a&gt;5. 引用类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Object类型&lt;ul&gt;
&lt;li&gt;字面量语法用花括号包围&lt;code&gt;{}&lt;/code&gt;，各属性之间用逗号分隔&lt;/li&gt;
&lt;li&gt;一般用点表示法访问对象属性，也可以使用方括号表示法来访问，作者建议除非必须否则用点表示法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Array类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字面量语法用方括号包围&lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每一项可以保存任意类型的值&lt;/li&gt;
&lt;li&gt;数组大小可动态调整&lt;/li&gt;
&lt;li&gt;使用Array构造函数是，可以省略new操作符&lt;/li&gt;
&lt;li&gt;length属性不是只读的，所以可以使用它调整数组大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array.isArray()&lt;/code&gt;方法用来检查一个参数是否是数组(ES5)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join()&lt;/code&gt;方法用传入的分隔符参数连接字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push()&lt;/code&gt;和&lt;code&gt;pop()&lt;/code&gt;向数组末尾添加和删除元素，类似对栈的操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift()&lt;/code&gt;和&lt;code&gt;unshift()&lt;/code&gt;在数组开始的位置删除和插入元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort()&lt;/code&gt;方法对数组进行排序，传入的参数是比较函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;concat()&lt;/code&gt;方法可以将当前数组和传入的数组参数连接起来创建一个新的数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice()&lt;/code&gt;从当前数组提取一或连续多项创建一个新数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splice()&lt;/code&gt;向数组中插入项，利用参数的组合则可以完成数组的删除替换插入项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;indexOf()&lt;/code&gt;和&lt;code&gt;lastIndexOf()&lt;/code&gt;返回要查找的项在数组中的位置，没找到则返回-1。这两个方法的不同在于一个是顺序查找，一个是逆序查找&lt;/li&gt;
&lt;li&gt;&lt;code&gt;every()&lt;/code&gt;、&lt;code&gt;filter()&lt;/code&gt;、&lt;code&gt;forEach()&lt;/code&gt;、&lt;code&gt;map()&lt;/code&gt;、&lt;code&gt;some()&lt;/code&gt;都是用来迭代数组的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduce()&lt;/code&gt;和&lt;code&gt;reduceRight()&lt;/code&gt;是用来归并数组的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Date类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Date.parse()&lt;/code&gt;返回日期字符串参数的毫秒数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Date.UTC()&lt;/code&gt;也返回表示日期的毫秒数，但是和parse参数不同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Date.now()&lt;/code&gt;返回当前时间的毫秒数&lt;/li&gt;
&lt;li&gt;Date类型还有一些专门用于将日期格式化为字符串的方法：&lt;code&gt;toDateString()&lt;/code&gt;、&lt;code&gt;toTimeString()&lt;/code&gt;、&lt;code&gt;toLocaleDateString()&lt;/code&gt;、&lt;code&gt;toLocaleTimeString()&lt;/code&gt;、&lt;code&gt;toUTCString&lt;/code&gt;，更多的日期时间方法可以看书&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RegExp类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正则表达式的字面量语法：&lt;br&gt;&lt;code&gt;var express = /pattern/flags;&lt;/code&gt;&lt;br&gt;flags有3个值，可配合使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;g: 表示全局模式&lt;/li&gt;
&lt;li&gt;i: 表示不区分大小写&lt;/li&gt;
&lt;li&gt;m: 表示多行模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RegExp每个实例都有下列属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;global：表示是否设置了g标志&lt;/li&gt;
&lt;li&gt;ignoreCase：表示是否设置了i标志&lt;/li&gt;
&lt;li&gt;lastIndex：表示开始搜索下一个匹配项的字符位置，从0算起:&lt;/li&gt;
&lt;li&gt;multiline：表示是否设置了m标志&lt;/li&gt;
&lt;li&gt;source：正则表达式的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RegExp实例方法&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test()&lt;/code&gt;方法测试参数字符串是否匹配正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt;方法接受一个字符串参数，返回第一个匹配项信息的数组，但包含两个额外的属性：index和input，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RegExp构造函数属性：input、lastMatch、lastParen、leftContext、rightContext、multiline&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Function类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数实际上是对象&lt;/li&gt;
&lt;li&gt;函数没有重载，因为函数名称只是一个变量，函数同名就像变量同名会被覆盖一样。&lt;/li&gt;
&lt;li&gt;函数可以作为值来使用，所以也可以用作函数参数，也可以将函数当作结果返回&lt;/li&gt;
&lt;li&gt;函数内部有两个特殊对象：arguments和this，arguments对象中还有一个名叫callee的属性，它是一个指针，指向拥有这个arguments对象的函数。ES5还有另一个函数对象的属性：caller，它保存着调用当前函数的函数的引用&lt;/li&gt;
&lt;li&gt;每个函数都包含两个属性：length和prototype，length表示函数希望接收的命名参数的个数，prototype是保存它们所在实例方法的真正所在&lt;br&gt;  每个函数都包含两个非继承而来的方法：&lt;code&gt;apply()&lt;/code&gt;和&lt;code&gt;call()&lt;/code&gt;，这两个方法都是在指定的作用域中调用函数，实际上等于设置函数体内this对象的值。&lt;br&gt;  ES5还定义了一个方法&lt;code&gt;bind()&lt;/code&gt;，这个方法会创建一个函数实例，其this值会被绑定到传给bind()的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基本包装类型&lt;br&gt;ES还定义了3个特殊的引用类型：Boolean、Number和String，它们是基本类型值的基本包装类型对象。不建议显示创建基本包装类型的对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String类型&lt;ul&gt;
&lt;li&gt;字符方法：&lt;code&gt;charAt()&lt;/code&gt;和&lt;code&gt;charCodeAt()&lt;/code&gt;用来访问特定字符&lt;/li&gt;
&lt;li&gt;字符串操作方法：&lt;code&gt;concat()&lt;/code&gt;和&lt;code&gt;+&lt;/code&gt;可以实现连接字符串。&lt;code&gt;slice()&lt;/code&gt;、&lt;code&gt;substr()&lt;/code&gt;、&lt;code&gt;substring()&lt;/code&gt;都是提取子字符串创建新字符串的方法&lt;/li&gt;
&lt;li&gt;字符串位置方法：&lt;code&gt;indexOf()&lt;/code&gt;和&lt;code&gt;lastIndexOf()&lt;/code&gt;可以从字符串中查找子字符串的位置&lt;/li&gt;
&lt;li&gt;去除前后空格：&lt;code&gt;trim()&lt;/code&gt;会创建一个字符串的副本，删除前后空格并返回。&lt;/li&gt;
&lt;li&gt;大小写转换：&lt;code&gt;toLowerCase()&lt;/code&gt;、&lt;code&gt;toUpperCase()&lt;/code&gt;、&lt;code&gt;toLocaleLowerCase()&lt;/code&gt;、&lt;code&gt;toLocaleUpperCase()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;模式匹配：&lt;br&gt;&lt;code&gt;match()&lt;/code&gt;接收正则表达式为参数，本质上和调用RegExp的exec方法差不多。&lt;br&gt;&lt;code&gt;search()&lt;/code&gt;返回字符串中第一个匹配项的索引。&lt;br&gt;&lt;code&gt;replace()&lt;/code&gt;方法用于替换字符串匹配项。&lt;br&gt;&lt;code&gt;split()&lt;/code&gt;基于特定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。&lt;br&gt;&lt;code&gt;localeCompare()&lt;/code&gt;用于比较字符串。&lt;br&gt;&lt;code&gt;fromCharCode()&lt;/code&gt;是一个静态方法，它接收一个或多个字符编码，并将它转换成一个字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单体内置对象&lt;br&gt;定义：由ES实现提供的，不依赖于宿主环境的对象，这些对象在ES程序执行之前就已经存在了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Global对象：不属于任何其他对象的属性和方法，最终都是它的属性和方法。所有全局作用域中定义的属性和函数，都是Global对象的属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URI编解码方法：&lt;code&gt;encodeURI()&lt;/code&gt;和&lt;code&gt;encodeURIComponent()&lt;/code&gt;可以对URI进行编码。&lt;code&gt;decodeURI()&lt;/code&gt;和&lt;code&gt;decodeURIComponent()&lt;/code&gt;是对应的解码方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval()&lt;/code&gt;将传入字符串当做实际JS语句来解析&lt;/li&gt;
&lt;li&gt;。。。还有其他Global对象的属性。。。&lt;/li&gt;
&lt;li&gt;window对象，Web浏览器都是讲Global对象作为window对象的一部分加以实现的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Math对象：它提供的计算功能比我们自己编写的计算功能执行起来要快得多&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含的属性都是数学计算中常用的特殊值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min()&lt;/code&gt;和&lt;code&gt;max()&lt;/code&gt;方法用于确定一组数值中的最大值和最小值&lt;/li&gt;
&lt;li&gt;舍入方法：&lt;code&gt;ceil()&lt;/code&gt;、&lt;code&gt;floor()&lt;/code&gt;、&lt;code&gt;round()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;random()&lt;/code&gt;方法返回0~1之间的随机数&lt;/li&gt;
&lt;li&gt;还有很多完成简单或复杂计算的方法：&lt;code&gt;pow()&lt;/code&gt;、&lt;code&gt;sqrt()&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;6-面向对象&quot;&gt;&lt;a href=&quot;#6-面向对象&quot; class=&quot;headerlink&quot; title=&quot;6.面向对象&quot;&gt;&lt;/a&gt;6.面向对象&lt;/h2&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;p&gt;ES中有两种属性：数据属性和访问器属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据属性有4个描述其行为的特性：&lt;ul&gt;
&lt;li&gt;Configurable&lt;/li&gt;
&lt;li&gt;Enumerable&lt;/li&gt;
&lt;li&gt;Writable&lt;/li&gt;
&lt;li&gt;Value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问器属性也有4个特性：&lt;ul&gt;
&lt;li&gt;Configurable&lt;/li&gt;
&lt;li&gt;Enumberable&lt;/li&gt;
&lt;li&gt;Get&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ES5提供了&lt;code&gt;Object.defineProperty()&lt;/code&gt;方法来修改属性默认的特性，&lt;code&gt;Object.defineProperties()&lt;/code&gt;方法可以通过描述符一次定义多个属性，&lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt;方法可以获取给定属性的描述符。&lt;/p&gt;
&lt;h3 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;：在函数里面创建对象并初始化属性和方法，然后返回对象，创建对象直接调用函数即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造函数模式&lt;/strong&gt;：将利用函数是对象的本质，在函数内直接对this进行初始化。缺点是对象的方法没有达到复用的目的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原型模式&lt;/strong&gt;：为了达到复用的目的，将对象属性和方法放进对象原型（object.prototype）中，这样每个对象就共享了属性和方法，而且每个实例可以定义自己专属的属性和方法，且会覆盖原型中的同名属性和方法。注意使用对象字面量语法会重写object.prototype，相当于是使用新对象覆盖了原型对象，导致某些引用关系丢失。这种模式的缺点是对原型对象中的引用类型的操作会共享给所有实例。&lt;br&gt;利用原型对象可以为原生对象添加新方法或重写&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合构造函数模式和原型模式&lt;/strong&gt;：对不需要共享的属性或方法用构造函数来定义，需要共享的属性或方法写进原型对象（推荐）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态原型模式&lt;/strong&gt;：和组合模式类似，只是它把所有信息封装在构造函数中，也在构造函数初始化原型（经检查有必要时）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄生构造函数模式&lt;/strong&gt;：和工厂模式类似，只是在创建对象时不是直接调用函数，而是使用new关键字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳妥构造函数模式&lt;/strong&gt;：和寄生模式类似，区别在：一是没有公共属性， 新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数（这一点又和工厂模式类似）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些有关的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isPrototype()&lt;/code&gt;方法可以确定一个对象实例的原型，&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;返回一个对象的原型&lt;/li&gt;
&lt;li&gt;delete 操作符可以删除实例中定义的属性和方法。&lt;/li&gt;
&lt;li&gt;in 操作符用来确认是否能够访问指定对象的指定属性&lt;/li&gt;
&lt;li&gt;ES5中的&lt;code&gt;Object.keys()&lt;/code&gt;可以获取对象上所有可枚举的实例属性，而&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;方法可以获取所有实例属性，无论它是否可枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原型链&lt;/strong&gt;：使用要继承自的父类型的实例覆盖子类型的原型。所有函数的默认原型都是Object的实例。该种继承方法的缺点：一是父类型的实例属性顺理成章的成了现在对象的原型属性；二是在创建子类型实例时，不能向父类型构造函数传递参数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;借用构造函数&lt;/strong&gt;：方法是在子类型的构造函数内部调用父类型构造函数（用apply或call方法），这下可以传递参数了，但没有解决函数复用的问题，而且父类型的原型对象中的方法对子类型不可见。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合继承&lt;/strong&gt;：将原型链和借用构造函数的技术组合到一块，其背后的思想是使用原型链实现对原型属性和方法的继承。其缺点是在构造函数中和用实例覆盖子类型的原型对象的过程中，调用了2次父类型的构造函数，导致父类型的实例属性有2份，1份在子类型原型对象中，1份在子类型实例中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原型式继承&lt;/strong&gt;：它的实现思路是在函数内借助给定的参数（对象）覆盖函数中一个全新的对象的原型，然后返回这个全新的对象，利用该函数实现了继承，每个实例都可以对自己的属性和方法进行自定义。这个技术和&lt;u&gt;原型继承&lt;/u&gt;的思路差不多，用对象实例去重写子类型的原型，只是它把步骤放到了函数里面，并且是返回了一个被更改过原型的空白对象。&lt;br&gt;  ES5的&lt;code&gt;Object.create()&lt;/code&gt;方法规范化了原型式继承，它用来创建并返回一个继承后的子对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄生式继承&lt;/strong&gt;：是和原型式继承紧密相关的一种方式，但是原型式继承返回的子类型没有任何自定义的属性和方法，所以寄生式继承是完成了二次封装，用来完善子类型的属性和方法。思路是创建一个函数，在函数中调用原型式继承中封装的步骤，然后定义子类型中应有的属性和方法。但是也没有解决方法复用的问题，相当于每个实例中都有一份自己的方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄生组合式继承&lt;/strong&gt;：通过借用构造函数继承来继承属性，通过原型链的混成形式来继承方法。基本思路是：不必为了指定子类型的原型而调用父类型的构造函数，我们需要的只是父类型的原型对象的一个副本而已。只是利用一个中间对象的实例覆盖了子类型的原型对象，而在子类型的构造函数中又调用父类型构造函数以达到继承属性的目的。（最常用最常用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有关方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;instanceof 操作符可以测试实例与原型链中出现过的构造函数。&lt;code&gt;isPrototypeOf()&lt;/code&gt;测试调用该方法的原型是否是这个实例(参数)的原型&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;后来想了一下，还是总结一下较好&lt;/p&gt;
&lt;h2 id=&quot;1-JS简介&quot;&gt;&lt;a href=&quot;#1-JS简介&quot; class=&quot;headerlink&quot; title=&quot;1. JS简介&quot;&gt;&lt;/a&gt;1. JS简介&lt;/h2&gt;&lt;p&gt;第1章主要讲了JS的起源和发展历程，以及JS的基本组成情况
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 69~76 天</title>
    <link href="http://archmee.github.io/201609/2016-09-18.html"/>
    <id>http://archmee.github.io/201609/2016-09-18.html</id>
    <published>2016-09-17T16:00:00.000Z</published>
    <updated>2016-10-26T14:16:24.775Z</updated>
    
    <content type="html">&lt;p&gt;时逢中秋佳节，又废了3天&lt;br&gt;这几天学习了JS高级编程前5章，想法是尽快刷一遍全书，再开始做小东西&lt;br&gt;但是这本书没有做笔记，原因是书上讲得足够详细了，在抄一遍浪费时间用处不大，不过可以一段时间回顾一下，做点摘要性质的知识点大纲&lt;br&gt;。。。&lt;br&gt;居然没什么写的了，剩下的当作留白吧！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;时逢中秋佳节，又废了3天&lt;br&gt;这几天学习了JS高级编程前5章，想法是尽快刷一遍全书，再开始做小东西&lt;br&gt;但是这本书没有做笔记，原因是书上讲得足够详细了，在抄一遍浪费时间用处不大，不过可以一段时间回顾一下，做点摘要性质的知识点大纲&lt;br&gt;。。。&lt;br&gt;居然没什么写的了，剩
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 57~68 天</title>
    <link href="http://archmee.github.io/201609/2016-09-10.html"/>
    <id>http://archmee.github.io/201609/2016-09-10.html</id>
    <published>2016-09-09T16:00:00.000Z</published>
    <updated>2016-12-13T15:02:01.313Z</updated>
    
    <content type="html">&lt;p&gt;这段时间多是荒废了的，所以做的事情不多，把《精通CSS》看完了，剩余的两章都是项目的实现，我分析了示例中的代码，但没发觉什么新东西，所以笔记也省略了&lt;/p&gt;
&lt;p&gt;再来中途参加了朋友的婚礼，耽搁了点时间&lt;/p&gt;
&lt;p&gt;继续学习智能社的JS视频教程，发现这个老师讲得挺好，他基本很少讲直接得理论知识，都是根据循序渐进的列子来带出知识点，并且讲解了当下很实用的一些网页效果，比如缓冲运动、焦点图滚动、淡入淡出，当然这个视频可能对JS学习并不完善，但是对于学习DOM编程入门挺好的，一边学可以一边实现常见的网页效果，会更有学习上的成就感。&lt;br&gt;而且现在根据他讲的内容对之前徒手撸的轮播图有了改进的想法，可以使其更完善。&lt;br&gt;准备明天开始刷JS高级编程，争取开启暴走模式&lt;/p&gt;
&lt;p&gt;上一篇博客后模仿了慕课网首页的导航效果，我只是实现了静态效果，轮播图没有做，不过是把以前写的代码融合进来，下面放上效果截图和DEMO：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2016-09-11_004601.jpg&quot; alt=&quot;模仿慕课首页导航&quot;&gt;&lt;/p&gt;
&lt;script async src=&quot;https://jsfiddle.net/wnxh0ujj/embed/result,html,css,js/&quot;&gt;&lt;/script&gt;

</content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间多是荒废了的，所以做的事情不多，把《精通CSS》看完了，剩余的两章都是项目的实现，我分析了示例中的代码，但没发觉什么新东西，所以笔记也省略了&lt;/p&gt;
&lt;p&gt;再来中途参加了朋友的婚礼，耽搁了点时间&lt;/p&gt;
&lt;p&gt;继续学习智能社的JS视频教程，发现这个老师讲得挺好，他基
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 55、56 天</title>
    <link href="http://archmee.github.io/201608/2016-08-29.html"/>
    <id>http://archmee.github.io/201608/2016-08-29.html</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2016-08-29T16:07:37.668Z</updated>
    
    <content type="html">&lt;p&gt;最近在看智能社的JS视频教程，这两天学习了无缝滚动效果的实现，心想着感觉和轮播效果差不多，一冲动就徒手撸了一个图片轮播效果，其实两种东西差远了，如果非要说它们之间有什么关系的话，就是都要用JS&lt;/p&gt;
&lt;p&gt;哈哈哈.gif&lt;/p&gt;
&lt;p&gt;不过先声明，在实现这个轮播效果以前，只是在其他网站看过这种效果，并没有了解过技术上是怎么实现的，所以这里的轮播效果完全是按照自己的思路强撸的，bug。。。暂时没有，但不完善，也不算什么好的实践。&lt;/p&gt;
&lt;p&gt;下面是我的大概思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先html结构要一个图片列表，但用css全部隐藏。有切换上一张和下一张图片的按钮&lt;/li&gt;
&lt;li&gt;文档加载完成后，js取出图片列表，然后显示第1张图片&lt;/li&gt;
&lt;li&gt;创建图片上的那一排可以切换图片的小圆点，用ul生成，li个数取决于上一步列表长度，每个li嵌套一个a元素，并且将第一个小圆点添加到事先写好的css类，使其有激活的效果&lt;/li&gt;
&lt;li&gt;在生成li中a元素时，为每个a绑定onmouseover和onclick事件，在onmouseover时，保持原有游标和定时器，这里只是简单的将图片切换到当前图片，定时器时间到了，原来计算好的下一张图片是谁，现在还是切换谁。而onclick不一样，它首先会清除原有定时器，然后隐藏原有图片，修改游标值，淡入显示当前图片，并且启动定时器，保证切换的下一张图片是当前图片紧邻的下一张，而不是其他，其实这一个和自动切换图片代码是一样的，只是改了游标的值&lt;/li&gt;
&lt;li&gt;启动定时器（上一步中的定时器要点击事件发生时才会启动的），间隔多少秒后，开始自动切换下一张图片（目前没见过自动切换上一张）。刚开始我用的setInterval，后面发现如果切换的地方多了后，定时器之间有干扰，后面改为setTimeout，每次切换下一张，再次启动就ok了&lt;/li&gt;
&lt;li&gt;切换时，先取消小圆点的激活效果，再隐藏当前图片，然后移动游标位置，再显示下一张图片以及激活下一个小圆点&lt;/li&gt;
&lt;li&gt;在切换下一张图片时，加一点淡入效果，显得不那么突兀。淡入效果是我自己写的，设置一个初始的opacity，用setInterval定时器，渐变到1就ok了，淡出的话思路不变，opcity逐渐减小即可&lt;/li&gt;
&lt;li&gt;两个按钮分别绑定onclick事件，和切换下一张图片思路一样，只是这次变成手动切换而已，上一张就是把游标位置减1，并且判断是否小于0，小于0的话，要像求余数一样从倒数的位置开始了。下一张也要判断位置，如果超过列表长度，就要取余数并更新游标，自动切换时也要走这一步&lt;/li&gt;
&lt;li&gt;更复杂的切换效果还做不了，so……暂时到此为止……&lt;/li&gt;
&lt;li&gt;忘了提，小圆点上的onmouseover效果不是很理想，原因未知，所以先注释掉了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是最终效果截图和Demo&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2016-08-29_235232.jpg&quot; alt=&quot;轮播效果截图&quot;&gt;&lt;/p&gt;
&lt;script async src=&quot;https://jsfiddle.net/ycssuxpj/embed/result,html,css,js/&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;ps：图片来自网络，侵删。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看智能社的JS视频教程，这两天学习了无缝滚动效果的实现，心想着感觉和轮播效果差不多，一冲动就徒手撸了一个图片轮播效果，其实两种东西差远了，如果非要说它们之间有什么关系的话，就是都要用JS&lt;/p&gt;
&lt;p&gt;哈哈哈.gif&lt;/p&gt;
&lt;p&gt;不过先声明，在实现这个轮播效果以前，
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 41~54 天</title>
    <link href="http://archmee.github.io/201608/2016-08-27.html"/>
    <id>http://archmee.github.io/201608/2016-08-27.html</id>
    <published>2016-08-26T16:00:00.000Z</published>
    <updated>2016-10-26T14:15:24.705Z</updated>
    
    <content type="html">&lt;p&gt;距离上一次更新博客已经时隔2周，这两周我在干嘛呢，主要是做了个播放器页面，看了《精通CSS》3~9章，以及开始学习智能社的js基础视频教程，所以下面主要整理了我看书的学习笔记。&lt;br&gt;速度这么慢，鬼知道我这两周经历了什么？？？&lt;/p&gt;
&lt;h2 id=&quot;3-可视化格式模型&quot;&gt;&lt;a href=&quot;#3-可视化格式模型&quot; class=&quot;headerlink&quot; title=&quot;3. 可视化格式模型&quot;&gt;&lt;/a&gt;3. 可视化格式模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;背景会应用于由内容和内边距组成的区域，外边距是透明的，一般使用它控制元素之间的间隔&lt;/li&gt;
&lt;li&gt;outline和border不同的是，它绘制在元素框之上，所以它们不影响元素的大小或者布局&lt;/li&gt;
&lt;li&gt;增加padding、border、margin不会影响内容区域的尺寸，但是会增加元素框的总尺寸&lt;/li&gt;
&lt;li&gt;&lt;p&gt;外边距叠加&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当两个或更多垂直外边距相遇时，它们将保留一个较大外边距&lt;/li&gt;
&lt;li&gt;当A元素嵌入在B元素中时，如果B元素没有边框或内边距将两个元素的外边距分隔开，它们垂直方向的外边距也会叠加，并保留一个较大外边距&lt;/li&gt;
&lt;li&gt;当一个元素为空（没有任何内容），这个元素本身的垂直外边距也会发生叠加，并保留一个较大外边距&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;只有普通文档流中块框的垂直外边距才会发生叠加，行内框、浮动框、绝对定位框等内联、内联块元素之间的外边距不会发生叠加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;块级框&lt;/strong&gt;从上到下一个接一个地垂直排列，框之间的的垂直距离由框的垂直外边距计算出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;行内框&lt;/strong&gt;在一行中水平排列，可以使用水平方向的内边距、边框和外边距调整它们的水平间距，但是垂直方向的内边距、行框、外边距不影响行内框的高度。同样，在行内框上设置显示高度或宽度也没有影响&lt;br&gt;由一行形成的水平框称为行框，行框的高度总是足以容纳它包含的所有行内框，但是，设置行高可以增加这个框的高度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;相对定位&lt;/strong&gt;：如果对一个元素进行相对定位，它将出现在它原来所在的位置，然后可以设置垂直和水平偏移，让这个元素相对于它的起点移动，在使用相对定位时，无论是否移动，元素仍然占据原来的空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绝对定位&lt;/strong&gt;：绝对定位使位置与文档流无关，因此不占据空间，普通文档流中其他元素的布局会忽略该元素的存在。绝对定位元素的位置是相对于距离它最近的那个已定位的祖先元素确定的，如果没有已定位祖先元素，那么它的位置是相对于初始包含块的。根据用户代理的不同，初始包含块可能是画布或HTML元素&lt;/li&gt;
&lt;li&gt;因为绝对定位元素的框与文档流无关，所以它们可能会覆盖文档流中的其他元素，可以通过z-index属性来控制这些框的叠放次序，值越高，就越层次越高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;固定定位&lt;/strong&gt;：固定定位是绝对定位的一种，差异在于固定元素的包含块是视口(viewport)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浮动的框可以左右移动，直到它的外边缘碰到包含框或另一个浮动框的边缘。因为浮动框不在普通文档流中，所以普通文档流中的块框表现得就像浮动框不存在一样。但是，块框中的内联元素受到浮动元素的影响，会移动给浮动元素留出空间。&lt;br&gt;对元素进行清理实际上是为前面的浮动元素留出垂直空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;overflow属性定义包含的内容对于指定的尺寸太大的情况下元素应该怎么样。应用值为hidden或auto的overflow属性有一个很有用的副作用，它会自动地清理包含的任何浮动元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-背景图像效果&quot;&gt;&lt;a href=&quot;#4-背景图像效果&quot; class=&quot;headerlink&quot; title=&quot;4. 背景图像效果&quot;&gt;&lt;/a&gt;4. 背景图像效果&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用像素设置背景图像位置，那么图像左上角到元素左上角的距离就是指定的像素数。但使用百分比进行背景定位的工作方式不太一样，百分数定位并不对背景图像的左上角进行定位，而是使用图像左上角上对应的百分比作为对应点，再从对应点到元素左上角进行定位。&lt;/li&gt;
&lt;li&gt;混合使用关键字（如left、top等）和单位（像素、百分比）在某些浏览器中会导致错误，而且可能使css失效&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-2-圆角框&quot;&gt;&lt;a href=&quot;#4-2-圆角框&quot; class=&quot;headerlink&quot; title=&quot;4.2 圆角框&quot;&gt;&lt;/a&gt;4.2 圆角框&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;固定宽度的圆角框&lt;br&gt; 需要顶部和底部两个圆角图片，可垂直扩展，这种只适用于宽度固定且单色的框。要想实现水平和垂直都可扩展的圆角，可用四个角的圆角图片来实现，且需要增加额外的html标记，在水平方向的扩展也很有局限性&lt;/li&gt;
&lt;li&gt;山顶角&lt;br&gt; 使用位图角蒙版，白色蒙版将覆盖背景色，产生简单的曲线效果，但是仍然要添加无意义标记&lt;/li&gt;
&lt;li&gt;CSS 3 允许&lt;strong&gt;使用多个背景图像&lt;/strong&gt;，使用background-image指定多个图像，然后用其他几个属性指定想要的位置、是否重复等属性，而且现在不能使用简写background的形式，必须在各个属性中分别指定&lt;/li&gt;
&lt;li&gt;CSS 3 新增了&lt;strong&gt;border-radius&lt;/strong&gt;属性来绘制边框效果&lt;/li&gt;
&lt;li&gt;CSS 3 新增了&lt;strong&gt;border-image&lt;/strong&gt;属性，该属性允许指定一个图像作为边框&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;4-3-投影&quot;&gt;&lt;a href=&quot;#4-3-投影&quot; class=&quot;headerlink&quot; title=&quot;4.3 投影&quot;&gt;&lt;/a&gt;4.3 投影&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;简单的CSS投影，使用专门制作的投影图像应用于元素背景，然后负偏移元素框使其达到阴影效果&lt;/li&gt;
&lt;li&gt;CSS 3 支持 box-shadow直接创建投影，还可以和border-radius相互配合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-4-不透明度&quot;&gt;&lt;a href=&quot;#4-4-不透明度&quot; class=&quot;headerlink&quot; title=&quot;4.4 不透明度&quot;&gt;&lt;/a&gt;4.4 不透明度&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;opacity，取值范围0~1，值越大越不透明，除了背景会生效外，应用它的元素的内容也会继承它，导致内容产生不透明度，这不是理想的效果&lt;/li&gt;
&lt;li&gt;RGBa，a代表alpha透明度&lt;/li&gt;
&lt;li&gt;PNG透明度，png图像格式最大的优点是它支持alpha透明度&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;4-5-图像替换&quot;&gt;&lt;a href=&quot;#4-5-图像替换&quot; class=&quot;headerlink&quot; title=&quot;4.5 图像替换&quot;&gt;&lt;/a&gt;4.5 图像替换&lt;/h3&gt;&lt;p&gt;由于不愿意将这些某些图像直接嵌入页面中，CSS作者发明了图像替换技术的概念。你可以像平常一样将文本添加到文档中，然后使用CSS隐藏文本并在它的位置上显示一个背景图像。这样的话，搜索引擎仍然可以搜索HTML文本，而且如果禁用CSS，文本仍然会显示。&lt;br&gt;后来发展了FIR（display:none OR visibility:none）、Phark（text-indent:-9999）、sFIR（flash技术和js）等图像替换方法&lt;/p&gt;
&lt;p&gt;ps：下面的章节示例比较多，我并不打算照搬代码，所以只是记录了一些关键点&lt;/p&gt;
&lt;h2 id=&quot;5-对链接应用样式&quot;&gt;&lt;a href=&quot;#5-对链接应用样式&quot; class=&quot;headerlink&quot; title=&quot;5. 对链接应用样式&quot;&gt;&lt;/a&gt;5. 对链接应用样式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对链接伪类应用样式顺序：link、visited、hover、focus、active&lt;/li&gt;
&lt;li&gt;:target伪类可以为目标元素设置样式&lt;/li&gt;
&lt;li&gt;绝不要使用链接更新服务器，或者用技术术语来说，链接应该只用于GET请求，绝不要用于POST请求&lt;/li&gt;
&lt;li&gt;Pixy样式的翻转：不切换多个图像，而是使用一个图像并切换它的背景位置。使用单个图像的好处是减少了服务器请求的数量。&lt;/li&gt;
&lt;li&gt;CSS精灵是更彻底的Pixy技术，它把所有图标都放在一张或几张图片上，通过切换位置来应用图像&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;6-对列表应用样式和创建导航条&quot;&gt;&lt;a href=&quot;#6-对列表应用样式和创建导航条&quot; class=&quot;headerlink&quot; title=&quot;6. 对列表应用样式和创建导航条&quot;&gt;&lt;/a&gt;6. 对列表应用样式和创建导航条&lt;/h2&gt;&lt;p&gt;主要讲了创建垂直导航条和水平导航条的技术，以及如何创建圆角按钮样式的链接，和鼠标移入的翻转效果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;制作水平导航条，一般是把列表元素显示为内联元素或者使其浮动&lt;/li&gt;
&lt;li&gt;有几种方法可以让父元素包含浮动的子元素。一个是添加一个进行清理的元素，但这会在页面中增加不必要的标记。另一种是让父元素浮动，并且使用某个元素（比如页脚）对它进行清理。第三种是用overflow:hidden技术，它产生的副作用会解决这个问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;7-对表单和数据表格应用样式&quot;&gt;&lt;a href=&quot;#7-对表单和数据表格应用样式&quot; class=&quot;headerlink&quot; title=&quot;7. 对表单和数据表格应用样式&quot;&gt;&lt;/a&gt;7. 对表单和数据表格应用样式&lt;/h2&gt;&lt;h3 id=&quot;表格&quot;&gt;&lt;a href=&quot;#表格&quot; class=&quot;headerlink&quot; title=&quot;表格&quot;&gt;&lt;/a&gt;表格&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;尽量避免使用表格来布局&lt;/li&gt;
&lt;li&gt;&lt;p&gt;表格特有的元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;caption：用于表格标题，样式caption-side决定了它显示在表格四周的位置&lt;/li&gt;
&lt;li&gt;sumary：应用于表格标签，用来描述表格的内容&lt;/li&gt;
&lt;li&gt;thead、tbody、tfoot：thead和tfoot只有1个，而tbody可以有多个&lt;/li&gt;
&lt;li&gt;col和colgroup：colgroup可以使用col元素对一或多列定义和分组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;border-collapse决定了表格单元格边框。collapse则水平垂直都合并，separte是默认值，即分别使用自己的边框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;border-spacing决定了单元格之间的距离&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;表单&quot;&gt;&lt;a href=&quot;#表单&quot; class=&quot;headerlink&quot; title=&quot;表单&quot;&gt;&lt;/a&gt;表单&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;fieldset用来对相关信息块进行分组&lt;/li&gt;
&lt;li&gt;label标签可以帮助添加结构和增加表单的可用性和可访问性&lt;br&gt;还有很多其他表单元素的应用以及对表单元素的样式处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;8-布局&quot;&gt;&lt;a href=&quot;#8-布局&quot; class=&quot;headerlink&quot; title=&quot;8. 布局&quot;&gt;&lt;/a&gt;8. 布局&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在布局之前需要做的就是理清页面结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把页面划分为大的结构性区域，比如页眉页脚主内容区&lt;/li&gt;
&lt;li&gt;然后，将注意力转移到内容区域本身，开始建立网格结构&lt;/li&gt;
&lt;li&gt;最后，在各个内容区域中寻找不同的布局结构，给内一个内容块一个有意义的名称，分析它们之间的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主内容是页面上最重要的东西，所以应该在文档中首先出现，而用样式来决定它们的显示位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后介绍了2列、3列的基于浮动的&lt;strong&gt;定宽、流式和弹性布局&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用流式布局时，尺寸是用百分数而不是像素设置的，这使流式布局能够相对于浏览器窗口进行伸缩。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;弹性布局相对于字号而不是浏览器宽度来设置元素的宽度。以em为单位设置宽度，可以确保在字号增加时整个布局随之扩大。&lt;br&gt;作者建议，用em为单位来设置容器的宽度，内部宽度仍然使用百分数，这样的话，内部宽度仍然是相对于字号的。这样就可以方便地修改布局的总尺寸，不必修改每个元素的宽度，这种解决方案更灵活、更容易维护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于需要跨大区域的图像（比如站点页眉页脚或品牌区域中的图像）。可以考虑使用背景图像而不是图像标记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;faux&lt;/strong&gt;列是一种对包含容器使用背景图像来制作视觉上和被包含的内容区等高的侧边栏效果的技术&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等高列&lt;/strong&gt;的技术要点：对每一列设置一个很大的底内边距（大概是最短的列和最高的列之间的差值），然后再设置一个小于等于（这个取决于你是否需要间距效果）底内边距的负底外边距（注意是负，为了消除padding带来的视觉影响）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;CSS3 列&lt;/strong&gt;：有几个主要属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;column-count：表示总共多少列&lt;/li&gt;
&lt;li&gt;column-width：表示每列宽度&lt;/li&gt;
&lt;li&gt;column-gap：每列之间的间隔&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它的优点就是在可用空间小于已指定的列的宽度时，它会减少列数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps：之前我对css 3列的概念有误解，我一直认为display:table-cell就是所谓的css 3列，不过现在看来错了太离谱了。甚至我在上一个大作业中还用了table-cell来做瀑布流布局。。。所以后面会花点时间更正&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;9-bug和修复bug&quot;&gt;&lt;a href=&quot;#9-bug和修复bug&quot; class=&quot;headerlink&quot; title=&quot;9. bug和修复bug&quot;&gt;&lt;/a&gt;9. bug和修复bug&lt;/h2&gt;&lt;p&gt;这一章主要讲了很多出现在IE6及其更低版本的bug以及修复方式，因为作者认为IE6现在还占据很大一部分用户，所以应该重视。但是考虑到这本书是09年的，且这几年技术更新比较大，所以个人认为实用性一般。这里也只是简单的摘录了一下常用的bug和常用修复方案&lt;/p&gt;
&lt;h3 id=&quot;捕捉bug&quot;&gt;&lt;a href=&quot;#捕捉bug&quot; class=&quot;headerlink&quot; title=&quot;捕捉bug&quot;&gt;&lt;/a&gt;捕捉bug&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;尽量在一开始就避免bug&lt;/li&gt;
&lt;li&gt;隔离问题&lt;/li&gt;
&lt;li&gt;创建基本测试案例&lt;/li&gt;
&lt;li&gt;修复问题，而不是修复症状&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;拥有布局&quot;&gt;&lt;a href=&quot;#拥有布局&quot; class=&quot;headerlink&quot; title=&quot;拥有布局&quot;&gt;&lt;/a&gt;拥有布局&lt;/h3&gt;&lt;p&gt;Windows上的IE使用布局概念来控制元素的尺寸和定位。那些“拥有布局”（have layout）的元素负责本身及其子元素的尺寸设置和定位，如果一个元素“没有拥有布局”，那么它的尺寸和位置由最近的拥有布局的祖先元素控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥有布局概念是Windows的IE特有的，而且它不是CSS属性&lt;/li&gt;
&lt;li&gt;可以使用JavaScript函数hasLayout查看一个元素是否拥有布局&lt;/li&gt;
&lt;li&gt;hasLayout是一个只读属性，所以无法使用JavaScript进行设置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置以下CSS属性会自动的使元素拥有布局&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;float&lt;/li&gt;
&lt;li&gt;display: inline-block&lt;/li&gt;
&lt;li&gt;width，height&lt;/li&gt;
&lt;li&gt;zoom: 任何值&lt;/li&gt;
&lt;li&gt;writing-mode（微软属性，不能通过检验）&lt;br&gt;在IE7中，以下属性也成了布局触发器&lt;/li&gt;
&lt;li&gt;overflow: hidden, scroll, auto&lt;/li&gt;
&lt;li&gt;min-width、max-width&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;部分问题解决方法&quot;&gt;&lt;a href=&quot;#部分问题解决方法&quot; class=&quot;headerlink&quot; title=&quot;部分问题解决方法&quot;&gt;&lt;/a&gt;部分问题解决方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IE条件注释&lt;br&gt; 条件注释是一种专有的（因此是非标准的）对常规html注释的Microsoft扩展。条件注释能够根据条件显示代码块。尽管是非标准的，条件注释在其他所有浏览器看来是常规注释，因此本质上是无害的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果要为IE指定特定样式表，可以这样做&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--[if IE]&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/ie.css&quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;![end if]--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也可以指定特定版本的浏览器&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--[if IE 6]&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...样式表...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;![end if]--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以指定一组浏览器&lt;/p&gt;
  &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--[if lt IE 6]&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...样式表...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;![end if]--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  说明：lt是less than的意思，即小于，gt为大于&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;还可以指定IE以外的浏览器   &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--[if !IE]&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...给除了IE外的浏览器指定样式表...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;![end if]--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于hack和过滤器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS被设计成具有很强的向前兼容性，这个特点意味着添加新的选择器，属性和值不会对老式浏览器产生严重的影响&lt;/li&gt;
&lt;li&gt;作为一般规则，应该使用依赖于不被支持的CSS的过滤器，而不是依赖某种浏览器bug的过滤器，这可能比较安全。最好完全避免使用过滤器&lt;/li&gt;
&lt;li&gt;明智的使用hack和过滤器，如果需要的hack比较多，那么最好将它们放在自己的样式表中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;星号HTML hack&lt;br&gt; 一般认为html元素是网页上的根元素，但是IE的老版本（IE6及以下）有一个匿名的根元素，它包围着html元素。可以使用通用选择器指定包围在另一个元素中的html元素&lt;/p&gt;
 &lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;tag&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;rules&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;rule&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;width&lt;/span&gt;:&lt;span class=&quot;value&quot;&gt;&lt;span class=&quot;number&quot;&gt;1px&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自选择器hack&lt;br&gt; 因为子选择器是CSS 3才出来的，所以在老版本浏览器不支持的情况下会忽略它&lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;html&amp;gt;body &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章的最后的最后，可以考虑一下分级浏览器支持。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;想了一下，估计博客后面更新的频率会越来越慢了，仔细评估了一下，写读书笔记博客太费时间而且没有多少意义，书上已经写的清清楚楚明明白白了，自己无非是做了一些摘录性质的工作，so……&lt;/p&gt;
&lt;p&gt;总而言之言而总之，后期我更新的内容是大多是最近的学习内容，参考资料，技术总结，以及技术笔记demo展示等。哦，其实还是会写一些读书笔记的，可精可简，比如一本书的要点，点评或读后感什么的也不错&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;距离上一次更新博客已经时隔2周，这两周我在干嘛呢，主要是做了个播放器页面，看了《精通CSS》3~9章，以及开始学习智能社的js基础视频教程，所以下面主要整理了我看书的学习笔记。&lt;br&gt;速度这么慢，鬼知道我这两周经历了什么？？？&lt;/p&gt;
&lt;h2 id=&quot;3-可视化格式模型&quot;&gt;
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>前端之旅第 35~40 天</title>
    <link href="http://archmee.github.io/201608/2016-08-13.html"/>
    <id>http://archmee.github.io/201608/2016-08-13.html</id>
    <published>2016-08-12T16:00:00.000Z</published>
    <updated>2016-10-26T14:26:05.101Z</updated>
    
    <content type="html">&lt;p&gt;在8.12完成了&lt;a href=&quot;https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0001&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IFE2015的第一个任务的第7个作业&lt;/a&gt;，今天来写点日志，现在已经感觉对盒子模型和布局理解更深入一点了。&lt;/p&gt;
&lt;p&gt;-&amp;gt;&lt;a href=&quot;https://github.com/Archmee/Front-End-Demo/tree/master/ife_task_007&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这是项目的github地址&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;已解决问题&quot;&gt;&lt;a href=&quot;#已解决问题&quot; class=&quot;headerlink&quot; title=&quot;已解决问题&quot;&gt;&lt;/a&gt;已解决问题&lt;/h2&gt;&lt;p&gt;这些已解决问题或记录，只是自己在遇到时随手记下来的，并且贴出了解决办法，并没有把每个问题的表现形式截图下来，问题和解决方式的描述也还有待调整，我争取看看有时间的时候完善补充一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当a嵌入一个img时，a元素的高度和img不一样？（ 转自：&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 这是 line-height 和 vertical-align 造成的，被称为幽灵空白节点，解决方案有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让 vertical-align 失效：&lt;code&gt;img { display: block; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;vertical-align 默认为 baseline，更改为其他即可：&lt;code&gt;img { vertical-align:middle; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;直接修改 line-height 值：&lt;code&gt;a { line-height: 5px; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改 font-size：&lt;code&gt;a { font-size: 0; }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;做banner的背景时找到一个新的css 3属性&lt;br&gt; &lt;code&gt;background-size: 100% 100%;&lt;/code&gt;，这样就可以控制背景图片的大小适应整个盒子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于背景透明，文字不透明，解决方案 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个DIV放在一个位置，文字DIV放上面，需要透明的DIV放下面&lt;/li&gt;
&lt;li&gt;使用css属性opacity（文字背景都透明）或者rgba（背景透明文字不透明），参考：&lt;a href=&quot;http://www.cnblogs.com/PeunZhang/p/4089894.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/PeunZhang/p/4089894.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;font-family应该优先指定英文字体，然后再指定中文字体。同时声明中文字体的字体名称（英文）和显示名称（中文）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于li元素之间的间隔，是inline-block导致的，之前遇到过这个问题，也在博客中提过，是用&lt;code&gt;display:table-cell;&lt;/code&gt;解决的，但是我发现它和最上面的问题一有点类似，采用&lt;code&gt;vertical-align:middle;&lt;/code&gt;也解决了问题，仔细检查发现虽然间隔小了很多但还是有一点间隔。所以还是采用&lt;code&gt;font-size:0;&lt;/code&gt;的方式解决了，其实浮动应该可以。&lt;br&gt; 在写表单的时候，若多个表单元素放在一行的话，也会出现间隔，用 letter-spacing 可以解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;了解word-wrap和word-break&lt;br&gt;一下内容来自这篇博客：www.cnblogs.com/2050/archive/2012/08/10/2632256.html。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;word-wrap:break-word;&lt;/code&gt; 对长串英文不起作用，其实这是非常错误的，&lt;code&gt;word-wrap:break-word;&lt;/code&gt;照样能把一个长串英文或数字拆成多行。事实上，&lt;code&gt;word-wrap:break-word;&lt;/code&gt;与&lt;code&gt;word-break:break-all;&lt;/code&gt;共同点是都能把长单词强行断句，不同点是&lt;code&gt;word-wrap:break-word;&lt;/code&gt;会首先起一个新行来放置长单词，新的行还是放不下这个长单词则会对长单词进行强制断句；而&lt;code&gt;word-break:break-all;&lt;/code&gt;则不会把长单词放在一个新行里，当这一行放不下的时候就直接强制断句了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;页面底部采用text-align来居中，版权信息可以正常显示，但是github logo总是不居中，检查它的左边刚好在居中位置，所以采用了&lt;code&gt;margin-left: -50%;&lt;/code&gt; 将图片向左边缩进了自身宽度的边距&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;屏幕宽度小于980px就隐藏头部github图标&lt;/p&gt;
 &lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;media&lt;/span&gt; screen and (max-width: &lt;span class=&quot;number&quot;&gt;980px&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;id&quot;&gt;#github-icon&lt;/span&gt; &lt;span class=&quot;rules&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;rule&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;:&lt;span class=&quot;value&quot;&gt; none&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;之前主页的封面图是用背景来实现的，但是实际图片宽高大于盒子宽高，所以图片显示不完整，在网上找到解决方法是可以用background-size来缩放背景大小，我分别指定宽高为100%，就能适应盒子 大小了。&lt;br&gt;本来以为没问题了，但是今天在缩放窗口的时候发现，图片宽度会随着浏览器窗口调整导致挤压变形严重，在MDN看到一篇介绍background-size的文章，提到还有&lt;strong&gt;contain&lt;/strong&gt;和&lt;strong&gt;cover&lt;/strong&gt;属性可用，contain是按照原图宽高比例进行缩放，只要宽度发生变化，图片高度也会动态调整，这不是我期望的效果，而cover属性就能够填充整个盒子的宽高，并不会随着浏览器缩放调整大小，所以完美解决了这个问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;底部图标居中并底部对齐的问题，对copyright使用text-align:center可以居中，但是不能定位到底部，除非精确计算图标到版权文字的距离，但是不提倡这种硬编码方式。&lt;/p&gt;
&lt;p&gt;刚开始的时候我直接对a元素绝对定位，并且对齐了底部，当然还要对copyright这个div设置相对定位，结果发现它居中的位置是图标的左边位置，所以对img采用了margin-left:-50%使其居中，刚开始看没问题，但是发现和ie不兼容，因为text-align:center根本没有对a+img元素生效，所以图标在浏览器窗口最左边并且使用了img的负边距，所以图标只有右边一半可见。而且这种实现就是，a元素应该在的位置是可点击的，采用负边距后，导致a元素变成了原来宽度加上img的偏移位置，这样可点击的区域也变大了，所以这种方式不是很好。&lt;br&gt;然后我给a元素外面嵌套了一层div.icon，对其使用绝对定位和50%的left，a元素就都到中间偏右一点的位置去了，当然还是以img撑开的a元素的左边进行定位的，所以要对之前在img上使用的负边距使用到a上，不过这次不使用margin了，而是对a进行相对定位以及-50%的left，perfect！！！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;让整个块区域都是可点击区域，只需要把a样式设置为内联块，并且指定宽高就行（padding也可以）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;禁用链接 可对相关a元素使用 pointer-events: none; 但是IE9不兼容，可以添加disabled属性，对IE9有效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;outline 设置a元素或者input元素等在聚焦时候的默认边框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意在设置text input和submit input的大小时的区别，因为text input大小和其他盒子模型一样，真正宽高=设置的宽高+padding+margin+border，而submit input就不一样了，他的宽高=你设置的宽高+margin=可见区域+padding+border+margin。&lt;br&gt;用另一种方式来说就是，你设置的text input的宽高并不包括内边距和边框，而submit input的宽高则包括内边距和边框，注意我们讨论的区别都不包括margin，因为margin在其两者上表现上是相同的。&lt;br&gt;type=”button”和type=”submit”效果一样， type=”text” 和type=”password”效果一样&lt;br&gt;解决方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种 是单独设置宽高，使其达到理想的盒子模型&lt;/li&gt;
&lt;li&gt;第二种 是使用css3属性box-sizing: content-box;设置盒子的大小控制方式，content-box就是可以让该盒子和其他盒子一样，指定的宽高不包括padding、border、margin等，而border-box就是默认的表现，padding、border都在指定的宽高内进行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请看问题#14，在左右两个input元素高度一致时，左右不能对齐，就是不在同一条水平线上&lt;br&gt;已解决，办法是设置vertical-align为一个除了baseline外的值即可，可能还是跟inline-block元素的表现有关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认字间距为2像素（只是目测了Chrome ^,^）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在写project.html页面时，在a元素中嵌入div，用作在鼠标经过图片时，弹出隐藏的文字框，显示文字部分有背景，在完全使用css的情况下，div和a元素盒子一样大小，需要显示的文字要底部对齐，用 &lt;code&gt;a div:hover&lt;/code&gt;来实现选择元素，在正常时，将文字和用text-indent隐藏，而hover时，添加背景和显示文字，并且用渐变方式实现背景(可以指定位置)，但是ie不兼容，文字和渐变背景都没有，然后我给盒子加了一个非渐变的默认背景，但是这样就是hover时整个盒子都有背景了，虽然不理想，但是不想为兼容性浪费太多时间，背景就先这样。&lt;br&gt;然后我又先后使用了&lt;code&gt;font-size:0;&lt;/code&gt;到&lt;code&gt;font-size:1em;&lt;/code&gt;，以及&lt;code&gt;opacity:1;&lt;/code&gt;到&lt;code&gt;opacity:0;&lt;/code&gt;达到隐藏显示文字的目的，但是ie仍不兼容，除了opacity能够在鼠标hover到文字上时可以达到效果，但是如果鼠标在div的非文字区域，就还是识别不到hover。&lt;br&gt;经过google，找到和我之前不一样的设置hover的方式，&lt;code&gt;a:hover div&lt;/code&gt; 选中元素，注意它是把hover添加到了a上，所以现在ie和其他浏览器都兼容了，甚至可以指定盒子不用完全和a一样大了，而指定自己想要的高度即可，这样我也可以不使用渐变背景来达到文字区域的背景了，ie也ok&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在project.html页面的瀑布流布局那里，a元素嵌入img和一个div，a和img都是inline-block的框，但是a元素始终没有img高，始终会少1px左右，虽然网上的方案都是像问题#1一样解决的，但是这里，只有问题1的第一种方法&lt;code&gt;img{ display:block ;}&lt;/code&gt; 才有效果，暂时不知道什么原因&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;待解决问题&quot;&gt;&lt;a href=&quot;#待解决问题&quot; class=&quot;headerlink&quot; title=&quot;待解决问题&quot;&gt;&lt;/a&gt;待解决问题&lt;/h2&gt;&lt;p&gt;其实看了百度学院老师review其他人的代码，发现自己也犯了几个同样的问题，需要对代码进行调整。目前已知的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右上角github icon是背景方式呈现，不需要img标签，并且在a元素中包含说明文字，底部图标一样&lt;/li&gt;
&lt;li&gt;底部link列表应该用dl而不是ul&lt;/li&gt;
&lt;li&gt;项目相关的图片和css使用到的图标应该分开放置，方便以后做cdn之类的&lt;/li&gt;
&lt;li&gt;日历并不是链接，没有可点击的事件，不需要使用a标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过都是些小问题，马上就可以调整好了。接下来会看下css和html代码规范，看还有没需要修改的或者语义不正确的地方。&lt;/p&gt;
&lt;h2 id=&quot;截图&quot;&gt;&lt;a href=&quot;#截图&quot; class=&quot;headerlink&quot; title=&quot;截图&quot;&gt;&lt;/a&gt;截图&lt;/h2&gt;&lt;p&gt;上一次更新日志是前两个页面，现在放后面两个页面的截图:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2016-08-12_215651.jpg&quot; alt=&quot;项目&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/2016-08-12_215731.jpg&quot; alt=&quot;关于&quot;&gt;&lt;/p&gt;
&lt;p&gt;–END–&lt;br&gt;假装有彩蛋&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在8.12完成了&lt;a href=&quot;https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0001&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IFE2015的第一个任务的第7个
    
    </summary>
    
      <category term="tech" scheme="http://archmee.github.io/categories/tech/"/>
    
    
      <category term="Front End" scheme="http://archmee.github.io/tags/Front-End/"/>
    
  </entry>
  
</feed>
