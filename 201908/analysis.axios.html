<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>axios 源码分析 | 神无</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
</head>
</html>
<body>
  <nav class="app-nav">
  
      
        <a class="active" href="/./">home</a>
        

      
  
      
        <a href="/archives">archive</a>
      
  
      
        <a href="/demo">demo</a>
      
  
      
        <a href="/about">about</a>
      
  
      
        <a href="/atom.xml">rss</a>
      
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/201908/analysis.axios.html">axios 源码分析</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">August 14 2019</p>
  </section>

  <section class="article-entry">
    <blockquote>
<p>阅读完本文需要 鬼知道多少分钟</p>
<p>大家好，我是鬼道</p>
</blockquote>
<p>axios 是一个基于基于 Promise 的网路请求库，可以用于浏览器和node服务器，虽然经常用，但是我并没有看过内部是怎么实现的。</p>
<p>在某天晚上心血来潮，花了一晚上时间读完了axios的源码，其实发现也没有想象中那么难。</p>
<p>在进入具体细节分析前，先预览一下我阅读源码之后绘制的运行依赖图，可以感受下整体结构</p>
<p><img src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/images/axios-structure-2019-08-13_172827.png" alt="axios运行依赖图"></p>
<p>图片中对于方向表达的不是很明确，简单点说就是上层模块依赖下层模块，而右边的模块主要是为左边的这些模块提供一些通用的工具和方法，比如类型判断等，所以下边的分析重点只会聚焦于左边这一块的内容。</p>
<blockquote>
<p>从 github 上下载的 axios 代码根目录下的<code>lib</code>目录就是 axios 的所有源代码</p>
<p>为了易于理解，我分析的时候调整了代码顺序，并且省略了部分代码，一些工具函数也都是见名知义 :smile:</p>
</blockquote>
<h2 id="各个阶段"><a href="#各个阶段" class="headerlink" title="各个阶段"></a>各个阶段</h2><p>概括来说主要流程是这样的：</p>
<ul>
<li>调用 createInstance 创建 Axios 实例</li>
<li>Axios 实例中初始化了拦截器，Axios 的 request 方法被 createInstance 导出</li>
<li>用户发起请求，request 方法被调用，对拦截器做出响应，调用 dispatchRequest </li>
<li>dispatchRequest 会检查取消请求与否、转换数据 及调用网络请求库等，把数据返回给 request </li>
</ul>
<p>下面详细分析</p>
<h3 id="1-导入-axios"><a href="#1-导入-axios" class="headerlink" title="1. 导入 axios"></a>1. 导入 axios</h3><h4 id="1-1-导入配置对象"><a href="#1-1-导入配置对象" class="headerlink" title="1.1 导入配置对象"></a>1.1 导入配置对象</h4><blockquote>
<p>defaults.js</p>
</blockquote>
<p>导入配置对象，这个对象大概长这样，里面初始化了网络请求库、请求头信息等，该对象随后会在给各个模块间传递进行使用，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">defaults = &#123;</span><br><span class="line">  	<span class="comment">// 根据 node 和 browser 的区别返回 http | xhr 的模块</span></span><br><span class="line">    adapter: getDefaultAdapter(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据转换，之所以把函数放进数组，是为了方便用户自定义转换函数</span></span><br><span class="line">    <span class="comment">// 这样axios就可以连续调用把数据在多个函数之间传递</span></span><br><span class="line">    <span class="comment">// 看了mergeConfig里面，好像是用户传入是会覆盖默认的</span></span><br><span class="line">    transformRequest: [transformRequest], <span class="comment">// 请求时调用，比如对象转为字符串</span></span><br><span class="line">    transformResponse: [transformResponse], <span class="comment">// 返回响应时调用，将字符串转为json</span></span><br><span class="line">    </span><br><span class="line">    timeout: <span class="number">0</span>, <span class="comment">// 请求超时时间设置</span></span><br><span class="line">    xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>,</span><br><span class="line">    xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>,</span><br><span class="line">    maxContentLength: <span class="number">-1</span>,</span><br><span class="line">    validateStatus: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 校验http状态码的函数</span></span><br><span class="line">    </span><br><span class="line">    headers = &#123;</span><br><span class="line">      common: &#123;</span><br><span class="line">        <span class="string">'Accept'</span>: <span class="string">'application/json, text/plain, */*'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">delete</span>: &#123;&#125;,</span><br><span class="line">      <span class="keyword">get</span>: &#123;&#125;,</span><br><span class="line">      head: &#123;&#125;,</span><br><span class="line">    </span><br><span class="line">      put: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">      post: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">      patch: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-创建实例"><a href="#1-2-创建实例" class="headerlink" title="1.2 创建实例"></a>1.2 创建实例</h4><blockquote>
<p>文件：axios.js</p>
</blockquote>
<p>无论是默认初始化还是用户调用 axios.create，都需要调用 createInstance 。</p>
<p>这里传入了参数 defaults，通过 Axios 创建实例，返回 request 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建实例，传入默认配置，从Axios可知，axios.defaults = defaults</span></span><br><span class="line">axios = createInstance(defaults)</span><br><span class="line"></span><br><span class="line"><span class="comment">// createInstance 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 core/Axios 创建实例</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> Axios(defaultConfig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 Axios 原型里的 request 方法的绑定到 context</span></span><br><span class="line">  <span class="comment">// 所以 instance 其实就是一个单独的 request 函数，但是绑定了 context</span></span><br><span class="line">  <span class="keyword">var</span> instance = bind(Axios.prototype.request, context);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把 Axios.prototype 的方法和属性添加到到 instance 函数里面，并将其方法的 this 都绑定到 context</span></span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 context 的方法和属性也添加到 instance 函数里面去</span></span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面几步很绕，但总结起来就是：把Axios的原型对象和实例对象里的属性和方法都复制给instance函数，</span></span><br><span class="line">  <span class="comment">// 并且所有方法的 this 都被绑定到了context，变成了静态属性或方法</span></span><br><span class="line">  <span class="comment">// 后面可以直接调用 instance() 或者 instance.xxx()</span></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露构造函数</span></span><br><span class="line">axios.create = <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将用户传入配置 和 默认配置合并，创建axios实例，但是用户传入的无效配置将不会得到处理</span></span><br><span class="line">  <span class="keyword">return</span> createInstance(mergeConfig(axios.defaults, instanceConfig));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求相关的模块</span></span><br><span class="line">axios.Cancel = <span class="built_in">require</span>(<span class="string">'./cancel/Cancel'</span>);</span><br><span class="line">axios.CancelToken = <span class="built_in">require</span>(<span class="string">'./cancel/CancelToken'</span>);</span><br><span class="line">axios.isCancel = <span class="built_in">require</span>(<span class="string">'./cancel/isCancel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送所有请求</span></span><br><span class="line">axios.all = <span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spread(function(x, y) &#123;&#125;)([1, 2]);</span></span><br><span class="line">axios.spread = <span class="built_in">require</span>(<span class="string">'./helpers/spread'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="1-3-Axios-构造函数"><a href="#1-3-Axios-构造函数" class="headerlink" title="1.3 Axios 构造函数"></a>1.3 Axios 构造函数</h4><blockquote>
<p>文件：core/Axios.js</p>
</blockquote>
<p>createInstance 创建了 Axios 实例，Axios里面创建了两个 interceptor 等待 request 被调用的时候使用。</p>
<p>而通过代码可以看出，request 处理分三个阶段：</p>
<ol>
<li>请求前的拦截，调用 request.interceptors，如果成功才执行下一步</li>
<li>发出请求，调用网络请求模块</li>
<li>收到响应后的拦截，调用 response.interceptors</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.defaults = instanceConfig;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分别给 request和response 创建了 interceptorMnager</span></span><br><span class="line">  <span class="comment">// 我们在外面就可以调用 axios.interceptors.request.use 等方法</span></span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 request 就是整个 axios 最终导出的函数，目前还不会运行</span></span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果调用该方法之前没添加拦截器的话，dispatchRequest 会直接发请求</span></span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在chain头插入 request 的 interceptors</span></span><br><span class="line">  <span class="comment">// request 是一个interceptor对象，forEach方法是该对象自己的</span></span><br><span class="line">  <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在chain尾插入 response 的 interceptors</span></span><br><span class="line">  <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从chain头部顺序弹出fulfilled和rejected作为then函数的resolve和reject</span></span><br><span class="line">  <span class="comment">// 如果剩下 [dispatchRequest, undefined]</span></span><br><span class="line">  <span class="comment">// 则类似这样，promise.then(dispatchRequest, undefined)</span></span><br><span class="line">  <span class="comment">// 实际上在dispatchRequest左边的调用都是在请求前的，即request阶段</span></span><br><span class="line">  <span class="comment">// 如果request阶段的interceptor没问题就会得到这样的调用dispatchRequest(config)</span></span><br><span class="line">  <span class="comment">// 而 dispatchRequest 是真正发出了请求</span></span><br><span class="line">  <span class="comment">// dispatchRequest 后边的都是接收到响应后的，即response阶段</span></span><br><span class="line">  <span class="comment">// 通过分析在chain插入interceptor的顺序就可以分析出</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config); <span class="comment">// 将config对象传给then</span></span><br><span class="line">  <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">    promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为支持的请求方法提供别名比如get/post</span></span><br><span class="line"><span class="comment">// 这里实现了我们在使用的时候通过 axios.get() 这种方法的调用</span></span><br><span class="line"><span class="comment">// 但是如你所见，这只是一个别名而已，最终还是要调用 request 方法</span></span><br><span class="line"></span><br><span class="line">utils.forEach([<span class="string">'delete'</span>, <span class="string">'get'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodNoData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(utils.merge(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.forEach([<span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodWithData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, data, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(utils.merge(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url,</span><br><span class="line">      data: data, <span class="comment">// post 的数据就是从这里传入的</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="1-4-InterceptorManager"><a href="#1-4-InterceptorManager" class="headerlink" title="1.4 InterceptorManager"></a>1.4 InterceptorManager</h4><blockquote>
<p>文件：core/InterceptorManager.js</p>
</blockquote>
<p>在Axios构造函数中创建了 InterceptorManager 实例，use 添加拦截器，eject 移除拦截器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interceptor 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InterceptorManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handlers = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加interceptor</span></span><br><span class="line"><span class="comment">// 这个方法使得我们可以在外调用 axios.interceptors.request.use(resolve, reject)</span></span><br><span class="line">InterceptorManager.prototype.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fulfilled, rejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handlers.push(&#123;</span><br><span class="line">    fulfilled: fulfilled,</span><br><span class="line">    rejected: rejected</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.handlers.length - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除interceptor</span></span><br><span class="line">InterceptorManager.prototype.eject = <span class="function"><span class="keyword">function</span> <span class="title">eject</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[id]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handlers[id] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法遍历handlers，将handler作为参数传给外面的回调fn来执行</span></span><br><span class="line"><span class="comment">// Axios.prototype.request 里面有用到这个方法</span></span><br><span class="line">InterceptorManager.prototype.forEach = <span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  utils.forEach(<span class="keyword">this</span>.handlers, <span class="function"><span class="keyword">function</span> <span class="title">forEachHandler</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h !== <span class="literal">null</span>) &#123;</span><br><span class="line">      fn(h);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-axios-请求"><a href="#2-axios-请求" class="headerlink" title="2. axios 请求"></a>2. axios 请求</h3><blockquote>
<p>文件：core/dispatchRequest.js</p>
</blockquote>
<p>axios 真正发出请求都会调用 request 方法，request 处理分三个阶段，请求前拦截=&gt;请求=&gt;响应后拦截，而请求是 dispatchRequest 调用网络请求模块发出，dispatch分为 5 个阶段：</p>
<ol>
<li>请求前检查请求是否被取消</li>
<li>请求前转换数据（可配置的 transformRequest）</li>
<li>调用网络请求模块发出请求</li>
<li>收到响应后检查请求是否被取消</li>
<li>收到响应后转换数据（可配置的 transformResponse）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1 请求前检查请求是否被取消</span></span><br><span class="line">  throwIfCancellationRequested(config);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2 请求前转换数据，调用transformRequest</span></span><br><span class="line">  config.data = transformData(</span><br><span class="line">    config.data,</span><br><span class="line">    config.headers,</span><br><span class="line">    config.transformRequest</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 引入adapter，xhr 或者 http</span></span><br><span class="line">  <span class="keyword">var</span> adapter = config.adapter || defaults.adapter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3 发出请求</span></span><br><span class="line">  <span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 收到响应后检查请求是否被取消</span></span><br><span class="line">    throwIfCancellationRequested(config);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5 返回响应后调用 transformResponse 处理</span></span><br><span class="line">    response.data = transformData(</span><br><span class="line">      response.data,</span><br><span class="line">      response.headers,</span><br><span class="line">      config.transformResponse</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回响应给 request 方法</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">    </span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回自定义的json错误信息，也要经过 transformResponse</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(reason);</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-xhr-adapter"><a href="#3-xhr-adapter" class="headerlink" title="3. xhr adapter"></a>3. xhr adapter</h3><blockquote>
<p>文件：adapters/xhr.js</p>
</blockquote>
<p>axios 的网络请求库是 xhr 和 http，由于大部分时间我都工作在浏览器端，所以我只对 xhr 进行分析。</p>
<p>在我删除了一些非核心代码后，它神秘的外衣渐渐褪去，就是用 Promise 包装浏览器的 XMLHttpRequest 而已</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建xhr</span></span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置超时ms</span></span><br><span class="line">    request.timeout = config.timeout;</span><br><span class="line">    </span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 根据返回的 status 判断 resolve 或 reject</span></span><br><span class="line">    &#125;;</span><br><span class="line">    request.onabort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    request.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置传入的请求头，如果有必要，添加xsrf头</span></span><br><span class="line">    request.setRequestHeader(key, val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否发送cookie</span></span><br><span class="line">    request.withCredentials = request.withCredentials ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开连接，发送请求</span></span><br><span class="line">    request.open(method, url, <span class="literal">true</span>);</span><br><span class="line">    request.send(requestData);</span><br><span class="line">    </span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><blockquote>
<p>文件：cancel/CancelToken.js</p>
</blockquote>
<p>由于取消请求需要调用者主动发起，所以它并不算我们主要请求阶段，所以单独拿出来聊聊</p>
<p>cancelToken 是一个用于取消请求的模块，我很少用，尝试过感觉难用，不光是接口难用，我看了下源码，CancelToken 构造函数和  CancelToken.source 的实现也有点难理解，不过多看几遍就明白了，我精简了下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// promise 执行器，也就是通过下面调用后，resolvePromise 可以激发 then 的调用</span></span><br><span class="line">  <span class="keyword">var</span> resolvePromise;</span><br><span class="line">  <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">promiseExecutor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolvePromise = resolve;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> token = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当cancel被调用时，reason有了，resolvePromise被执行，等待被catch接收</span></span><br><span class="line">  executor(<span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token.reason) &#123; <span class="comment">// 如果cancel已经被调用过了，就不能重复调用了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token.reason = <span class="keyword">new</span> Cancel(message);</span><br><span class="line">    resolvePromise(token.reason); <span class="comment">// 发给promise.then</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以先忽略这里</span></span><br><span class="line">CancelToken.source = <span class="function"><span class="keyword">function</span> <span class="title">source</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cancel;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建 CancelToken 实例，传入一个函数，该函数会在 CancelToken 构造函数内部传回cancel</span></span><br><span class="line">  <span class="keyword">var</span> token = <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    token: token,</span><br><span class="line">    cancel: cancel</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>are u Crying？？？</p>
<p>i m not！！！</p>
<p>CancelToken 其实做了一件事，即接收一个函数，并给了你一个接受 cancel 函数的机会，你如果调用这个 cancel 函数，就会设置 token.reason 同时触发 resolvePromise </p>
<p>不知道你是否还记得 dispatchRequest 的 5 个阶段，请求前和响应后都会检查请求是否被取消，而正是通过下面这个 throwIfCancellationRequested 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispatchRequest.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户请求时传入的参数是否有cancelToken，这是用户在发送请求时设置的一个CancelToken实例</span></span><br><span class="line"><span class="comment">// 如果有，则说明用户有取消的潜在需求，然后调用 cancelToken.throwIfRequested </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfCancellationRequested</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">    config.cancelToken.throwIfRequested();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CancelToken.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 reason 是否存在？</span></span><br><span class="line"><span class="comment">// 不存在，说明 cancel 没有执行过，则放你一马</span></span><br><span class="line"><span class="comment">// 存在，说明 cancel 被执行了，则报警，必须立刻马上取消请求</span></span><br><span class="line">CancelToken.prototype.throwIfRequested = <span class="function"><span class="keyword">function</span> <span class="title">throwIfRequested</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.reason) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">this</span>.reason;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，throwIfRequested 是在 dispatchRequest 中被执行的，而 dispatchRequest  是在 Axios.Prototype.request （所有请求的方法都会经过request）方法中被 <code>promise = promise.then(dispatchRequest)</code> 执行的，而这个promise最终会带着错误被返回给调用者，必然会被调用者的 catch() 捕获到</p>
<p>再来看一下用法，则更能容易理解了，这个CancelToken的 2 个要素： token 和 cancel 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cancel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一要素，请求时要获取一个cancelToken，并且同时要拿到cancel函数</span></span><br><span class="line">axios.get(<span class="string">'/api'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    cancel = c</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二，任何时候，你都可以调用cancel取消请求</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure>
<p>至于 CancelToken.source， 只是把这个过程封装了一下而已</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有几个地方提一下，感兴趣的同学自己看代码</p>
<ol>
<li><p>createInstance 函数里面</p>
<p>createInstance 返回后的实例 并没有被返回，而是返回了<code>axios = Axios.prototype.request</code>，我知道这样做的好处是可以直接<code>axios()</code>这样调用，也可以调用静态方法<code>axios.get()</code>，可使除此之外呢？</p>
</li>
<li><p>interceptor 在 request 方法中的链式调用</p>
<p>代码很简单，又觉得妙，这个 chain 大概长这个样子<code>[resolve, reject, dispatchRequest, undefined, resolve, reject]</code>，然后不断的 <code>promise = promise.then(resolve, reject)</code></p>
</li>
<li><p>一个类似于bind的函数，觉得还不错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spread</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback.apply(<span class="literal">null</span>, arr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// spread(function(x, y, z) &#123;&#125;)([1, 2, 3]);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>了解到一个新接口 URLSearchParams，见名知义，用法如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'id'</span>, <span class="string">'123'</span>)</span><br><span class="line">params.append(<span class="string">'name'</span>, <span class="string">'haaa'</span>)</span><br><span class="line">params.toString() <span class="comment">// id=123&amp;name=haaa</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说 axios 运行分三个阶段：</p>
<ol>
<li>导入 axios 模块<ol>
<li>导入 defaults 配置对象</li>
<li>调用 createInstance 创建一个 Axios 实例 instance，创建Axios实例的时候分别为请求和响应创建了interceptor，然后返回 Axios.Prototype.request 函数，不过这个函数复制了 Axios.Prototype 和 instance 上的所有属性和方法，方法的 this 都被绑定了 instance</li>
<li>这个 request 是一个核心函数，最后导出的 axios 就是这个函数（函数对象也是对象），axios.create 得到的也是一个request方法、axios.get、post、delete 这些外部可见的请求方法都是调用 request 方法</li>
</ol>
</li>
<li>配置 interceptor<ol>
<li>当我们在正式请求之前会配置 axios 的拦截器，也就是调用 axios.request.interceptor.use 和 axios.response.interceptor.use 的时候，内部的 interceptorManager 会为每一个 axios 实例维护一个request 拦截列表 和 response 拦截列表，多次调用 use 可以配置多个拦截器</li>
<li>interceptor 不但可以用 use 添加拦截器，也可以用 eject 移除拦截器</li>
</ol>
</li>
<li>调用 axios 方法<ol>
<li>发出请求之前，request 会按照 use 调用的顺序处理所有的 request.interceptor，如果成功，则发出请求，否则中断请求</li>
<li>调用 dispatchRequest 模块<ol>
<li>检查请求是否被用户取消，取消则中断处理</li>
<li>处理一些头信息并调用 transformRequest 转换数据</li>
<li>然后调用网络请求模块发出请求，数据返回</li>
<li>检查请求是否被用户取消，取消则中断处理</li>
<li>调用 transformResponse 转换数据，最后返回数据</li>
</ol>
</li>
<li>收到结果之后，request 会按照 use 调用的顺序处理所有的 response.interceptor，分别对成功和失败做出处理</li>
</ol>
</li>
</ol>
<p>sofa !</p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> 神无 </p>
      <p class="subtitle"> 舍悟离迷，六尘不改。 </p>
    <div>
  </section>

  <section class="share-btns">
    <p> share it if you like it. </p>
    <!-- <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=ockquote>
<p>阅读完本文需要"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>
 -->
  </section>
</div>


  
</main>

</body>
</html>
