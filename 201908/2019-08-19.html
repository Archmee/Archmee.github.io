<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>循环引用和深度克隆 | 神无</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
</head>
</html>
<body>
  <nav class="app-nav">
  
      
        <a class="active" href="/./">home</a>
        

      
  
      
        <a href="/archives">archive</a>
      
  
      
        <a href="/demo">demo</a>
      
  
      
        <a href="/about">about</a>
      
  
      
        <a href="/atom.xml">rss</a>
      
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/201908/2019-08-19.html">循环引用和深度克隆</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">August 16 2019</p>
  </section>

  <section class="article-entry">
    <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>深度克隆我想很多人都写过，但是很多人实现的都是简单版本，对于复杂的深度克隆，基本上工程上大家都会使用 underscore 的 cloneDeep，那么深度克隆有什么技术难点呢：</p>
<ul>
<li>复杂数据类型，比如函数、正则、日期、Symbol 等不能通过直接遍历属性的方式拷贝</li>
<li>数据可能会有循环引用，如果一直拷贝就会无穷递归</li>
</ul>
<p>我最近在对以前实现的一个深度克隆进行思考改进的时候，灵感来了有了一点思路，下面分别进行说明</p>
<h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><p>第一，我们先处理复杂数据类型，我们只要实现一个严格的数据类型判断，在拷贝的时候进行判断，并分别进行处理</p>
<ul>
<li>对于基本类型数据，直接复制</li>
<li>对于 正则对象，可以提取字符串，再调用构造函数重新创建正则对象</li>
<li>对于日期对象，也可以通过构造函数重新黄建</li>
<li>其实比较难的是函数对象，主要是 new Function 传入的字符串会被包装到一个匿名函数中并返回，我用了一些比较hack的办法，主要是处理函数名和参数，算是暂时解决了这个问题。</li>
<li>除此之外的对象可以递归遍历</li>
</ul>
<p>下面直接看代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!src ||</span><br><span class="line">      isString(src) ||</span><br><span class="line">      isNumber(src) ||</span><br><span class="line">      isBoolean(src)) &#123; <span class="comment">//基本值 null, undefined, string, number, bool 直接复制</span></span><br><span class="line"></span><br><span class="line">    newValue = src;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDate(src)) &#123; <span class="comment">//日期</span></span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">Date</span>(src);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(src)) &#123; <span class="comment">// 函数</span></span><br><span class="line">    <span class="comment">// 方法一，把函数解体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个函数分为三个部分，名字、参数、函数体 转换为字符串后，要分别解析出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fnString = src.toString().replace(<span class="regexp">/[\r\n]*\s+/g</span>, <span class="string">' '</span>);<span class="comment">//去掉换行符</span></span><br><span class="line">    <span class="keyword">var</span> fnMatch = fnString.match(<span class="regexp">/^function\s*(?:([\w\$]*)\s*(?:\(([\w,]*)\))(?:\s*\&#123;(.*)\&#125;))/</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> fnName = fnMatch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fnArgs = fnMatch[<span class="number">2</span>].split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">var</span> fnBody = fnMatch[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数字符串中用名字递归调用自己，我们则relace为arguments.callee</span></span><br><span class="line">    <span class="comment">// 函数名前面和后面必然有边界符才替换</span></span><br><span class="line">    <span class="keyword">if</span> (fnName) &#123;</span><br><span class="line">      fnBody = fnMatch[<span class="number">3</span>].replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+ fnName + <span class="string">'\\b'</span>), <span class="string">'arguments.callee'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">Function</span>(...fnArgs, fnBody); <span class="comment">// 这里要借助... 不然很难展开参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种，一种比较hack的方法，替换函数名字，增加立即调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传给Function一个带有function声明的函数字符串的话，一定需要函数名，</span></span><br><span class="line">    <span class="comment">// 而且返回的函数被匿名函数包裹，我们通过在字符串后面添加立即执行函数来执行</span></span><br><span class="line">    <span class="comment">// 由于这个函数时被封闭的，所以名字可以随意</span></span><br><span class="line">    <span class="comment">// var fnString = src.toString().replace(/[\r\n]*\s+/g, ' ');</span></span><br><span class="line">    <span class="comment">// var fnMatch = fnString.match(/^function\s*(?:([\w\$]*))/);</span></span><br><span class="line">    <span class="comment">// var fnName = fnMatch[1] ? fnMatch[1] : 'noName';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (!fnMatch[1]) &#123;</span></span><br><span class="line">    <span class="comment">//     fnString = fnString.replace('function', 'function ' + fnName);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 追加立即调用</span></span><br><span class="line">    <span class="comment">// fnString += ';' + fnName + '.apply(this, [].slice.call(arguments));'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// newValue = new Function(fnString); // 这里会返回一个匿名函数，匿名函数中包裹原来的函数和函数调用</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(src)) &#123; <span class="comment">// 正则</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个正则对象的字符串分为两种情况，我们只需要处理字面量</span></span><br><span class="line">    <span class="comment">// 1. /^abc/ 这种是字面量，处理为 ^abc，对于/^abc/ig 这种，要把ig提取出来作为RegExp的第二个参数</span></span><br><span class="line">    <span class="comment">// 2. 还有通过RegExp创建的 ^abc，无需处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reg = src.toString();</span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> last = reg.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> patten = reg.slice(start, last);</span><br><span class="line">    <span class="keyword">var</span> end = reg.slice(last+<span class="number">1</span>); <span class="comment">// i、g、m ...</span></span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">RegExp</span>(patten, end);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(src) || isObject(src))&#123; <span class="comment">// 数据和对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src.hasOwnProperty(item)) &#123;  <span class="comment">//防止继承属性</span></span><br><span class="line">          newValue[item] = cloneObject(src[item]); <span class="comment">// 递归复制</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">// end else</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于数据类型判断的实现比较简单，就不在这里占篇幅了，通过上面的代码，可以看出函数的处理是最复杂的，因为传给 Function 构造函数的字符串都会被放进一个匿名函数进行返回，我实现了两种hack：</p>
<ul>
<li><p>一种是，对于原函数的字符串，通过正则提取函数名、参数、函数体，由于函数体可能递归调用函数自己，所以我们替换了函数体内和函数名同名的字符串为 <code>arguments.callee</code>，然后把参数和函数体分别传给 Function。</p>
<p>对于Function的参数展开目前我们使用了ES6的<code>...</code>展开符，如果没有这个运算符，我们如何处理这里的参数是个问题，而且这里不能调用apply，我有了一点思考，准备单开一个主题来聊聊我的思路</p>
</li>
<li><p>第二种是，我们直接传递原函数的字符串给 Function，但是现在返回的函数是一个匿名函数包裹了原函数的形式，不能被直接调用，所以我们在匿名函数内部实现了函数立即调用，并通过匿名函数的参数调用原函数，并将我们添加的调用字符串追加到原函数的字符串后面，传给Function即可</p>
</li>
</ul>
<p>如果不用这种方式处理的话，目前我还没有想到什么理想的方案，如果各位有想法的话欢迎交流</p>
<h2 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h2><p>我那天在草稿纸上画一棵树的时候，突然想到了循环引用的问题，并开始了展开思考，当A对象引用了B对象，而B对象又引用了A对象的话就构成了循环引用，如果采用上面的方法，碰到对象就递归，那么就会进入无线循环，如何解决呢，我们要做的不是斩断这个引用，而是如果源对象就是相互引用的，那么我们拷贝的结果也应当是相互引用的，考虑如下数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'a'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  name: <span class="string">'b'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.src = b;</span><br><span class="line">b.src = a;</span><br></pre></td></tr></table></figure>
<p>我也实现过两次，下面展开我的思路</p>
<p>第一种：类似原型链的方式</p>
<p>如果大家了解原型链，就比较好理解这种方式，当我们使用 instanceof 操作符的时候，它会一直遍历原型链检查原型对象直到 null 才终止，我的思路和这个思想差不多。</p>
<p>我们可以把它想象成有两颗节点的一棵树，一开始只有一个父节点为null的根节点，当从根节点向下遍历的时候，判断这个节点的祖先节点是否和该节点指向同一个地址，如果是，则表示进入循环，直接复制地址，然后返回（不进入递归）。如果遍历完祖先节点都没有找到相同相同地址的节点，表示没有循环，则将该节点加入这棵树。</p>
<p>这棵树长这样，由于curent是函数闭包里面的局部变量，每次递归的时候，传递给子节点，子节点保存父节点的引用和自己的引用，所以current不会相互影响，下面的代码省略了一些之前的一些过程，只表达主要思路。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚开始的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">a, parent=null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = &#123;</span><br><span class="line">    parent: parent, <span class="comment">// 这是我们要遍历的树，伴随指针</span></span><br><span class="line">    src: a, <span class="comment">// 这是原对象，我们不能更改，只是用作检查</span></span><br><span class="line">  &#125;；</span><br><span class="line">  <span class="keyword">if</span> (checkCircle(a, current)) &#123;</span><br><span class="line">    <span class="comment">// 遍历a的属性clone，这里省略了循环</span></span><br><span class="line">    cloneObject(a, current);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">b, parent=a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = ｛</span><br><span class="line">      parent: parent,</span><br><span class="line">      src: b</span><br><span class="line">  ｝</span><br><span class="line">  <span class="keyword">if</span> (checkCircle(b, current)) &#123;</span><br><span class="line">    <span class="comment">// 遍历b的属性clone，这里省略了循环</span></span><br><span class="line">    cloneObject(b, current);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次遇到一个对象 进行遍历检查是否循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCircle</span>(<span class="params">src, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = parent;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.src === src) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很清晰的表达做了什么事情，这里的思路没问题，但没有完全解决问题，所以没有贴出完整代码。我刚开始很喜滋滋的欣赏自己的成果，然后画了一颗复杂的树进行测试，然后发现，对于当前节点对兄弟节点或者兄弟节点的子孙节点进行引用的情况没有很好的处理，这样会出现什么情况呢，就是兄弟节点会复制自己的子孙节点，而当前节点也会复制其兄弟节点或其子孙节点，这种情况表示正在创建的这颗对象树有两份其兄弟节点的拷贝，这和原对象的引用情况不符，也不是我们想要的情况，毕竟浪费了内存。</p>
<p>在我苦思冥想以后，我仍然基于这棵树有了新的思路，如果一个对象表示这棵树的一个节点，它一旦被访问就保存到访问列表，然后保存被复制前的地址和复制后的地址，如果下次再访问就表示被创建过了，不管其他父节点，子孙节点还是兄弟节点再访问我，就表示重复访问，那我就直接把我上次创建的新的的引用地址给它，它就不用重复创建了，这个应该算是标记法吧。而且这个还很好的解决了循环引用的问题，因为一个节点一旦被访问过就被保存起来，下一次再访问如果不是重复创建就是循环引用，perfect，这个方案非常完美的解决了问题。</p>
<p>下面是 show time 。。。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点图，保存访问过的节点</span></span><br><span class="line"><span class="keyword">var</span> nodesMap = &#123;</span><br><span class="line">  nodes: [], <span class="comment">/* &#123; oldSrc: a, newSrc: b &#125; */</span></span><br><span class="line"></span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nodes.push(node);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nodes.length = <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  find: <span class="function"><span class="keyword">function</span>(<span class="params">ref</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">        len,</span><br><span class="line">        nodes = <span class="keyword">this</span>.nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ref === nodes[i].oldSrc) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodes[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!src ||</span><br><span class="line">      isString(src) ||</span><br><span class="line">      isNumber(src) ||</span><br><span class="line">      isBoolean(src)) &#123; <span class="comment">//基本值 null, undefined, string, number, bool</span></span><br><span class="line"></span><br><span class="line">    newValue = src;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDate(src)) &#123; <span class="comment">//日期</span></span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">Date</span>(src);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(src)) &#123;</span><br><span class="line">    <span class="comment">// 方法一，把函数解体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个函数分为三个部分，名字、参数、函数体 转换为字符串后，要分别解析出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fnString = src.toString().replace(<span class="regexp">/[\r\n]*\s+/g</span>, <span class="string">' '</span>);<span class="comment">//去掉换行符</span></span><br><span class="line">    <span class="keyword">var</span> fnMatch = fnString.match(<span class="regexp">/^function\s*(?:([\w\$]*)\s*(?:\(([\w,]*)\))(?:\s*\&#123;(.*)\&#125;))/</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> fnName = fnMatch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fnArgs = fnMatch[<span class="number">2</span>].split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">var</span> fnBody = fnMatch[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果函数字符串中用名字递归调用自己，我们则relace为arguments.callee</span></span><br><span class="line">    <span class="comment">// 函数名前面和后面必然有边界符才替换</span></span><br><span class="line">    <span class="keyword">if</span> (fnName) &#123;</span><br><span class="line">      fnBody = fnMatch[<span class="number">3</span>].replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+ fnName + <span class="string">'\\b'</span>), <span class="string">'arguments.callee'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">Function</span>(...fnArgs, fnBody); <span class="comment">// 这里要借助... 不然很难展开参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种，一种比较hack的方法，替换函数名字，增加立即调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传给Function一个带有function声明的函数字符串的话，一定需要函数名，</span></span><br><span class="line">    <span class="comment">// 而且返回的函数被匿名函数包裹，我们通过在字符串后面添加立即执行函数来执行</span></span><br><span class="line">    <span class="comment">// 由于这个函数时被封闭的，所以名字可以随意</span></span><br><span class="line">    <span class="comment">// var fnString = src.toString().replace(/[\r\n]*\s+/g, ' ');</span></span><br><span class="line">    <span class="comment">// var fnMatch = fnString.match(/^function\s*(?:([\w\$]*))/);</span></span><br><span class="line">    <span class="comment">// var fnName = fnMatch[1] ? fnMatch[1] : 'noName';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (!fnMatch[1]) &#123;</span></span><br><span class="line">    <span class="comment">//     fnString = fnString.replace('function', 'function ' + fnName);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 追加立即调用</span></span><br><span class="line">    <span class="comment">// fnString += ';' + fnName + '.apply(this, [].slice.call(arguments));'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// newValue = new Function(fnString); // 这里会返回一个匿名函数，匿名函数中包裹原来的函数和函数调用</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(src)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个正则字符串分为两种情况，我们只需要处理字面量</span></span><br><span class="line">    <span class="comment">// 1. /^abc/ 这种是字面量</span></span><br><span class="line">    <span class="comment">// 2. 还有通过RegExp创建的 ^abc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reg = src.toString();</span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> last = reg.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> patten = reg.slice(start, last);</span><br><span class="line">    <span class="keyword">var</span> end = reg.slice(last+<span class="number">1</span>); <span class="comment">// i、g、m ...</span></span><br><span class="line"></span><br><span class="line">    newValue = <span class="keyword">new</span> <span class="built_in">RegExp</span>(patten, end);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(src) || isObject(src))&#123; <span class="comment">// array and object</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点缓存中查找如果找到，则不用递归</span></span><br><span class="line">    <span class="keyword">var</span> current = nodesMap.find(src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!current) &#123; <span class="comment">// 如果没找到</span></span><br><span class="line">      <span class="comment">// 如果没找到，则创建新地址</span></span><br><span class="line">      newValue = isArray(src) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 每当访问一个节点的时候，会做两件事</span></span><br><span class="line">      <span class="comment">// 一是保存旧地址，而是创建新地址</span></span><br><span class="line">      nodesMap.add(&#123;</span><br><span class="line">        oldSrc: src,</span><br><span class="line">        newSrc: newValue,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src.hasOwnProperty(item)) &#123;  <span class="comment">//防止继承属性</span></span><br><span class="line">          newValue[item] = cloneObject(src[item]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果该节点被访问过，必然已经创建了新地址，则指向新地址即可</span></span><br><span class="line">      newValue = current.newSrc;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">// end else</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理一些克隆之外的工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = cloneObject(src);</span><br><span class="line"></span><br><span class="line">  nodesMap.reset();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要增加了几个东西</p>
<ul>
<li>首先是nodesMap，保存了一个已访问列表，每个元素都保存了一个节点的新地址和旧地址</li>
<li>当判断是对象类型的时候，就从nodesMap中查找该对象<ul>
<li>如果找到，则说明已经被访问过，并且肯定被复制了，就把新地址返回即可，不用再递归</li>
<li>如果没找到，则说明还是第一次访问，就创建新对象，并在nodesMap中新增访问节点，保存了被复制的对象的旧地址和新地址</li>
</ul>
</li>
<li>增加了一次cloneDeep的调用，这是由于cloneObject完成的时候，需要做一些清理工作</li>
</ul>
<p>上面的就是完整思路和代码了</p>
<p>其实还有 Symbol 类型的数据没处理，这个我想了下，Symbol 是一个生成一个唯一标识符，我知道有全局注册表，但是如果从全局注册表拿出来的话，那个Symbol就是原来的，如果生成一个新的话，是否有必要？而且Symbol数据类型对于用户几乎是不可见的</p>
<p>所以对于是否拷贝 Symbol 我持保留态度</p>
<p>如有问题，欢迎交流</p>
<p>biu -。-</p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="https://raw.githubusercontent.com/Archmee/lkd2d97zvb5fvz89feyhwr98v/master/gitblog/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> 神无 </p>
      <p class="subtitle"> 舍悟离迷，六尘不改。 </p>
    <div>
  </section>

  <section class="share-btns">
    <p> share it if you like it. </p>
    <!-- <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text= id="简介"><a href="#简"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>
 -->
  </section>
</div>


  
</main>

</body>
</html>
